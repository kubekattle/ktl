<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ktl Deploy Visualize</title>
  <style>
    :root {
      color-scheme: light;
      --surface: rgba(255,255,255,0.9);
      --surface-soft: rgba(255,255,255,0.82);
      --border: rgba(15,23,42,0.12);
      --text: #0f172a;
      --muted: rgba(15,23,42,0.65);
      --accent: #2563eb;
      --chip-bg: rgba(37,99,235,0.08);
      --chip-text: #1d4ed8;
      --warn: #fbbf24;
      --fail: #ef4444;
      --sparkline-color: #0ea5e9;
      --ease: cubic-bezier(.16,1,.3,1);
    }
    * { box-sizing:border-box; }
    body {
      font-family: "SF Pro Display","SF Pro Text",-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      margin:0;
      min-height:100vh;
      padding:48px 56px 72px;
      background:radial-gradient(circle at 20% 20%, #ffffff, #e9edf5 45%, #dce3f1);
      color:var(--text);
    }
    .chrome { max-width:1200px; margin:0 auto; }
    .layout {
      display:flex;
      gap:32px;
      margin-top:32px;
      align-items:flex-start;
      width:100%;
      flex-wrap:wrap;
    }
    .panel {
      background:var(--surface);
      border-radius:28px;
      border:1px solid var(--border);
      padding:32px;
      box-shadow:0 40px 80px rgba(16,23,36,0.12);
      backdrop-filter:blur(18px);
    }
    .hero-panel {
      flex:1;
      position:relative;
      background:linear-gradient(140deg,rgba(255,255,255,0.95),rgba(231,239,255,0.85));
      overflow:hidden;
    }
    .hero-panel::after {
      content:"";
      position:absolute;
      inset:12px;
      border-radius:24px;
      border:1px solid rgba(255,255,255,0.4);
      pointer-events:none;
    }
    .hero-panel > * { position:relative; }
    .tree-panel {
      flex:0 1 360px;
      min-height:520px;
      display:flex;
      flex-direction:column;
      gap:20px;
      position:relative;
    }
    .manifest-panel {
      flex:1 1 640px;
      min-height:520px;
      display:flex;
      flex-direction:column;
      gap:24px;
    }
    .hero-panel h3 { margin:0 0 0.6rem; font-size:1rem; }
    .timeline {
      list-style:none;
      padding:0;
      margin:0;
      display:flex;
      flex-direction:column;
      gap:16px;
    }
    .timeline li {
      position:relative;
      padding-left:24px;
      font-size:0.95rem;
      color:var(--text);
    }
    .timeline li .dot {
      width:10px;
      height:10px;
      border-radius:50%;
      background:var(--accent);
      position:absolute;
      left:0;
      top:0.45rem;
    }
    .timeline li strong {
      display:block;
      font-weight:600;
    }
    .timeline li small {
      display:block;
      margin-top:2px;
      color:var(--muted);
      font-size:0.85rem;
    }
    .timeline li.warn .dot { background:var(--warn); }
    .timeline li.warn strong { color:var(--warn); }
    .timeline li.fail .dot { background:var(--fail); }
    .timeline li.fail strong { color:var(--fail); }
    .runbook-card pre.snippet {
      background:#0f172a;
      color:#e2e8f0;
      padding:0.8rem;
      border-radius:12px;
      overflow:auto;
      font-size:0.9rem;
      font-family:"SFMono-Regular","JetBrains Mono","Menlo","Source Code Pro",monospace;
    }
    .cta {
      border:none;
      border-radius:999px;
      background:var(--accent);
      color:#fff;
      font-size:0.9rem;
      padding:0.55rem 1.4rem;
      cursor:pointer;
      transition:box-shadow 0.2s ease, transform 0.2s ease;
    }
    .cta:hover { box-shadow:0 12px 24px rgba(37,99,235,0.25); transform:translateY(-1px); }
    .hero-content {
      display:flex;
      gap:32px;
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .hero-main {
      flex:1 1 420px;
      display:flex;
      flex-direction:column;
      gap:24px;
    }
    .hero-primary { flex:1; }
    .hero-eyebrow {
      text-transform:uppercase;
      letter-spacing:0.22em;
      font-size:0.75rem;
      color:var(--muted);
      margin:0 0 0.4rem;
    }
    .hero-headline {
      font-size:2.4rem;
      letter-spacing:-0.03em;
      margin:0;
    }
    .hero-subtitle {
      margin:0.35rem 0 0;
      color:var(--muted);
      font-size:1rem;
    }
    .hero-chips {
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:1rem;
    }
    .hero-chip {
      border-radius:999px;
      border:1px solid rgba(37,99,235,0.2);
      padding:0.35rem 0.9rem;
      font-size:0.82rem;
      letter-spacing:0.08em;
      text-transform:uppercase;
      color:var(--muted);
      background:var(--chip-bg);
    }
    .hero-chip.positive { color:#16a34a; border-color:rgba(22,163,74,0.35); background:rgba(16,185,129,0.12); }
    .hero-chip.warning { color:var(--warn); border-color:rgba(251,191,36,0.45); background:rgba(251,191,36,0.15); }
    .hero-side {
      flex:0 0 280px;
      display:flex;
      flex-direction:column;
      gap:20px;
    }
    .hero-metrics {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(130px,1fr));
      gap:16px;
    }
    .hero-card {
      border-radius:20px;
      padding:16px;
      background:rgba(255,255,255,0.72);
      border:1px solid rgba(15,23,42,0.08);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);
    }
    .hero-card span {
      display:block;
      text-transform:uppercase;
      letter-spacing:0.12em;
      font-size:0.72rem;
      color:var(--muted);
    }
    .hero-card strong {
      display:block;
      font-size:2rem;
      margin-top:0.35rem;
      letter-spacing:-0.02em;
      color:var(--text);
    }
    .info-banner {
      margin-top:16px;
      border-radius:20px;
      border:1px solid rgba(251,191,36,0.6);
      background:rgba(251,191,36,0.15);
      color:#92400e;
      padding:12px 18px;
      font-size:0.95rem;
    }
    .meta-list {
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(160px,1fr));
      gap:12px;
      margin:0;
    }
    .meta-list div {
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .meta-list dt {
      font-size:0.72rem;
      text-transform:uppercase;
      letter-spacing:0.2em;
      color:var(--muted);
      margin:0;
    }
    .meta-list dd {
      margin:0;
      font-size:1rem;
      color:var(--text);
    }
    .runbook-card {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .warning-list {
      margin:0;
      padding-left:1rem;
      color:var(--warn);
      font-size:0.92rem;
    }
    .hero-meta-block {
      border-radius:20px;
      border:1px solid rgba(15,23,42,0.08);
      background:rgba(255,255,255,0.8);
      padding:20px;
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.5);
      backdrop-filter:blur(10px);
    }
    .hero-meta-block h3 {
      margin:0 0 0.4rem;
      font-size:1rem;
    }
    .view-toggle {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-bottom:4px;
    }
    .view-pane[hidden] { display:none !important; }
    .chip {
      border-radius:999px;
      border:1px solid var(--border);
      padding:6px 16px;
      text-transform:uppercase;
      letter-spacing:0.12em;
      font-size:0.78rem;
      font-weight:600;
      background:var(--surface-soft);
      color:var(--muted);
      cursor:pointer;
      transition:background 180ms var(--ease), color 180ms var(--ease), border-color 180ms var(--ease);
    }
    .chip.active {
      background:var(--accent);
      border-color:var(--accent);
      color:#fff;
      box-shadow:0 8px 24px rgba(37,99,235,0.25);
    }
    .tree-controls {
      position:sticky;
      top:24px;
      z-index:2;
      background:var(--surface);
      padding-bottom:12px;
      border-bottom:1px solid rgba(15,23,42,0.08);
    }
    .tree-controls .view-toggle { margin-bottom:12px; }
    .tree-filters {
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .tree-header {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:12px;
      flex-wrap:wrap;
    }
    .tree-header h2 { margin:0; font-size:1.4rem; }
    .tree-header .muted { margin-top:4px; font-size:0.9rem; }
    .tree-search {
      display:flex;
      gap:8px;
      align-items:center;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px 6px 16px;
      background:var(--surface-soft);
    }
    .tree-search input {
      border:none;
      flex:1;
      font-size:0.95rem;
      outline:none;
      background:transparent;
      color:var(--text);
    }
    .tree-search button {
      border:none;
      background:var(--accent);
      color:#fff;
      border-radius:999px;
      padding:6px 14px;
      font-size:0.82rem;
      cursor:pointer;
    }
    .tree-search button:disabled {
      opacity:0.4;
      cursor:not-allowed;
      background:rgba(37,99,235,0.3);
    }
    .tree-chips,
    .change-chips {
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .filter-status {
      min-height:1.2rem;
      font-size:0.85rem;
      color:var(--muted);
    }
    .tree-scroll {
      flex:1;
      overflow:auto;
      border:1px solid var(--border);
      border-radius:24px;
      padding:12px 16px;
      background:var(--surface-soft);
    }
    .tree {
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    details.tree-node {
      border:1px solid var(--border);
      border-radius:20px;
      padding:12px 14px;
      background:#fff;
    }
    details.tree-node.level-kind { margin-top:8px; }
    details.tree-node[open] > summary .twist { transform:rotate(90deg); }
    summary {
      list-style:none;
      cursor:pointer;
      display:flex;
      align-items:center;
      gap:12px;
      font-weight:600;
      text-transform:capitalize;
    }
    summary::-webkit-details-marker { display:none; }
    .twist {
      transition:transform 0.2s ease;
      font-size:0.9rem;
      color:var(--muted);
    }
    .count-pill {
      font-size:0.75rem;
      padding:2px 10px;
      border-radius:999px;
      background:var(--chip-bg);
      color:var(--accent);
    }
    .resource-list {
      list-style:none;
      margin:12px 0 0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .resource-list li.hidden { display:none; }
    .resource-btn {
      width:100%;
      border:1px solid rgba(15,23,42,0.08);
      border-radius:16px;
      padding:10px 14px;
      text-align:left;
      font-size:0.95rem;
      background:rgba(15,23,42,0.02);
      color:var(--text);
      cursor:pointer;
      transition:border-color 0.2s ease, background 0.2s ease;
      display:flex;
      gap:8px;
      align-items:center;
    }
    .resource-btn.change-create { border-left:4px solid #22c55e; }
    .resource-btn.change-update { border-left:4px solid var(--warn); }
    .resource-btn.change-delete { border-left:4px solid var(--fail); }
    .resource-btn:hover,
    .resource-btn:focus-visible {
      border-color:var(--accent);
      outline:none;
      background:rgba(37,99,235,0.08);
    }
    .resource-btn.selected {
      border-color:var(--accent);
      background:rgba(37,99,235,0.12);
    }
    .resource-btn.impact-upstream {
      border-color:#f97316;
      background:rgba(249,115,22,0.12);
    }
    .resource-btn.impact-downstream {
      border-color:#0ea5e9;
      background:rgba(14,165,233,0.12);
    }
    .resource-pill {
      margin-left:auto;
      font-size:0.7rem;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(15,23,42,0.08);
      color:var(--muted);
    }
    .resource-pill.strong {
      background:var(--chip-bg);
      color:var(--accent);
    }
    .selection-head {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .selection-head h2 { margin:0; font-size:1.5rem; }
    .breadcrumbs {
      font-size:0.95rem;
      margin-top:6px;
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      color:var(--muted);
    }
    .breadcrumbs span::after { content:'/'; margin-left:6px; color:var(--border); }
    .breadcrumbs span:last-child::after { content:""; }
    .meta-badges { display:flex; flex-wrap:wrap; gap:8px; }
    .badge {
      font-size:0.8rem;
      padding:4px 10px;
      border-radius:999px;
      background:var(--surface-soft);
      border:1px solid var(--border);
      color:var(--muted);
    }
    .dependency-panel {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(200px,1fr));
      gap:16px;
    }
    .dependency-panel h3 { margin:0; font-size:1rem; }
    .dependency-list {
      list-style:none;
      margin:8px 0 0;
      padding:0;
      max-height:140px;
      overflow:auto;
      font-size:0.9rem;
      border:1px solid var(--border);
      border-radius:16px;
      background:var(--surface-soft);
    }
    .dependency-list li {
      padding:8px 12px;
      border-bottom:1px solid rgba(15,23,42,0.08);
      display:flex;
      flex-direction:column;
      gap:2px;
      color:var(--text);
    }
    .dependency-list li:last-child { border-bottom:none; }
    .dependency-list li.impact-upstream { background:rgba(249,115,22,0.08); }
    .dependency-list li.impact-downstream { background:rgba(14,165,233,0.08); }
    .dependency-list .empty { color:var(--muted); }
    .dependency-link {
      border:none;
      background:none;
      color:var(--accent);
      text-align:left;
      font:inherit;
      cursor:pointer;
      padding:0;
    }
    .dependency-link:focus-visible { outline:2px solid var(--accent); outline-offset:2px; }
    .dependency-reason { font-size:0.8rem; color:var(--muted); }
    .manifest-toggle {
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .manifest-toggle button {
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 16px;
      background:#fff;
      cursor:pointer;
      font-size:0.85rem;
    }
    .manifest-toggle button.active {
      border-color:var(--accent);
      color:#fff;
      background:var(--accent);
    }
    .manifest-view {
      flex:1;
      border-radius:24px;
      border:1px solid var(--border);
      background:#0f172a;
      color:#e2e8f0;
      font-family:"SFMono-Regular","Consolas","Liberation Mono",monospace;
      font-size:0.85rem;
      padding:20px;
      overflow:auto;
      white-space:pre;
      line-height:1.4;
    }
    .manifest-view[data-view="diff"] { background:#111827; }
    .download-actions {
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .download-actions button {
      border:1px solid var(--border);
      border-radius:12px;
      padding:6px 16px;
      background:var(--surface-soft);
      color:var(--text);
      cursor:pointer;
      font-size:0.85rem;
    }
    .download-actions button:disabled {
      opacity:0.5;
      cursor:not-allowed;
    }
    .compare-controls {
      display:flex;
      align-items:center;
      gap:12px;
      flex-wrap:wrap;
    }
    .compare-controls input[type="file"] { display:none; }
    .compare-columns {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
      gap:16px;
    }
    .compare-manifest {
      border-radius:16px;
      border:1px solid var(--border);
      background:#0f172a;
      color:#e2e8f0;
      padding:16px;
      min-height:160px;
      font-family:"SFMono-Regular","Consolas","Liberation Mono",monospace;
      font-size:0.8rem;
      line-height:1.4;
      overflow:auto;
      white-space:pre;
    }
    .graph-pane { display:flex; flex-direction:column; gap:16px; }
    .graph-header { display:flex; justify-content:space-between; flex-wrap:wrap; gap:12px; }
    .graph-legend { display:flex; gap:16px; align-items:center; font-size:0.85rem; color:var(--muted); }
    .legend-item { display:flex; align-items:center; gap:6px; }
    .legend-dot {
      width:12px;
      height:12px;
      border-radius:999px;
      display:inline-block;
      background:var(--border);
    }
    .legend-dot.change-create { background:#16a34a; }
    .legend-dot.change-update { background:var(--warn); }
    .legend-dot.legend-unchanged { background:rgba(15,23,42,0.2); }
    .graph-canvas {
      border:1px solid var(--border);
      border-radius:28px;
      background:var(--surface-soft);
      min-height:460px;
      position:relative;
      overflow:auto;
    }
    .graph-canvas svg {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }
    .graph-nodes {
      position:relative;
      min-height:460px;
    }
    .graph-node {
      position:absolute;
      transform:translate(-50%,-50%);
      border-radius:14px;
      padding:6px 14px;
      border:1px solid rgba(15,23,42,0.15);
      background:#fff;
      box-shadow:0 8px 24px rgba(16,23,36,0.12);
      font-size:0.85rem;
      cursor:pointer;
      transition:box-shadow 180ms var(--ease), border-color 180ms var(--ease);
    }
    .graph-node.change-create { border-left:4px solid #22c55e; }
    .graph-node.change-update { border-left:4px solid var(--warn); }
    .graph-node.change-delete { border-left:4px solid var(--fail); }
    .graph-node.selected { border-color:var(--accent); box-shadow:0 8px 28px rgba(37,99,235,0.25); }
    .graph-edge {
      fill:none;
      stroke:rgba(15,23,42,0.25);
      stroke-width:2;
      stroke-linecap:round;
    }
    .graph-edge.impact-upstream { stroke:#f97316; stroke-width:3; }
    .graph-edge.impact-downstream { stroke:#0ea5e9; stroke-width:3; }
    .muted { color:var(--muted); }
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
    [hidden] { display:none !important; }
    @media (max-width:1100px) {
      body { padding:24px 24px 48px; }
      .layout { flex-direction:column; }
      .tree-panel,
      .manifest-panel { width:100%; }
      .hero-side,
      .hero-main { flex:1 1 100%; }
    }
    @media (prefers-reduced-motion: no-preference) {
      .panel {
        opacity:0;
        transform:translateY(16px);
        animation:panelIn 360ms var(--ease) forwards;
        animation-delay:calc(var(--panel-delay,0) * 60ms);
      }
      @keyframes panelIn {
        from { opacity:0; transform:translateY(16px); }
        to { opacity:1; transform:translateY(0); }
      }
    }
    @media print {
      body { background:#fff; padding:32px; }
      .graph-pane,
      .view-toggle,
      .chip,
      .cta,
      .info-banner { display:none !important; }
      .panel { box-shadow:none !important; backdrop-filter:none; }
    }
  </style>
</head>
<body>
  <div class="chrome">
    <p id="releaseSummary" class="sr-only"></p>
    <section class="panel hero-panel" aria-label="Release summary">
      <div class="hero-content">
        <div class="hero-main">
          <div class="hero-primary">
            <p class="hero-eyebrow">ktl deploy</p>
            <h2 class="hero-headline" id="heroHeadline">Deployment overview</h2>
            <p class="hero-subtitle" id="heroSubtitle">Awaiting release data…</p>
            <div id="heroChips" class="hero-chips"></div>
            <p class="hero-subtitle" id="heroTimestamp"></p>
          </div>
          <div class="hero-metrics">
            <div class="hero-card">
              <span>Creates</span>
              <strong id="heroCreates">0</strong>
            </div>
            <div class="hero-card">
              <span>Updates</span>
              <strong id="heroUpdates">0</strong>
            </div>
            <div class="hero-card">
              <span>Deletes</span>
              <strong id="heroDeletes">0</strong>
            </div>
            <div class="hero-card">
              <span>Unchanged</span>
              <strong id="heroUnchanged">0</strong>
            </div>
          </div>
        </div>
        <div class="hero-side">
          <section class="hero-meta-block">
            <h3>Release details</h3>
            <dl class="meta-list">
              <div>
                <dt>Release</dt>
                <dd id="metaRelease">—</dd>
              </div>
              <div>
                <dt>Namespace</dt>
                <dd id="metaNamespace">—</dd>
              </div>
              <div>
                <dt>Chart</dt>
                <dd id="metaChart">—</dd>
              </div>
              <div>
                <dt>Cluster</dt>
                <dd id="metaCluster">—</dd>
              </div>
              <div>
                <dt>Generated</dt>
                <dd id="metaGenerated">—</dd>
              </div>
            </dl>
          </section>
          <section class="hero-meta-block">
            <h3>Timeline</h3>
            <ul id="timelineList" class="timeline"></ul>
          </section>
          <section id="warningsPanel" class="hero-meta-block" hidden>
            <h3>Warnings</h3>
            <ul id="warningsList" class="warning-list"></ul>
          </section>
          <section id="runbookPanel" class="hero-meta-block runbook-card" hidden>
            <h3>Next steps</h3>
            <p class="muted">Share this command when you're ready to apply the release.</p>
            <pre id="installSnippet" class="snippet">Command will appear after the plan loads.</pre>
            <button id="installCopy" class="cta copy" type="button">Copy install command</button>
          </section>
        </div>
      </div>
    </section>
    <div id="offlineBanner" class="info-banner" hidden>Live cluster data was unavailable when this was generated. Diffs reference the previous release when possible.</div>
    <div class="layout">
      <aside class="panel tree-panel" aria-label="Resource views">
        <div class="tree-controls">
          <div class="view-toggle" role="tablist">
            <button type="button" class="chip active" data-pane-target="tree">Tree</button>
            <button type="button" class="chip" data-pane-target="graph">Graph</button>
          </div>
          <div id="treeFilters" class="tree-filters">
            <div class="tree-header">
              <div>
                <h2>Resource Tree</h2>
                <p class="muted"><span id="resourceTotal">0</span> rendered objects</p>
              </div>
              <div class="tree-actions">
                <button id="expandAll" class="chip" type="button">Expand all</button>
                <button id="collapseAll" class="chip" type="button">Collapse all</button>
              </div>
            </div>
            <label class="tree-search">
              <span class="sr-only">Filter resources</span>
              <input id="treeSearch" type="search" placeholder="Filter by namespace, kind, or name" autocomplete="off" />
              <button id="clearSearch" type="button" disabled>Clear</button>
            </label>
            <div id="kindChips" class="tree-chips" role="group" aria-label="Filter by resource type"></div>
            <div id="changeChips" class="change-chips" role="group" aria-label="Highlight changed resources"></div>
            <p id="filterStatus" class="filter-status" aria-live="polite"></p>
          </div>
        </div>
        <div id="treePane" class="view-pane">
          <div class="tree-scroll">
            <div id="resourceTree" class="tree" role="tree"></div>
          </div>
        </div>
        <div id="graphPane" class="view-pane graph-pane" hidden>
          <div class="graph-header">
            <div>
              <h2>Dependency Graph</h2>
              <p class="muted">Namespaces render as columns; edges show workload references.</p>
            </div>
            <div class="graph-legend">
              <span class="legend-item"><span class="legend-dot change-create"></span>Create</span>
              <span class="legend-item"><span class="legend-dot change-update"></span>Update</span>
              <span class="legend-item"><span class="legend-dot legend-unchanged"></span>Unchanged</span>
            </div>
          </div>
          <div id="graphCanvas" class="graph-canvas">
            <svg id="graphEdgesLayer" aria-hidden="true"></svg>
            <div id="graphNodesLayer" class="graph-nodes"></div>
          </div>
          <p id="graphEmpty" class="muted" hidden>No resources available to visualize.</p>
        </div>
      </aside>
      <section class="panel manifest-panel">
        <div class="selection-head">
          <div>
            <h2 id="selectionTitle">Select a resource</h2>
            <div id="breadcrumbs" class="breadcrumbs muted">No resource selected</div>
          </div>
          <button id="copyLinkBtn" class="chip" type="button">Copy link</button>
        </div>
          <div id="metaBadges" class="meta-badges"></div>
          <div class="dependency-panel">
            <div>
              <h3>Depends on</h3>
              <ul id="dependsOnList" class="dependency-list"></ul>
            </div>
            <div>
              <h3>Referenced by</h3>
              <ul id="referencedByList" class="dependency-list"></ul>
            </div>
          </div>
          <div class="manifest-toggle" role="group" aria-label="Manifest display mode">
            <button type="button" class="active" data-manifest-mode="rendered">Rendered YAML</button>
            <button type="button" data-manifest-mode="diff">Diff vs live</button>
            <span id="diffHint" class="muted"></span>
          </div>
          <pre id="manifestView" class="manifest-view" data-view="rendered" aria-live="polite">Select a resource to view its rendered YAML.</pre>
          <div class="download-actions">
            <button type="button" data-download="rendered">Download rendered YAML</button>
            <button type="button" data-download="diff">Download diff</button>
          </div>
          <div class="compare-controls">
            <label for="compareUpload" class="chip">Load comparison</label>
            <input type="file" id="compareUpload" accept=".json,.html,.htm,.txt" />
            <span id="compareMeta" class="muted"></span>
          </div>
          <div id="compareColumns" class="compare-columns" hidden>
            <div>
              <h3>Base Render</h3>
              <pre id="compareBaseView" class="compare-manifest">Select a resource to view its rendered YAML.</pre>
            </div>
            <div>
              <h3 id="compareTitle">Comparison Render</h3>
              <pre id="compareOtherView" class="compare-manifest">Load a comparison artifact to see its YAML.</pre>
            </div>
          </div>
          <p id="manifestStatus" class="muted" aria-live="polite"></p>
        </section>
      </div>
    </div>
  </div>
  <script id="vizData" type="application/json">__DATA__</script>
  <script>
    (function() {
      'use strict';
      var storageKey = 'ktlDeployVisualizeState';
      var dataEl = document.getElementById('vizData');
      var dataset = dataEl ? JSON.parse(dataEl.textContent || '{}') : {};
      var treeContainer = document.getElementById('resourceTree');
      var manifestView = document.getElementById('manifestView');
      var metaBadges = document.getElementById('metaBadges');
      var selectionTitle = document.getElementById('selectionTitle');
      var breadcrumbs = document.getElementById('breadcrumbs');
      var totalEl = document.getElementById('resourceTotal');
      var searchInput = document.getElementById('treeSearch');
      var clearSearchBtn = document.getElementById('clearSearch');
      var filterStatus = document.getElementById('filterStatus');
      var expandAllBtn = document.getElementById('expandAll');
      var collapseAllBtn = document.getElementById('collapseAll');
      var releaseSummaryEl = document.getElementById('releaseSummary');
      var chipContainer = document.getElementById('kindChips');
      var changeChipContainer = document.getElementById('changeChips');
      var manifestStatus = document.getElementById('manifestStatus');
      var dependsOnList = document.getElementById('dependsOnList');
      var referencedByList = document.getElementById('referencedByList');
      var manifestModeButtons = document.querySelectorAll('[data-manifest-mode]');
      var downloadButtons = document.querySelectorAll('[data-download]');
      var offlineBanner = document.getElementById('offlineBanner');
      var diffHint = document.getElementById('diffHint');
      var copyLinkBtn = document.getElementById('copyLinkBtn');
      var compareUpload = document.getElementById('compareUpload');
      var compareMeta = document.getElementById('compareMeta');
      var compareColumns = document.getElementById('compareColumns');
      var compareBaseView = document.getElementById('compareBaseView');
      var compareOtherView = document.getElementById('compareOtherView');
      var compareTitle = document.getElementById('compareTitle');
      var heroHeadline = document.getElementById('heroHeadline');
      var heroSubtitle = document.getElementById('heroSubtitle');
      var heroTimestamp = document.getElementById('heroTimestamp');
      var heroChips = document.getElementById('heroChips');
      var heroCreates = document.getElementById('heroCreates');
      var heroUpdates = document.getElementById('heroUpdates');
      var heroDeletes = document.getElementById('heroDeletes');
      var heroUnchanged = document.getElementById('heroUnchanged');
      var metaRelease = document.getElementById('metaRelease');
      var metaNamespace = document.getElementById('metaNamespace');
      var metaChart = document.getElementById('metaChart');
      var metaCluster = document.getElementById('metaCluster');
      var metaGenerated = document.getElementById('metaGenerated');
      var timelineList = document.getElementById('timelineList');
      var warningsPanel = document.getElementById('warningsPanel');
      var warningsList = document.getElementById('warningsList');
      var runbookPanel = document.getElementById('runbookPanel');
      var installSnippet = document.getElementById('installSnippet');
      var installCopy = document.getElementById('installCopy');
      var paneButtons = document.querySelectorAll('[data-pane-target]');
      var treePane = document.getElementById('treePane');
      var graphPane = document.getElementById('graphPane');
      var treeFiltersEl = document.getElementById('treeFilters');
      var graphCanvas = document.getElementById('graphCanvas');
      var graphNodesLayer = document.getElementById('graphNodesLayer');
      var graphEdgesLayer = document.getElementById('graphEdgesLayer');
      var graphEmpty = document.getElementById('graphEmpty');

      var state = loadState();
      var manifests = dataset.manifests || {};
      var liveManifests = dataset.liveManifests || {};
      var manifestDiffs = dataset.manifestDiffs || {};
      var changeKinds = dataset.changeKinds || {};
      var manifestMode = state.manifestMode || 'rendered';
      var pendingFilterTerm = state.filterText || '';
      var activeBucket = state.bucket || 'all';
      var showChangedOnly = !!state.showChanged;
      var resourceEntries = [];
      var resourceEntryLookup = {};
      var dependencyItemLookup = {};
      var namespaceSections = [];
      var activeButton = null;
      var pendingHashUpdate = false;
      var treeReady = false;
      var treeReadyCallbacks = [];
      var LARGE_NAMESPACE_THRESHOLD = 25;
      var CHUNK_SIZE = 4;
      var compareDataset = null;
      var compareManifests = dataset.compareManifests || null;
      var compareSummary = dataset.compareSummary || '';
      var changedIds = new Set();
      var currentNode = null;
      var impactButtonTargets = [];
      var impactListTargets = [];
      var graphNodeElements = {};
      var graphEdgeElements = [];
      var graphImpactNodes = [];
      var graphImpactEdges = [];
      var graphPositions = {};
      var graphSelectedId = null;
      var graphRenderPending = false;
      var numberFormatter = (typeof Intl !== 'undefined' && Intl.NumberFormat) ? new Intl.NumberFormat() : null;

      recomputeChangedIds();

      var rawNodes = Array.isArray(dataset.nodes) ? dataset.nodes : [];
      var nodes = rawNodes.map(normalizeNode).sort(function(a, b) {
        return a.namespace.localeCompare(b.namespace) ||
          a.kind.localeCompare(b.kind) ||
          a.displayName.localeCompare(b.displayName);
      });
      var edges = Array.isArray(dataset.edges) ? dataset.edges : [];
      var dependencyMap = buildDependencyMap(edges);

      if (offlineBanner) {
        offlineBanner.hidden = !dataset.offlineFallback;
      }

      if (releaseSummaryEl) {
        var parts = [];
        if (dataset.release) parts.push('Release ' + dataset.release);
        if (dataset.namespace) parts.push('ns/' + dataset.namespace);
        if (dataset.chart) parts.push(dataset.chart);
        releaseSummaryEl.textContent = parts.join(' · ');
      }

      if (totalEl) {
        totalEl.textContent = nodes.length;
      }

      if (searchInput) {
        searchInput.value = pendingFilterTerm;
      }

      var kindBuckets = [
        { id: 'all', label: 'All kinds', kinds: null },
        { id: 'workload', label: 'Workloads', kinds: ['deployment','statefulset','daemonset','job','cronjob','pod','replicaset'] },
        { id: 'network', label: 'Networking', kinds: ['service','ingress','httproute','gateway'] },
        { id: 'config', label: 'Config', kinds: ['configmap','secret','serviceaccount'] },
        { id: 'storage', label: 'Storage', kinds: ['persistentvolumeclaim','persistentvolume'] },
        { id: 'other', label: 'Other', kinds: [] }
      ];

      setupManifestToggle();
      buildKindChips();
      buildChangeChip();
      bindPaneToggle();
      buildTree();
      bindSearch();
      bindExpandCollapse();
      bindHashWatcher();
      bindCopyLink();
      bindDownloadButtons();
      bindCompareUpload();
      applyEmbeddedCompare();
      renderGraph();
      window.addEventListener('resize', scheduleGraphRender);

      onTreeReady(function() {
        applyFilter(pendingFilterTerm);
        restoreSelection();
      });

      updateDiffHint();
      updateDownloadButtons();
      hydrateHero();
      hydrateReleaseDetails();
      hydrateTimeline();
      hydrateWarnings();
      hydrateRunbook();

      function loadState() {
        try {
          var raw = window.localStorage.getItem(storageKey);
          return raw ? JSON.parse(raw) : {};
        } catch (err) {
          return {};
        }
      }

      function persistState(patch) {
        state = Object.assign({}, state, patch);
        try {
          window.localStorage.setItem(storageKey, JSON.stringify(state));
        } catch (err) {
          /* ignore */
        }
      }

      function onTreeReady(fn) {
        if (treeReady) {
          fn();
        } else {
          treeReadyCallbacks.push(fn);
        }
      }

      function resolveBucket(kind) {
        kind = (kind || '').toLowerCase();
        for (var i = 1; i < kindBuckets.length; i++) {
          var lane = kindBuckets[i];
          if (!lane.kinds || lane.kinds.length === 0) continue;
          if (lane.kinds.indexOf(kind) !== -1) {
            return lane.id;
          }
        }
        return 'other';
      }

      function normalizeNode(raw) {
        var namespace = raw.namespace || raw.Namespace || dataset.namespace || 'cluster';
        var name = raw.name || raw.Name || raw.id || raw.ID || 'resource';
        var kind = (raw.kind || raw.Kind || 'resource').toLowerCase();
        var fallbackId = (namespace || 'cluster').toLowerCase() + '|' + kind + '|' + name.toLowerCase();
        var idValue = (raw.id || raw.ID || raw.Id || fallbackId).toLowerCase();
        var changeKind = (changeKinds && changeKinds[idValue]) ? String(changeKinds[idValue]).toLowerCase() : '';
        return {
          original: raw,
          id: idValue,
          displayName: name,
          kind: kind,
          kindLabel: titleCase(kind),
          namespace: namespace,
          meta: raw.meta || raw.Meta || {},
          category: resolveBucket(kind),
          changeKind: changeKind
        };
      }

      function setupManifestToggle() {
        manifestModeButtons.forEach(function(button) {
          var mode = button.getAttribute('data-manifest-mode');
          button.classList.toggle('active', mode === manifestMode);
          button.addEventListener('click', function() {
            if (!mode || manifestMode === mode) return;
            manifestMode = mode;
            persistState({ manifestMode: manifestMode });
            manifestModeButtons.forEach(function(btn) {
              btn.classList.toggle('active', btn === button);
            });
            if (manifestView) {
              manifestView.setAttribute('data-view', manifestMode === 'diff' ? 'diff' : 'rendered');
            }
            if (currentNode) {
              renderManifest(currentNode);
            }
            updateDiffHint();
            updateDownloadButtons();
          });
        });
        if (manifestView) {
          manifestView.setAttribute('data-view', manifestMode === 'diff' ? 'diff' : 'rendered');
        }
      }

      function buildKindChips() {
        if (!chipContainer) return;
        chipContainer.innerHTML = '';
        kindBuckets.forEach(function(bucket) {
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'chip' + (bucket.id === activeBucket ? ' active' : '');
          btn.textContent = bucket.label;
          btn.addEventListener('click', function() {
            if (activeBucket === bucket.id) return;
            activeBucket = bucket.id;
            persistState({ bucket: activeBucket });
            chipContainer.querySelectorAll('.chip').forEach(function(chip) {
              chip.classList.toggle('active', chip === btn);
            });
            applyFilter(pendingFilterTerm);
          });
          chipContainer.appendChild(btn);
        });
      }

      function buildChangeChip() {
        if (!changeChipContainer) return;
        changeChipContainer.innerHTML = '';
        var btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip' + (showChangedOnly ? ' active' : '');
        btn.textContent = 'Show changed only';
        btn.addEventListener('click', function() {
          showChangedOnly = !showChangedOnly;
          btn.classList.toggle('active', showChangedOnly);
          persistState({ showChanged: showChangedOnly });
          applyFilter(pendingFilterTerm);
        });
        changeChipContainer.appendChild(btn);
      }

      function bindPaneToggle() {
        if (!paneButtons || paneButtons.length === 0) return;
        paneButtons.forEach(function(button) {
          button.addEventListener('click', function() {
            var target = button.getAttribute('data-pane-target') || 'tree';
            setActivePane(target);
          });
        });
        setActivePane('tree');
      }

      function setActivePane(target) {
        target = target === 'graph' ? 'graph' : 'tree';
        paneButtons.forEach(function(button) {
          button.classList.toggle('active', button.getAttribute('data-pane-target') === target);
        });
        if (treePane) {
          treePane.hidden = target !== 'tree';
        }
        if (graphPane) {
          graphPane.hidden = target !== 'graph';
        }
        if (treeFiltersEl) {
          treeFiltersEl.hidden = target !== 'tree';
        }
        if (target === 'graph') {
          scheduleGraphRender();
          if (currentNode) {
            highlightGraphSelection(currentNode);
            scrollGraphIntoView(currentNode);
          }
        }
      }

      function buildTree() {
        if (!treeContainer) return;
        treeReady = false;
        resourceEntries = [];
        resourceEntryLookup = {};
        dependencyItemLookup = {};
        namespaceSections = [];
        treeContainer.innerHTML = '';
        if (nodes.length === 0) {
          treeContainer.innerHTML = '<p class="muted">Chart rendered zero objects.</p>';
          finishTreeRender();
          return;
        }
        var groups = groupBy(nodes, function(item) { return item.namespace || 'cluster'; });
        var index = 0;
        function renderChunk() {
          if (index >= groups.length) {
            finishTreeRender();
            return;
          }
          var frag = document.createDocumentFragment();
          for (var i = 0; i < CHUNK_SIZE && index < groups.length; i++, index++) {
            frag.appendChild(createNamespaceSection(groups[index]));
          }
          treeContainer.appendChild(frag);
          schedule(renderChunk);
        }
        renderChunk();
      }

      function scheduleGraphRender() {
        if (graphRenderPending) return;
        graphRenderPending = true;
        (window.requestAnimationFrame || window.setTimeout)(function() {
          graphRenderPending = false;
          renderGraph();
        }, 16);
      }

      function renderGraph() {
        if (!graphNodesLayer || !graphEdgesLayer || !graphCanvas) return;
        graphNodesLayer.innerHTML = '';
        graphEdgesLayer.innerHTML = '';
        graphNodeElements = {};
        graphEdgeElements = [];
        graphImpactNodes = [];
        graphImpactEdges = [];
        graphPositions = {};
        if (!nodes.length) {
          if (graphEmpty) graphEmpty.hidden = false;
          return;
        }
        if (graphEmpty) graphEmpty.hidden = true;
        var groups = groupBy(nodes, function(item) { return item.namespace || 'cluster'; });
        var namespaceIndex = {};
        groups.forEach(function(group, idx) {
          namespaceIndex[group.key] = idx;
        });
        var colSpacing = 220;
        var rowSpacing = 90;
        var marginX = 120;
        var marginY = 90;
        var counts = {};
        var maxRows = 0;
        nodes.forEach(function(node) {
          var ns = node.namespace || 'cluster';
          var col = namespaceIndex[ns] || 0;
          var row = counts[ns] || 0;
          counts[ns] = row + 1;
          var x = marginX + col * colSpacing;
          var y = marginY + row * rowSpacing;
          graphPositions[node.id] = { x: x, y: y };
          if (row+1 > maxRows) {
            maxRows = row + 1;
          }
        });
        var width = marginX * 2 + Math.max(0, groups.length-1) * colSpacing;
        var height = marginY * 2 + Math.max(0, maxRows-1) * rowSpacing;
        setGraphCanvasSize(width, height);
        nodes.forEach(function(node) {
          var pos = graphPositions[node.id];
          if (!pos) return;
          var btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'graph-node';
          if (node.changeKind) {
            btn.classList.add('change-' + node.changeKind);
          }
          btn.textContent = node.displayName;
          btn.style.left = pos.x + 'px';
          btn.style.top = pos.y + 'px';
          btn.title = (node.namespace || 'cluster') + ' · ' + node.kindLabel;
          btn.addEventListener('click', function() {
            selectNode(node);
          });
          graphNodesLayer.appendChild(btn);
          graphNodeElements[node.id] = btn;
        });
        edges.forEach(function(edge) {
          var fromId = (edge.From || edge.from || '').toLowerCase();
          var toId = (edge.To || edge.to || '').toLowerCase();
          var from = graphPositions[fromId];
          var to = graphPositions[toId];
          if (!from || !to) return;
          var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', buildEdgePath(from, to));
          path.classList.add('graph-edge');
          graphEdgesLayer.appendChild(path);
          graphEdgeElements.push({ from: fromId, to: toId, element: path });
        });
        highlightGraphSelection(currentNode);
      }

      function setGraphCanvasSize(width, height) {
        if (!graphCanvas) return;
        var minWidth = graphCanvas.clientWidth || 0;
        if (minWidth > width) {
          width = minWidth;
        }
        graphEdgesLayer.setAttribute('viewBox', '0 0 ' + width + ' ' + height);
        graphEdgesLayer.setAttribute('width', width);
        graphEdgesLayer.setAttribute('height', height);
        graphNodesLayer.style.width = width + 'px';
        graphNodesLayer.style.height = height + 'px';
      }

      function buildEdgePath(from, to) {
        var midX = (from.x + to.x) / 2;
        return [
          'M', from.x, from.y,
          'C', midX, from.y,
          midX, to.y,
          to.x, to.y
        ].join(' ');
      }

      function highlightGraphSelection(node) {
        graphSelectedId = node && node.id ? node.id : null;
        Object.keys(graphNodeElements).forEach(function(id) {
          graphNodeElements[id].classList.toggle('selected', id === graphSelectedId);
        });
      }

      function highlightGraphEdges(sourceId, targetId, type) {
        if (!sourceId || !targetId) return;
        graphEdgeElements.forEach(function(edge) {
          if (!edge || !edge.element) return;
          var isMatch = false;
          if (type === 'upstream') {
            isMatch = edge.from === sourceId && edge.to === targetId;
          } else if (type === 'downstream') {
            isMatch = edge.from === targetId && edge.to === sourceId;
          } else {
            isMatch = (edge.from === sourceId && edge.to === targetId) || (edge.from === targetId && edge.to === sourceId);
          }
          if (isMatch) {
            var cls = type === 'downstream' ? 'impact-downstream' : 'impact-upstream';
            edge.element.classList.add(cls);
            graphImpactEdges.push(edge.element);
          }
        });
      }

      function scrollGraphIntoView(node) {
        if (!graphCanvas || !node) return;
        var pos = graphPositions[node.id];
        if (!pos) return;
        var targetLeft = Math.max(pos.x - (graphCanvas.clientWidth || 0) / 2, 0);
        var targetTop = Math.max(pos.y - (graphCanvas.clientHeight || 0) / 2, 0);
        if (typeof graphCanvas.scrollTo === 'function') {
          graphCanvas.scrollTo({ left: targetLeft, top: targetTop, behavior: 'smooth' });
        } else {
          graphCanvas.scrollLeft = targetLeft;
          graphCanvas.scrollTop = targetTop;
        }
      }

      function finishTreeRender() {
        treeReady = true;
        applyFilter(pendingFilterTerm);
        syncChangedFlags();
        while (treeReadyCallbacks.length) {
          var fn = treeReadyCallbacks.shift();
          fn();
        }
      }

      function schedule(fn) {
        if (window.requestIdleCallback) {
          window.requestIdleCallback(fn);
        } else {
          setTimeout(fn, 0);
        }
      }

      function createNamespaceSection(group) {
        var details = createDetails(group.key || 'cluster', group.items.length, 'namespace');
        details.dataset.namespace = group.key;
        details.open = group.items.length <= LARGE_NAMESPACE_THRESHOLD;
        var container = document.createElement('div');
        details.appendChild(container);
        var section = { name: group.key, details: details };
        namespaceSections.push(section);
        var kindGroups = groupBy(group.items, function(item) { return item.kindLabel || item.kind; });
        kindGroups.forEach(function(kindGroup) {
          var kindDetails = createDetails(kindGroup.key, kindGroup.items.length, 'kind');
          kindDetails.open = kindGroup.items.length <= LARGE_NAMESPACE_THRESHOLD;
          var list = document.createElement('ul');
          list.className = 'resource-list';
          kindGroup.items.sort(function(a, b) {
            var delta = changeRank(a.changeKind) - changeRank(b.changeKind);
            if (delta !== 0) return delta;
            return a.displayName.localeCompare(b.displayName);
          }).forEach(function(node) {
            var li = document.createElement('li');
            var btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'resource-btn';
            btn.textContent = node.displayName;
            btn.dataset.nodeId = node.id;
            btn.dataset.search = (node.displayName + ' ' + (node.namespace || '') + ' ' + (node.kindLabel || '')).toLowerCase();
            btn.dataset.kindBucket = node.category;
            if (node.changeKind) {
              btn.dataset.changeKind = node.changeKind;
              btn.classList.add('change-' + node.changeKind);
            }
            if (changedIds.has(node.id)) {
              btn.dataset.changed = 'true';
            }
            btn.setAttribute('role', 'treeitem');
            btn.setAttribute('aria-label', node.namespace + ' ' + node.kindLabel + ' ' + node.displayName);
            var counts = dependencyCounts(node.id);
            appendCountBadge(btn, counts.out, 'Depends on ' + counts.out + ' resources');
            appendCountBadge(btn, counts.in, 'Referenced by ' + counts.in + ' resources', true);
            btn.addEventListener('click', function() { selectNode(node); });
            li.appendChild(btn);
            list.appendChild(li);
            var entryRecord = { button: btn, li: li, node: node };
            resourceEntries.push(entryRecord);
            resourceEntryLookup[node.id] = entryRecord;
          });
          kindDetails.appendChild(list);
          container.appendChild(kindDetails);
        });
        return details;
      }

      function bindSearch() {
        if (!searchInput || !clearSearchBtn) return;
        clearSearchBtn.disabled = pendingFilterTerm.trim().length === 0;
        searchInput.addEventListener('input', function() {
          pendingFilterTerm = searchInput.value || '';
          persistState({ filterText: pendingFilterTerm });
          clearSearchBtn.disabled = pendingFilterTerm.trim().length === 0;
          applyFilter(pendingFilterTerm);
        });
        clearSearchBtn.addEventListener('click', function() {
          pendingFilterTerm = '';
          searchInput.value = '';
          clearSearchBtn.disabled = true;
          persistState({ filterText: '' });
          applyFilter('');
          searchInput.focus();
        });
      }

      function bindExpandCollapse() {
        if (!expandAllBtn || !collapseAllBtn) return;
        expandAllBtn.addEventListener('click', function() {
          namespaceSections.forEach(function(section) {
            section.details.open = true;
          });
        });
        collapseAllBtn.addEventListener('click', function() {
          namespaceSections.forEach(function(section) {
            section.details.open = false;
          });
        });
      }

      function bindCopyLink() {
        if (!copyLinkBtn) return;
        copyLinkBtn.addEventListener('click', function() {
          if (!currentNode) return;
          var text = window.location.href;
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(showCopyToast, showCopyToast);
          } else {
            showCopyToast();
          }
        });
      }

      function showCopyToast() {
        if (!copyLinkBtn) return;
        var previous = copyLinkBtn.textContent;
        copyLinkBtn.textContent = 'Link copied';
        setTimeout(function() { copyLinkBtn.textContent = previous; }, 1500);
      }

      function bindDownloadButtons() {
        downloadButtons.forEach(function(button) {
          button.addEventListener('click', function() {
            if (!currentNode) return;
            var mode = button.getAttribute('data-download');
            var content = mode === 'diff' ? manifestDiffs[currentNode.id] : manifests[currentNode.id];
            if (!content) return;
            var ext = mode === 'diff' ? 'diff' : 'yaml';
            var filename = (currentNode.namespace || 'cluster') + '-' + currentNode.displayName + '.' + ext;
            downloadText(content, filename);
          });
        });
      }

      function downloadText(text, filename) {
        try {
          var blob = new Blob([text], { type: 'text/plain' });
          var url = URL.createObjectURL(blob);
          var link = document.createElement('a');
          link.href = url;
          link.download = filename;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          setTimeout(function() { URL.revokeObjectURL(url); }, 0);
        } catch (err) {
          console.error('download failed', err);
        }
      }

      function bindCompareUpload() {
        if (!compareUpload) return;
        compareUpload.addEventListener('change', function() {
          var file = compareUpload.files[0];
          if (!file) return;
          var reader = new FileReader();
          reader.onload = function() {
            handleComparePayload(reader.result, file.name);
          };
          reader.readAsText(file);
        });
      }

      function handleComparePayload(raw, label) {
        var parsed = parseExternalVizPayload(raw);
        if (!parsed) {
          setCompareMeta('Failed to parse comparison artifact.');
          return;
        }
        compareDataset = parsed;
        compareManifests = parsed.manifests || {};
        compareSummary = buildSummary(parsed) || label || 'comparison artifact';
        dataset.compareSummary = compareSummary;
        dataset.compareManifests = compareManifests;
        setCompareMeta('Comparing against ' + compareSummary);
        if (compareTitle) {
          compareTitle.textContent = compareSummary;
        }
        if (compareColumns) {
          compareColumns.hidden = false;
        }
        recomputeChangedIds();
        syncChangedFlags();
        applyFilter(pendingFilterTerm);
        if (currentNode) {
          renderCompareViews(currentNode);
          applyImpactHighlights(currentNode);
        }
        scheduleGraphRender();
        hydrateHero();
        hydrateTimeline();
      }

      function parseExternalVizPayload(raw) {
        if (!raw) return null;
        try {
          var data = JSON.parse(raw);
          var normalized = normalizeExternalDataset(data);
          if (normalized) {
            return normalized;
          }
        } catch (err) {
          /* try HTML parse */
        }
        var match = raw.match(/<script[^>]+id=["']vizData["'][^>]*>([\s\S]*?)<\/script>/i);
        if (match && match[1]) {
          try {
            var embedded = JSON.parse(match[1]);
            return normalizeExternalDataset(embedded);
          } catch (err) {
            return null;
          }
        }
        return null;
      }

      function normalizeExternalDataset(obj) {
        if (!obj) return null;
        if (obj.manifests) {
          return obj;
        }
        if (obj.manifestBlobs) {
          return {
            release: obj.release || obj.releaseName,
            namespace: obj.namespace,
            chart: obj.chart || obj.chartReference || obj.chartRef,
            nodes: obj.graphNodes || [],
            edges: obj.graphEdges || [],
            manifests: obj.manifestBlobs,
            liveManifests: obj.liveManifestBlobs || obj.liveManifests || {},
            manifestDiffs: obj.manifestDiffs || {}
          };
        }
        return null;
      }

      function buildSummary(data) {
        if (!data) return '';
        var parts = [];
        if (data.release) parts.push('Release ' + data.release);
        if (data.namespace) parts.push('ns/' + data.namespace);
        if (data.chart) parts.push(data.chart);
        return parts.join(' · ');
      }

      function setCompareMeta(message) {
        if (!compareMeta) return;
        compareMeta.textContent = message || '';
      }

      function applyEmbeddedCompare() {
        if (!compareManifests) return;
        if (!compareSummary) {
          compareSummary = 'embedded plan';
        }
        setCompareMeta('Comparing against ' + compareSummary);
        if (compareTitle) {
          compareTitle.textContent = compareSummary;
        }
        if (compareColumns) {
          compareColumns.hidden = false;
        }
        if (currentNode) {
          renderCompareViews(currentNode);
        }
        hydrateHero();
        hydrateTimeline();
      }

      function recomputeChangedIds() {
        changedIds = new Set(Object.keys(manifestDiffs || {}));
        if (compareManifests) {
          Object.keys(manifests || {}).forEach(function(id) {
            if (!compareManifests[id] || compareManifests[id] !== manifests[id]) {
              changedIds.add(id);
            }
          });
        }
        Object.keys(changeKinds || {}).forEach(function(id) {
          var marker = (changeKinds && changeKinds[id]) ? String(changeKinds[id]).toLowerCase() : '';
          if (marker && marker !== 'unchanged') {
            changedIds.add(id);
          }
        });
      }

      function syncChangedFlags() {
        resourceEntries.forEach(function(entry) {
          var kind = entry.node.changeKind || '';
          if (kind) {
            entry.button.dataset.changeKind = kind;
          } else {
            delete entry.button.dataset.changeKind;
          }
          entry.button.classList.toggle('change-create', kind === 'create');
          entry.button.classList.toggle('change-update', kind === 'update');
          entry.button.classList.toggle('change-delete', kind === 'delete');
          if (changedIds.has(entry.node.id)) {
            entry.button.dataset.changed = 'true';
          } else {
            delete entry.button.dataset.changed;
          }
        });
      }

      function renderCompareViews(node) {
        if (!compareColumns || !compareBaseView || !compareOtherView) return;
        if (!compareManifests) {
          compareColumns.hidden = true;
          return;
        }
        compareColumns.hidden = false;
        if (!node) {
          compareBaseView.textContent = 'Select a resource to view its rendered YAML.';
          compareOtherView.textContent = 'Select a resource to compare.';
          return;
        }
        compareBaseView.textContent = manifests[node.id] || 'Rendered YAML unavailable.';
        if (compareManifests[node.id]) {
          compareOtherView.textContent = compareManifests[node.id];
        } else {
          compareOtherView.textContent = 'Resource missing in comparison artifact.';
        }
      }

      function applyImpactHighlights(node) {
        clearImpactHighlights();
        if (!node) return;
        highlightSet(dependencyMap.outgoing[node.id] || [], 'impact-upstream', 'upstream', node.id);
        highlightSet(dependencyMap.incoming[node.id] || [], 'impact-downstream', 'downstream', node.id);
      }

      function highlightSet(items, className, type, sourceId) {
        if (!items) return;
        items.forEach(function(item) {
          var targetId = item && item.id ? item.id : item;
          if (!targetId) return;
          var entry = resourceEntryLookup[targetId];
          if (entry) {
            entry.button.classList.add(className);
            impactButtonTargets.push(entry.button);
          }
          var depKey = (type || '') + ':' + targetId;
          var depEl = dependencyItemLookup[depKey];
          if (depEl) {
            depEl.classList.add(className);
            impactListTargets.push(depEl);
          }
          var graphNode = graphNodeElements[targetId];
          if (graphNode) {
            graphNode.classList.add(className);
            graphImpactNodes.push(graphNode);
          }
          highlightGraphEdges(sourceId, targetId, type);
        });
      }

      function clearImpactHighlights() {
        impactButtonTargets.forEach(function(btn) {
          btn.classList.remove('impact-upstream', 'impact-downstream');
        });
        impactButtonTargets = [];
        impactListTargets.forEach(function(item) {
          item.classList.remove('impact-upstream', 'impact-downstream');
        });
        impactListTargets = [];
        graphImpactNodes.forEach(function(node) {
          node.classList.remove('impact-upstream', 'impact-downstream');
        });
        graphImpactNodes = [];
        graphImpactEdges.forEach(function(edge) {
          edge.classList.remove('impact-upstream', 'impact-downstream');
        });
        graphImpactEdges = [];
      }

      function bindHashWatcher() {
        window.addEventListener('hashchange', function() {
          if (pendingHashUpdate) return;
          var node = findNodeFromHash();
          if (node) {
            onTreeReady(function() {
              selectNode(node, { updateHash: false });
            });
          }
        });
      }

      function applyFilter(term) {
        pendingFilterTerm = term || '';
        if (!treeReady) {
          return;
        }
        clearImpactHighlights();
        var query = pendingFilterTerm.trim().toLowerCase();
        var visible = 0;
        resourceEntries.forEach(function(entry) {
          var matchesQuery = !query || entry.button.dataset.search.indexOf(query) !== -1;
          var matchesBucket = activeBucket === 'all' || entry.button.dataset.kindBucket === activeBucket;
          var matchesChanged = !showChangedOnly || entry.button.dataset.changed === 'true';
          var match = matchesQuery && matchesBucket && matchesChanged;
          entry.li.classList.toggle('hidden', !match);
          if (match) {
            visible += 1;
          }
        });
        if (filterStatus) {
          if (!query && activeBucket === 'all' && !showChangedOnly) {
            filterStatus.textContent = '';
          } else {
            filterStatus.textContent = visible + ' resources match the current filters.';
          }
        }
        applyImpactHighlights(currentNode);
      }

      function restoreSelection() {
        var fromHash = findNodeFromHash();
        var persistedId = state.selectedId;
        var persistedNode = persistedId ? nodes.find(function(n) { return n.id === persistedId; }) : null;
        var target = fromHash || persistedNode || nodes[0];
        if (target) {
          selectNode(target, { updateHash: !fromHash });
        } else {
          setSelectionPlaceholder();
        }
      }

      function selectNode(node, opts) {
        if (!node) {
          setSelectionPlaceholder();
          return;
        }
        opts = opts || {};
        clearImpactHighlights();
        ensureSectionVisible(node);
        var entry = resourceEntries.find(function(item) { return item.node.id === node.id; });
        if (!entry) {
          setSelectionPlaceholder();
          return;
        }
        if (activeButton) {
          activeButton.classList.remove('selected');
        }
        entry.button.classList.add('selected');
        activeButton = entry.button;
        expandParents(entry.button);
        currentNode = node;
        highlightGraphSelection(node);
        if (graphPane && !graphPane.hidden) {
          scrollGraphIntoView(node);
        }
        selectionTitle.textContent = node.displayName;
        renderBreadcrumbs(node);
        renderMeta(node);
        renderDependencies(node);
        renderManifest(node);
        renderCompareViews(node);
        applyImpactHighlights(node);
        persistState({ selectedId: node.id });
        updateDownloadButtons();
        if (opts.updateHash !== false) {
          updateHash(node);
        }
      }

      function ensureSectionVisible(node) {
        namespaceSections.forEach(function(section) {
          if (section.name === node.namespace) {
            section.details.open = true;
          }
        });
      }

      function updateHash(node) {
        pendingHashUpdate = true;
        var ns = encodeURIComponent(node.namespace || 'cluster');
        var kind = encodeURIComponent(node.kind);
        var name = encodeURIComponent(node.displayName);
        window.location.hash = 'resource=' + ns + ':' + kind + ':' + name;
        setTimeout(function() { pendingHashUpdate = false; }, 0);
      }

      function findNodeFromHash() {
        var hash = window.location.hash || '';
        var idx = hash.indexOf('resource=');
        if (idx === -1) return null;
        var raw = hash.substring(idx + 9);
        var parts = raw.split(':');
        if (parts.length < 3) return null;
        var ns = decodeURIComponent(parts[0]);
        var kind = decodeURIComponent(parts[1]).toLowerCase();
        var name = decodeURIComponent(parts.slice(2).join(':'));
        var id = (ns || 'cluster').toLowerCase() + '|' + kind + '|' + name.toLowerCase();
        return nodes.find(function(n) { return n.id === id; }) || null;
      }

      function renderBreadcrumbs(node) {
        var parts = [dataset.release || 'release', node.namespace || 'cluster', node.kindLabel, node.displayName];
        breadcrumbs.innerHTML = '';
        parts.filter(Boolean).forEach(function(part) {
          var span = document.createElement('span');
          span.textContent = part;
          breadcrumbs.appendChild(span);
        });
      }

      function renderMeta(node) {
        metaBadges.innerHTML = '';
        addBadge('Kind', node.kindLabel);
        addBadge('Namespace', node.namespace || 'cluster');
        Object.entries(node.meta || {}).forEach(function(entry) {
          addBadge(titleCase(entry[0]), entry[1]);
        });
      }

      function addBadge(label, value) {
        if (!value) return;
        var badge = document.createElement('span');
        badge.className = 'badge';
        badge.textContent = label + ': ' + value;
        metaBadges.appendChild(badge);
      }

      function renderDependencies(node) {
        dependencyItemLookup = {};
        renderDependencyList(dependsOnList, dependencyMap.outgoing[node.id], 'No direct references', 'upstream');
        renderDependencyList(referencedByList, dependencyMap.incoming[node.id], 'Not referenced by other resources', 'downstream');
      }

      function renderDependencyList(target, items, emptyText, type) {
        if (!target) return;
        target.innerHTML = '';
        if (!items || items.length === 0) {
          var empty = document.createElement('li');
          empty.className = 'empty';
          empty.textContent = emptyText;
          target.appendChild(empty);
          return;
        }
        items.forEach(function(entry) {
          var li = document.createElement('li');
          var depId = entry && entry.id ? entry.id : entry;
          var node = nodes.find(function(n) { return n.id === depId; });
          var button = document.createElement('button');
          button.type = 'button';
          button.className = 'dependency-link';
          button.textContent = node ? node.namespace + ' · ' + node.kindLabel + ' · ' + node.displayName : depId;
          if (node) {
            button.addEventListener('click', function() { selectNode(node); });
          } else {
            button.disabled = true;
          }
          li.appendChild(button);
          if (entry.reason) {
            var reason = document.createElement('span');
            reason.className = 'dependency-reason';
            reason.textContent = entry.reason;
            li.appendChild(reason);
          }
          li.dataset.depId = depId || '';
          li.dataset.depType = type || '';
          dependencyItemLookup[(type || '') + ':' + depId] = li;
          target.appendChild(li);
        });
      }

      function renderManifest(node) {
        var rendered = manifests[node.id] || 'Rendered YAML unavailable for this resource.';
        if (manifestMode === 'diff') {
          var diff = manifestDiffs[node.id];
          if (diff && diff.trim()) {
            manifestView.innerHTML = diffToHtml(diff);
            manifestStatus.textContent = 'Displaying unified diff (live vs rendered).';
            return;
          }
          manifestView.textContent = rendered;
          if (liveManifests[node.id]) {
            manifestStatus.textContent = 'No changes detected between live and rendered manifest.';
          } else if (dataset.offlineFallback) {
            manifestStatus.textContent = 'Diff unavailable because live data could not be retrieved.';
          } else {
            manifestStatus.textContent = 'Diff unavailable for this resource.';
          }
          return;
        }
        manifestView.textContent = rendered;
        if (liveManifests[node.id]) {
          manifestStatus.textContent = 'Rendered manifest (live object exists).';
        } else if (dataset.offlineFallback) {
          manifestStatus.textContent = 'Rendered manifest (live data unavailable when generated).';
        } else {
          manifestStatus.textContent = 'Rendered manifest.';
        }
      }

      function updateDownloadButtons() {
        downloadButtons.forEach(function(button) {
          var mode = button.getAttribute('data-download');
          if (mode === 'diff') {
            var hasDiff = currentNode && manifestDiffs[currentNode.id];
            button.disabled = !hasDiff;
          } else {
            button.disabled = !currentNode;
          }
        });
      }

      function updateDiffHint() {
        if (!diffHint) return;
        if (manifestMode !== 'diff') {
          diffHint.textContent = '';
        } else if (dataset.offlineFallback) {
          diffHint.textContent = 'Diffs may be missing (live data unavailable).';
        } else {
          diffHint.textContent = 'Diff view compares rendered manifests to live cluster objects.';
        }
      }

      function hydrateHero() {
        if (!heroHeadline) return;
        var release = dataset.release || '';
        heroHeadline.textContent = release ? 'Deploying ' + release : 'Deployment overview';
        heroSubtitle.textContent = buildHeroSubtitle(dataset.namespace, dataset.chart, dataset.clusterHost);
        var generatedText = formatTimestamp(dataset.generatedAt);
        if (heroTimestamp) {
          heroTimestamp.textContent = generatedText ? 'Generated ' + generatedText : '';
        }
        var summary = dataset.summary || {};
        if (heroCreates) heroCreates.textContent = formatNumber(summary.creates);
        if (heroUpdates) heroUpdates.textContent = formatNumber(summary.updates);
        if (heroDeletes) heroDeletes.textContent = formatNumber(summary.deletes);
        if (heroUnchanged) heroUnchanged.textContent = formatNumber(summary.unchanged);
        var chips = [];
        if (release) chips.push({ label: 'Release', value: release });
        if (dataset.namespace) chips.push({ label: 'Namespace', value: dataset.namespace });
        if (dataset.chart) chips.push({ label: 'Chart', value: dataset.chart });
        if (dataset.clusterHost) chips.push({ label: 'Cluster', value: dataset.clusterHost });
        if (dataset.compareSummary) chips.push({ label: 'Compare', value: dataset.compareSummary, kind: 'positive' });
        if (dataset.offlineFallback) chips.push({ label: 'Mode', value: 'Offline fallback', kind: 'warning' });
        chips.push({ label: 'Resources', value: formatNumber(nodes.length) });
        setHeroChips(chips);
      }

      function hydrateReleaseDetails() {
        setDetailText(metaRelease, dataset.release);
        setDetailText(metaNamespace, dataset.namespace);
        setDetailText(metaChart, dataset.chart);
        setDetailText(metaCluster, formatClusterHost(dataset.clusterHost));
        setDetailText(metaGenerated, formatTimestamp(dataset.generatedAt));
      }

      function hydrateTimeline() {
        if (!timelineList) return;
        var items = [];
        var generated = formatTimestamp(dataset.generatedAt);
        if (generated) {
          items.push({ label: 'Plan rendered', detail: generated });
        }
        if (dataset.compareSummary) {
          items.push({ label: 'Comparison attached', detail: dataset.compareSummary, state: 'positive' });
        }
        if (dataset.offlineFallback) {
          items.push({ label: 'Offline mode', detail: 'Live data unavailable; using cached release.', state: 'warn' });
        }
        if (!items.length) {
          items.push({ label: 'Waiting for events', detail: 'No additional metadata recorded yet.' });
        }
        timelineList.innerHTML = '';
        items.forEach(function(entry) {
          timelineList.appendChild(buildTimelineItem(entry));
        });
      }

      function buildTimelineItem(entry) {
        var li = document.createElement('li');
        if (entry.state === 'warn') li.classList.add('warn');
        if (entry.state === 'fail') li.classList.add('fail');
        var dot = document.createElement('span');
        dot.className = 'dot';
        li.appendChild(dot);
        var title = document.createElement('strong');
        title.textContent = entry.label || 'Event';
        li.appendChild(title);
        var detail = document.createElement('small');
        detail.textContent = entry.detail || '';
        li.appendChild(detail);
        return li;
      }

      function hydrateWarnings() {
        if (!warningsPanel || !warningsList) return;
        var warnings = Array.isArray(dataset.warnings) ? dataset.warnings.filter(Boolean) : [];
        warningsPanel.hidden = warnings.length === 0;
        warningsList.innerHTML = '';
        warnings.forEach(function(message) {
          var li = document.createElement('li');
          li.textContent = message;
          warningsList.appendChild(li);
        });
      }

      function hydrateRunbook() {
        if (!runbookPanel || !installSnippet || !installCopy) return;
        var command = dataset.installCommand || dataset.installCmd || '';
        if (!command.trim()) {
          runbookPanel.hidden = true;
          return;
        }
        runbookPanel.hidden = false;
        installSnippet.textContent = command;
        installCopy.textContent = 'Copy install command';
        installCopy.onclick = function() {
          copyCommandToClipboard(command, installCopy, 'Copied');
        };
      }

      function buildHeroSubtitle(ns, chart, host) {
        var parts = [];
        if (ns) parts.push('Namespace ' + ns);
        if (chart) parts.push(chart);
        var cluster = formatClusterHost(host);
        if (cluster) parts.push(cluster);
        return parts.join(' · ') || 'Rendered resources';
      }

      function setHeroChips(entries) {
        if (!heroChips) return;
        heroChips.innerHTML = '';
        entries.filter(Boolean).forEach(function(entry) {
          heroChips.appendChild(createHeroChip(entry));
        });
      }

      function createHeroChip(entry) {
        var chip = document.createElement('span');
        chip.className = 'hero-chip';
        if (entry.kind === 'positive') {
          chip.classList.add('positive');
        }
        if (entry.kind === 'warning') {
          chip.classList.add('warning');
        }
        chip.textContent = entry.label ? entry.label + ': ' + entry.value : entry.value;
        return chip;
      }

      function setDetailText(target, value) {
        if (!target) return;
        var text = '';
        if (value || value === 0) {
          text = String(value);
        }
        target.textContent = text.trim() ? text : '—';
      }

      function formatClusterHost(host) {
        if (!host) return '';
        return host.replace(/^https?:\/\//, '');
      }

      function copyCommandToClipboard(text, button, successLabel) {
        if (!button || !text) return;
        var original = button.textContent;
        function done() {
          button.textContent = successLabel || 'Copied';
          setTimeout(function() {
            button.textContent = original;
          }, 1400);
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(done, done);
        } else {
          done();
        }
      }

      function formatNumber(value) {
        var numeric = typeof value === 'number' ? value : parseInt(value || '0', 10) || 0;
        return numberFormatter ? numberFormatter.format(numeric) : String(numeric);
      }

      function formatTimestamp(value) {
        if (!value) return '';
        var date = new Date(value);
        if (isNaN(date.getTime())) return '';
        return date.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
      }

      function setSelectionPlaceholder() {
        selectionTitle.textContent = 'Select a resource';
        breadcrumbs.textContent = 'No resource selected';
        metaBadges.innerHTML = '';
        renderDependencyList(dependsOnList, [], '');
        renderDependencyList(referencedByList, [], '');
        manifestView.textContent = 'Select a resource to view its rendered YAML.';
        manifestStatus.textContent = '';
        currentNode = null;
        updateDownloadButtons();
        if (compareColumns) {
          compareColumns.hidden = !compareManifests;
        }
        clearImpactHighlights();
      }

      function dependencyCounts(id) {
        return {
          out: (dependencyMap.outgoing[id] || []).length,
          in: (dependencyMap.incoming[id] || []).length
        };
      }

      function appendCountBadge(parent, count, title, emphasize) {
        if (!count || count <= 0) return;
        var pill = document.createElement('span');
        pill.className = 'resource-pill' + (emphasize ? ' strong' : '');
        pill.textContent = count;
        pill.title = title;
        parent.appendChild(pill);
      }

      function expandParents(element) {
        var detail = element.closest('details.tree-node');
        while (detail) {
          detail.open = true;
          detail = detail.parentElement ? detail.parentElement.closest('details.tree-node') : null;
        }
      }

      function groupBy(items, keyFn) {
        var buckets = {};
        items.forEach(function(item) {
          var key = keyFn(item) || 'other';
          if (!buckets[key]) buckets[key] = [];
          buckets[key].push(item);
        });
        return Object.keys(buckets).sort(function(a, b) { return a.localeCompare(b); }).map(function(key) {
          return { key: key, items: buckets[key] };
        });
      }

      function titleCase(str) {
        return (str || '').replace(/(^|\s)([a-z])/g, function(match, start, char) {
          return start + char.toUpperCase();
        });
      }

      function changeRank(kind) {
        switch ((kind || '').toLowerCase()) {
          case 'delete': return 0;
          case 'update': return 1;
          case 'create': return 2;
          default: return 3;
        }
      }

      function buildDependencyMap(edges) {
        var map = { outgoing: {}, incoming: {} };
        edges.forEach(function(edge) {
          var from = (edge.From || edge.from || '').toLowerCase();
          var to = (edge.To || edge.to || '').toLowerCase();
          if (!from || !to) return;
          var reason = edge.Reason || edge.reason || '';
          if (!map.outgoing[from]) map.outgoing[from] = [];
          if (!map.incoming[to]) map.incoming[to] = [];
          if (!map.outgoing[from].some(function(entry) { return entry.id === to && entry.reason === reason; })) {
            map.outgoing[from].push({ id: to, reason: reason });
          }
          if (!map.incoming[to].some(function(entry) { return entry.id === from && entry.reason === reason; })) {
            map.incoming[to].push({ id: from, reason: reason });
          }
        });
        return map;
      }

      function diffToHtml(diff) {
        return diff.split('\n').map(function(line) {
          var cls = 'diff-line';
          if (line.startsWith('+')) cls += ' added';
          else if (line.startsWith('-')) cls += ' removed';
          else if (line.startsWith('@@')) cls += ' header';
          return '<span class="' + cls + '">' + escapeHtml(line) + '</span>';
        }).join('\n');
      }

      function escapeHtml(str) {
        return str.replace(/[&<>]/g, function(ch) {
          switch (ch) {
            case '&': return '&amp;';
            case '<': return '&lt;';
            case '>': return '&gt;';
            default: return ch;
          }
        });
      }
    })();
  </script>
</body>
</html>
