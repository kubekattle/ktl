# Песочница `ktl`: демонстрация угроз и защиты (для реального демо)

Этот документ — “скрипт для выступления”. Он объясняет аудитории, **что именно мы демонстрируем**, какие предпосылки нужны и что считать “успехом” в каждом шаге.

Ключевая идея:

- Если вы запускаете сборку **без песочницы `ktl`** (или делаете “просто Docker”), вы сами создаёте мостик между недоверенным кодом и ресурсами хоста.
- Если вы запускаете сборку **в песочнице `ktl`**, `ktl` ограничивает окружение так, чтобы сборка видела только то, что нужно для билда (контекст, кеш), а не весь хост.

## Модель угроз (о чём речь)

Ситуация: вы делаете `ktl build` для репозитория, которому не доверяете полностью (PR из форка, “пример” из интернета, внешняя команда прислала Dockerfile).

Задача атакующего в этом случае — не “сломать контейнер”, а использовать сборку, чтобы:

- прочитать файлы/конфиги хоста;
- записать что-то на хост (закладки/подмена);
- получить доступ к привилегированным локальным интерфейсам (например, `docker.sock`), что по сути эквивалентно контролю над хостом.

## Важно: от чего зависит “вау‑эффект”

Разные хосты настроены по‑разному. На части систем попытки “дотянуться до хоста” будут блокироваться самим билд‑движком (BuildKit/демон).

Это нормально — это **безопасный** исход.

Поэтому в наших демо‑скриптах есть режим `SKIP`: если конкретная машина уже “закрыта” на уровне билдера, мы честно говорим аудитории, что здесь песочница — дополнительный слой, но конкретно этот трюк на этом хосте не воспроизводится.

## Что нужно заранее (перед демонстрацией)

Рекомендуемая площадка: Linux‑хост `root@188.124.37.233`.

1) Убедитесь, что `nsjail` установлен:

```bash
command -v nsjail
```

2) Возьмите политику песочницы (для демо достаточно `linux-ci`):

```bash
export KTL_SANDBOX_CONFIG="$(pwd)/sandbox/linux-ci.cfg"
```

Если на хосте нет Go toolchain, демо всё равно можно прогнать с уже собранным бинарником:

- локально собрать `ktl` под Linux и загрузить его на хост (см. `scripts/remote-sandbox-demo.sh`), или
- вручную передать путь к бинарнику через `KTL_BIN=/path/to/ktl` (в этом случае `scripts/sandbox-demo.sh` не требует `go`).

## Демо 1 (основное): “`ktl` без песочницы vs `ktl` в песочнице”

Этот демо‑набор делает несколько проверок и печатает понятный итог (`PASS`/`FAIL`/`SKIP`).

Запуск:

```bash
./scripts/sandbox-demo.sh
```

Что рассказывать аудитории по ходу:

- “Сейчас мы делаем базовую сборку, чтобы убедиться, что вообще всё работает.”
- “Дальше мы отключаем песочницу (`KTL_SANDBOX_DISABLE=1`) и сравниваем поведение.”
- “Дальше — детерминированные проверки `--sandbox-probe-path`: песочница прячет файлы вне build context, но не ломает доступ к самому контексту.”
- “Потом показываем allowlist‑принцип: явный `--sandbox-bind` делает конкретный файл видимым (только если мы сами этого хотим).”
- “И в конце проверяем, что если песочница не стартует, это видно через `--sandbox-logs` (никаких ‘пустых запусков’).”

## Демо 2 (сравнение с Docker): “явный доступ к хосту в Docker vs ограничения песочницы `ktl`”

Цель — показать аудитории простую мысль:

- “Обычный Docker” с `-v /tmp:/host-tmp` **явно** даёт контейнеру доступ к файлам хоста.
- “Обычный Docker” с `-v /var/run/docker.sock:/var/run/docker.sock` даёт контейнеру возможность управлять Docker‑демоном (что на практике очень близко к контролю над хостом).
- `ktl` песочница в режиме сборки старается не допустить “неявной видимости” хоста при сборке недоверенного контента.

Запуск:

```bash
./scripts/docker-vs-ktl-sandbox-demo.sh
```

## Почему песочница предотвращает “root‑impact” сценарии

Самое важное свойство песочницы — **ограничение видимости и доступов**:

- сборка не видит произвольные пути хоста;
- сборка не получает доступ к локальным “опасным” интерфейсам (если вы их явно не пробросили);
- если сборка пытается “прибиндить хост”, в песочнице это превращается в “прибиндить песочницу”, а не реальную машину.

## Практические правила

- `KTL_SANDBOX_DISABLE=1` — это флаг повышенного риска (включать только для отладки и только на доверенном коде).
- Недоверенные репозитории (PR/форки) — всегда собирать в песочнице.
- Если легитимной сборке нужны дополнительные бинды, добавляйте их явно и проверяемо (`--sandbox-bind` или политика в `sandbox/*.cfg`).
