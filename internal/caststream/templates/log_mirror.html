<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ktl Log Mirror</title>
  <link rel="icon" href="data:," />
  <style>
    :root {
      color-scheme: light;
      --surface: rgba(255,255,255,0.9);
      --surface-soft: rgba(255,255,255,0.82);
      --border: rgba(15,23,42,0.12);
      --text: #0f172a;
      --muted: rgba(15,23,42,0.65);
      --accent: #2563eb;
      --chip-bg: rgba(37,99,235,0.08);
      --chip-text: #1d4ed8;
      --warn: #fbbf24;
      --fail: #ef4444;
      --ease: cubic-bezier(.16,1,.3,1);
      --timeline-label-width: 168px;
    }
    * { box-sizing: border-box; }
    .hidden { display:none !important; }
    body {
      font-family: "SF Pro Display", "SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      margin: 0;
      min-height: 100vh;
      padding: 48px 56px 72px;
      background: radial-gradient(circle at 20% 20%, #ffffff, #e9edf5 45%, #dce3f1);
      color: var(--text);
    }
    .chrome { max-width: 1600px; margin: 0 auto; }
    header {
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:1.5rem;
      margin-bottom:32px;
    }
    body[data-filters-enabled="false"] header {
      justify-content:flex-end;
    }
    body.popout-mode header {
      display:none;
    }
    body.popout-mode {
      padding:16px 24px 32px;
    }
    body.popout-mode .layout {
      margin-top:0;
    }
    body.popout-mode .sidebar,
    body.popout-mode .heatmap-panel,
    body.popout-mode .timeline-panel,
    body.popout-mode .graph-panel,
    body.popout-mode .health-panel,
    body.popout-mode .diff-panel,
    body.popout-mode .build-metrics,
    body.popout-mode .header-actions {
      display:none !important;
    }
    body.popout-mode .log-panel {
      min-height:calc(100vh - 40px);
    }
    h1 { font-size:2.4rem; font-weight:600; letter-spacing:-0.04em; margin:0; }
    .subtitle { font-size:1rem; color:var(--muted); margin:0; }
    .status-chip {
      border-radius:999px;
      border:1px solid rgba(37,99,235,0.2);
      padding:0.4rem 1rem;
      font-weight:600;
      color:var(--chip-text);
      background:var(--chip-bg);
    }
	    .header-actions {
	      display:flex;
	      align-items:center;
	      gap:0.75rem;
	    }
    .header-actions .spacer {
      width:1px;
      height:28px;
      background:rgba(15,23,42,0.12);
      margin:0 0.15rem;
    }
    .icon-button {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.15);
      background:rgba(15,23,42,0.02);
      color:var(--muted);
      width:40px;
      height:40px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:1rem;
      cursor:pointer;
      transition:all 140ms var(--ease);
    }
    .icon-button:hover,
    .icon-button:focus-visible {
      border-color:var(--accent);
      color:var(--accent);
      background:rgba(37,99,235,0.08);
    }
    .filter-toggle {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.15);
      background:rgba(15,23,42,0.02);
      color:var(--muted);
      letter-spacing:0.12em;
      text-transform:uppercase;
      font-size:0.78rem;
      padding:0.35rem 1.1rem;
      cursor:pointer;
      transition:all 140ms var(--ease);
    }
    .filter-toggle.active {
      border-color:var(--accent);
      color:var(--accent);
      background:rgba(37,99,235,0.08);
    }
    .filter-toggle.danger {
      border-color:rgba(239,68,68,0.3);
      background:rgba(239,68,68,0.06);
      color:#b91c1c;
    }
    .layout {
      display:flex;
      flex-direction:row;
      align-items:flex-start;
      gap:22px;
    }
    .sidebar {
      flex:0 0 420px;
      min-width:340px;
      max-width:620px;
      display:flex;
      flex-direction:column;
      gap:22px;
      resize:horizontal;
      overflow:auto;
      padding:40px 18px 44px;
    }
    body.sidebar-collapsed .sidebar {
      display:none;
    }
	    .main {
	      flex:1 1 auto;
	      min-width:0;
	      display:flex;
	      flex-direction:column;
	      gap:22px;
	    }
	    .active-filters {
	      position:sticky;
	      top:16px;
	      z-index:50;
	      padding:14px 18px;
	    }
	    .active-filters.hidden { display:none; }
	    .active-filters-row {
	      display:flex;
	      align-items:center;
	      justify-content:space-between;
	      gap:0.75rem;
	      flex-wrap:wrap;
	    }
	    .active-filters-chips {
	      display:flex;
	      flex-wrap:wrap;
	      gap:0.45rem;
	      min-width:0;
	      flex:1 1 auto;
	      align-items:center;
	    }
	    .active-filter-chip {
	      border-radius:999px;
	      border:1px solid rgba(15,23,42,0.14);
	      background:rgba(15,23,42,0.03);
	      color:var(--text);
	      font-size:0.78rem;
	      padding:0.18rem 0.65rem;
	      cursor:pointer;
	      max-width:100%;
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	      transition:transform 140ms var(--ease), border-color 140ms var(--ease), background 140ms var(--ease);
	    }
	    .active-filter-chip:hover,
	    .active-filter-chip:focus-visible {
	      outline:none;
	      transform:translateY(-1px);
	      border-color:rgba(37,99,235,0.35);
	      background:rgba(37,99,235,0.06);
	      color:var(--accent);
	    }
	    .active-filters-actions {
	      display:flex;
	      gap:0.45rem;
	      align-items:center;
	      justify-content:flex-end;
	      flex:0 0 auto;
	    }

    .mini-btn.danger {
      border-color:rgba(239,68,68,0.35);
      background:rgba(239,68,68,0.08);
      color:#b91c1c;
    }
    @media (max-width: 1100px) {
      body { padding:32px 24px 48px; }
      .layout { flex-direction:column; gap:18px; }
      .sidebar {
        flex:1 1 auto;
        min-width:0;
        max-width:none;
        resize:none;
        overflow:visible;
        padding:0;
      }
    }
    .panel {
      border-radius:28px;
      padding:32px;
      background:var(--surface);
      border:1px solid var(--border);
      backdrop-filter:blur(18px);
      box-shadow:0 40px 80px rgba(16,23,36,0.12);
    }
    .panel.compact {
      padding:24px 26px;
    }
    .panel-title-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:0.8rem;
      flex-wrap:wrap;
      margin-bottom:0.85rem;
    }
    .panel-title-row h2 {
      margin:0;
      font-size:1.05rem;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .subtle {
      font-size:0.85rem;
      color:var(--muted);
      margin:0;
    }
	    .log-panel {
	      padding:32px;
	      overflow:visible;
	      display:flex;
	      flex-direction:column;
	      gap:16px;
	      position:relative;
	    }
	    .log-feed {
	      font-family: SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono',monospace;
	      padding:24px 32px 32px;
	      max-height:70vh;
	      overflow:auto;
	      display:flex;
	      flex-direction:column;
	      gap:14px;
	      background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.7));
	    }
	    .log-group {
	      border:1px solid rgba(15,23,42,0.12);
	      background:rgba(255,255,255,0.86);
	      border-radius:20px;
	      overflow:hidden;
	      box-shadow:0 18px 40px rgba(15,23,42,0.10);
	      backdrop-filter:blur(16px);
	    }
	    .log-group.hidden { display:none; }
	    .log-group summary {
	      list-style:none;
	      display:flex;
	      align-items:center;
	      justify-content:space-between;
	      gap:0.85rem;
	      padding:0.75rem 1rem;
	      cursor:pointer;
	      user-select:none;
	      background:rgba(15,23,42,0.02);
	    }
	    .log-group summary::-webkit-details-marker { display:none; }
	    .group-title {
	      font-size:0.85rem;
	      letter-spacing:0.08em;
	      text-transform:uppercase;
	      color:rgba(15,23,42,0.75);
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	    }
	    .group-count {
	      border-radius:999px;
	      padding:0.15rem 0.65rem;
	      border:1px solid rgba(15,23,42,0.14);
	      background:rgba(255,255,255,0.7);
	      font-size:0.78rem;
	      color:rgba(15,23,42,0.7);
	      letter-spacing:0.08em;
	      text-transform:uppercase;
	      flex:0 0 auto;
	    }
	    .group-body {
	      padding:0.35rem 0.95rem 0.95rem;
	      display:flex;
	      flex-direction:column;
	      gap:12px;
	    }
	    .log-entry { border-left:4px solid rgba(37,99,235,0.35); padding-left:1rem; transition:opacity 140ms ease; }
	    .log-entry.level-warn { border-left-color:var(--warn); }
	    .log-entry.level-fail { border-left-color:var(--fail); background:rgba(239,68,68,0.03); }
	    .log-entry.hidden { display:none; }
	    .log-entry.focused {
	      background:rgba(37,99,235,0.04);
	      border-left-color:var(--accent);
	    }
	    .log-entry.selected {
	      outline:2px solid rgba(37,99,235,0.25);
	      outline-offset:2px;
	      background:rgba(37,99,235,0.03);
	    }
    .log-entry .meta { font-size:0.9rem; color:var(--muted); margin-bottom:0.35rem; display:flex; flex-wrap:wrap; gap:0.5rem; }
    .meta-pill {
      border:none;
      background:none;
      padding:0;
      font:inherit;
      color:inherit;
      cursor:pointer;
      border-radius:999px;
    }
    .meta-pill:hover,
    .meta-pill:focus-visible {
      color:var(--accent);
      text-decoration:underline;
      outline:none;
    }
    .chip-inline {
      border-radius:999px;
      padding:0.15rem 0.75rem;
      background:var(--chip-bg);
      color:var(--chip-text);
      font-size:0.8rem;
      letter-spacing:0.08em;
      text-transform:uppercase;
    }
    .meta-chip {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.14);
      background:rgba(255,255,255,0.65);
      color:var(--muted);
      font-size:0.8rem;
      padding:0.12rem 0.65rem;
      letter-spacing:0.06em;
      text-transform:uppercase;
      display:inline-flex;
      gap:0.45rem;
      align-items:center;
      cursor:pointer;
      transition:transform 140ms var(--ease), border-color 140ms var(--ease), background 140ms var(--ease);
    }
    .meta-chip:hover,
    .meta-chip:focus-visible {
      outline:none;
      transform:translateY(-1px);
      border-color:rgba(37,99,235,0.35);
      background:rgba(37,99,235,0.06);
      color:var(--accent);
    }
    .meta-actions {
      margin-left:auto;
      display:flex;
      gap:0.35rem;
      align-items:center;
      flex-wrap:wrap;
    }
    .mini-btn {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.14);
      background:rgba(255,255,255,0.7);
      color:var(--muted);
      font-size:0.78rem;
      padding:0.18rem 0.65rem;
      cursor:pointer;
      transition:transform 140ms var(--ease), border-color 140ms var(--ease), background 140ms var(--ease);
    }
    .mini-btn:hover,
    .mini-btn:focus-visible {
      outline:none;
      transform:translateY(-1px);
      border-color:rgba(37,99,235,0.35);
      background:rgba(37,99,235,0.06);
      color:var(--accent);
    }
    .mini-btn.primary {
      border-color:rgba(37,99,235,0.35);
      background:rgba(37,99,235,0.08);
      color:var(--chip-text);
    }
    .log-entry.match {
      border-left-color:rgba(37,99,235,0.75);
      background:rgba(37,99,235,0.03);
    }
    .log-line {
      font-size:0.95rem;
      line-height:1.45;
      color:var(--text);
      white-space:pre-wrap;
      word-break:break-word;
    }
    .filter-panel h2 { margin:0; font-size:1.2rem; letter-spacing:0.02em; }
    .filter-head {
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:0.8rem;
      margin-bottom:0.85rem;
    }
    .filter-search-row {
      display:flex;
      gap:0.6rem;
      align-items:center;
      margin-bottom:0.35rem;
    }
    .filter-search-row .mini-btn {
      flex:0 0 auto;
    }
    .find-actions {
      display:flex;
      gap:0.35rem;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .filter-search-row input[type="search"] {
      flex:1;
      border-radius:999px;
      border:1px solid var(--border);
      padding:0.58rem 1.1rem;
      font-size:1rem;
      background:rgba(255,255,255,0.9);
      color:var(--text);
    }
    .filter-hint { font-size:0.85rem; color:var(--muted); margin:0 0 0.8rem; }
    .search-chip-tray {
      display:flex;
      flex-wrap:wrap;
      gap:0.4rem;
      margin-bottom:0.6rem;
      min-height:1.2rem;
    }
    .search-chip-tray .chip-button {
      text-transform:none;
      letter-spacing:0.02em;
    }
    .chip-button:disabled {
      opacity:0.55;
      cursor:not-allowed;
      transform:none !important;
    }
    .diff-panel {
      padding:28px 32px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .diff-grid {
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:16px;
    }
    @media (max-width: 900px) {
      .diff-grid { grid-template-columns:1fr; }
    }
    .diff-box {
      border:1px solid rgba(15,23,42,0.10);
      border-radius:18px;
      background:rgba(15,23,42,0.02);
      padding:14px 16px;
    }
    .diff-box h3 {
      margin:0 0 8px;
      font-size:0.9rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .diff-list {
      margin:0;
      padding-left:1.1rem;
      color:var(--text);
      font-size:0.9rem;
      line-height:1.35;
    }
    .diff-list li { margin:0.25rem 0; }
    .filter-grid {
      display:flex;
      gap:1.25rem;
      flex-wrap:wrap;
    }
    .capture-panel {
      padding:28px 32px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:1.2rem;
      flex-wrap:wrap;
    }
    .capture-panel h2 {
      margin:0.2rem 0 0;
      font-size:1.35rem;
      letter-spacing:-0.02em;
    }
    .capture-panel .summary {
      margin-top:0.35rem;
    }
    .session-panel {
      padding:28px 32px;
      display:flex;
      flex-direction:column;
      gap:0.75rem;
    }
    .session-panel .panel-title-row {
      margin-bottom:0;
    }
    .session-actions {
      display:flex;
      gap:0.6rem;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .session-controls {
      display:flex;
      gap:0.6rem;
      flex-wrap:wrap;
      align-items:center;
      margin-top:0.75rem;
    }
    .session-controls input[type="text"] {
      border-radius:999px;
      border:1px solid var(--border);
      padding:0.5rem 0.9rem;
      font-size:0.9rem;
      background:rgba(255,255,255,0.92);
      color:var(--text);
      min-width:220px;
    }
    .session-controls .hint {
      font-size:0.85rem;
      color:var(--muted);
      margin:0;
      flex-basis:100%;
    }
    .cta-button {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.20);
      padding:0.55rem 1rem;
      background:rgba(255,255,255,0.92);
      color:var(--text);
      font-weight:600;
      cursor:pointer;
      box-shadow:0 12px 24px rgba(15,23,42,0.10), inset 0 1px 0 rgba(255,255,255,0.75);
      transition:transform 180ms var(--ease), border-color 180ms var(--ease), box-shadow 180ms var(--ease);
    }
    .cta-button:hover {
      transform:translateY(-1px);
      border-color:rgba(37,99,235,0.45);
      box-shadow:0 16px 32px rgba(15,23,42,0.12), inset 0 1px 0 rgba(255,255,255,0.78);
    }
    .cta-button:active {
      transform:translateY(0px);
      box-shadow:inset 0 2px 10px rgba(15,23,42,0.18);
    }
    .cta-button:disabled {
      cursor:not-allowed;
      opacity:0.6;
      transform:none;
      box-shadow:none;
    }
    .cta-button:focus-visible {
      outline:none;
      box-shadow:0 0 0 3px rgba(37,99,235,0.22), 0 16px 32px rgba(15,23,42,0.12);
    }
    .context-panel {
      padding:28px 32px;
      display:flex;
      flex-direction:column;
      gap:0.65rem;
    }
    .context-panel h2 {
      margin:0;
      font-size:1.1rem;
      letter-spacing:0.02em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .context-grid {
      display:flex;
      gap:1rem;
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .context-chip {
      border-radius:16px;
      border:1px solid rgba(15,23,42,0.12);
      background:rgba(15,23,42,0.02);
      padding:0.6rem 0.85rem;
      min-width:220px;
      flex:1;
    }
    .context-chip .label {
      font-size:0.75rem;
      letter-spacing:0.16em;
      text-transform:uppercase;
      color:var(--muted);
      margin:0 0 0.25rem;
    }
    .context-chip pre {
      margin:0;
      font-family: SFMono-Regular,Menlo,Monaco,Consolas,'Liberation Mono',monospace;
      font-size:0.85rem;
      line-height:1.35;
      white-space:pre-wrap;
      word-break:break-word;
      color:var(--text);
    }
    body[data-filters-enabled="false"] .filter-panel {
      padding-top:24px;
      padding-bottom:24px;
    }
    body[data-filters-enabled="false"] .filter-head,
    body[data-filters-enabled="false"] .filter-hint {
      display:none;
    }
    body[data-filters-enabled="false"] .filter-toggle {
      display:none;
    }
    body[data-filters-enabled="false"] .filter-grid,
    body[data-filters-enabled="false"] .chip-stack,
    body[data-filters-enabled="false"] .chip-stack-head,
    body[data-filters-enabled="false"] .chip-meta,
    body[data-filters-enabled="false"] .chip-tray {
      display:none;
    }
    body.filters-collapsed .filter-panel {
      display:none;
    }
    .chip-stack {
      flex:1 1 260px;
      display:flex;
      flex-direction:column;
      gap:0.5rem;
    }
    .chip-stack-head {
      display:flex;
      justify-content:flex-end;
      align-items:center;
      gap:0.4rem;
      letter-spacing:0.12em;
      font-size:0.8rem;
      color:var(--muted);
    }
    .chip-meta { font-size:0.75rem; letter-spacing:0.14em; color:var(--muted); }
    .chip-tray { display:flex; flex-wrap:wrap; gap:0.45rem; }
    .chip-button {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.15);
      background:rgba(15,23,42,0.02);
      color:var(--muted);
      font-size:0.78rem;
      letter-spacing:0.08em;
      text-transform:uppercase;
      padding:0.25rem 0.9rem;
      cursor:pointer;
    }
    .chip-button.active {
      border-color:var(--accent);
      color:var(--accent);
      background:rgba(37,99,235,0.08);
    }
    .placeholder { font-size:0.85rem; color:var(--muted); margin:0; }
    .link-button {
      border:none;
      background:none;
      color:var(--accent);
      font-weight:600;
      cursor:pointer;
      padding:0;
    }
	    .follow-indicator {
	      position:absolute;
	      right:46px;
	      bottom:46px;
	      border-radius:999px;
	      border:1px solid rgba(251,191,36,0.45);
	      background:rgba(251,191,36,0.12);
	      color:#a16207;
	      font-size:0.9rem;
	      height:44px;
	      padding:0 0.9rem;
	      display:flex;
	      align-items:center;
	      justify-content:center;
	      gap:0.65rem;
	      cursor:pointer;
	      box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);
	      backdrop-filter:blur(14px);
	      letter-spacing:0.08em;
	      text-transform:uppercase;
	    }
	    .follow-indicator:hover,
	    .follow-indicator:focus-visible {
	      outline:none;
	      border-color:rgba(251,191,36,0.65);
	      background:rgba(251,191,36,0.18);
	    }
		    .follow-indicator.hidden { display:none; }
		    .follow-label { font-weight:650; }
		    .follow-time { opacity:0.78; }
		    .feed-live-badge {
		      position:absolute;
		      right:46px;
		      bottom:46px;
	      z-index:20;
	      display:flex;
	      align-items:center;
	      gap:0.4rem;
	      border-radius:999px;
	      padding:0.4rem 0.8rem;
	      border:1px solid rgba(34,197,94,0.35);
	      background:rgba(34,197,94,0.08);
	      color:#15803d;
	      font-size:0.82rem;
	      letter-spacing:0.08em;
	      text-transform:uppercase;
	      box-shadow:0 18px 40px rgba(15,23,42,0.12);
	      backdrop-filter:blur(14px);
	      pointer-events:none;
	    }
		    .feed-live-badge.paused {
		      border-color:rgba(251,191,36,0.45);
		      background:rgba(251,191,36,0.12);
		      color:#a16207;
		    }
	    .search-chip-tray.preview {
	      margin-top:0.25rem;
	      margin-bottom:0.25rem;
	    }
	    .preview-chip {
	      opacity:0.7;
	      border-style:dashed;
	      background:rgba(15,23,42,0.01);
	      cursor:default;
	    }
	    .session-stats {
	      display:grid;
	      grid-template-columns:repeat(auto-fit, minmax(140px, 1fr));
	      gap:0.65rem;
	      margin-top:0.9rem;
	      margin-bottom:0.85rem;
	    }
	    .event-list {
	      display:flex;
	      flex-direction:column;
	      gap:0.5rem;
	    }
	    .event-row {
	      border-radius:16px;
	      border:1px solid rgba(15,23,42,0.12);
	      background:rgba(255,255,255,0.7);
	      padding:0.65rem 0.8rem;
	      cursor:pointer;
	      transition:transform 140ms var(--ease), border-color 140ms var(--ease), background 140ms var(--ease);
	    }
	    .event-row:hover,
	    .event-row:focus-visible {
	      outline:none;
	      transform:translateY(-1px);
	      border-color:rgba(37,99,235,0.35);
	      background:rgba(37,99,235,0.06);
	    }
	    .event-row .head {
	      display:flex;
	      justify-content:space-between;
	      gap:0.65rem;
	      align-items:center;
	      margin-bottom:0.25rem;
	    }
	    .event-row .title {
	      font-weight:650;
	      color:var(--text);
	      font-size:0.9rem;
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	    }
	    .event-row .meta {
	      color:var(--muted);
	      font-size:0.85rem;
	      margin:0;
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	    }
	    .event-row.fail {
	      border-color:rgba(239,68,68,0.35);
	      background:rgba(239,68,68,0.06);
	    }
	    .event-row.warn {
	      border-color:rgba(251,191,36,0.45);
	      background:rgba(251,191,36,0.08);
	    }
		    .feed-empty {
		      position:absolute;
		      left:44px;
		      right:44px;
		      top:44px;
	      bottom:44px;
	      z-index:15;
	      display:flex;
	      align-items:center;
	      justify-content:center;
	      text-align:center;
	      border-radius:24px;
	      border:1px dashed rgba(15,23,42,0.18);
	      background:rgba(255,255,255,0.82);
	      backdrop-filter:blur(16px);
		      box-shadow:0 18px 40px rgba(15,23,42,0.10);
		      padding:24px;
		    }
		    .feed-empty.dragging {
		      border-color:rgba(37,99,235,0.55);
		      background:rgba(37,99,235,0.06);
		    }
		    .feed-empty.hidden { display:none; }
	    .feed-empty-inner {
	      max-width:540px;
	      display:flex;
	      flex-direction:column;
	      gap:0.55rem;
	      align-items:center;
	    }
	    .feed-empty-title {
	      margin:0;
	      font-size:1.15rem;
	      font-weight:650;
	      color:var(--text);
	      letter-spacing:-0.01em;
	    }
	    .feed-empty-sub {
	      margin:0;
	      color:var(--muted);
	      font-size:0.95rem;
	    }
	    .feed-empty-actions {
	      display:flex;
	      gap:0.5rem;
	      flex-wrap:wrap;
	      justify-content:center;
	      margin-top:0.25rem;
	    }
    .build-metrics {
      display:flex;
      gap:1rem;
      flex-wrap:wrap;
      align-items:flex-start;
    }
    .build-metrics.hidden { display:none; }
    .timeline-panel {
      position:relative;
      padding:32px;
      background:linear-gradient(180deg, rgba(255,255,255,0.96), rgba(255,255,255,0.64));
      border:1px solid rgba(255,255,255,0.45);
      box-shadow:0 32px 60px rgba(15,23,42,0.08);
      overflow:visible;
    }
    .timeline-panel::before {
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      background:radial-gradient(circle at 20% 0%, rgba(255,255,255,0.9), rgba(255,255,255,0));
      pointer-events:none;
      opacity:0.9;
    }
    .timeline-panel.hidden {
      display:none;
    }
    .timeline-panel.timeline-no-window .timeline-track,
    .timeline-panel.timeline-no-window .timeline-mini,
    .timeline-panel.timeline-no-window .timeline-readout {
      display:none;
    }
    .timeline-panel.timeline-no-window .timeline-head {
      margin-bottom:0;
    }
    .timeline-windows {
      display:grid;
      grid-template-columns:1fr;
      gap:18px;
      margin-top:18px;
      position:relative;
      z-index:1;
    }
    @media (max-width: 1100px) {
      .timeline-windows { grid-template-columns:1fr; }
    }
    .timeline-window {
      border-radius:22px;
      border:1px solid rgba(15,23,42,0.12);
      background:rgba(255,255,255,0.82);
      box-shadow:0 18px 40px rgba(15,23,42,0.10);
      backdrop-filter:blur(16px);
      padding:18px 18px 16px;
      min-width:0;
      position:relative;
    }
    .timeline-window .panel-title-row {
      margin-bottom:0.65rem;
    }
    .timeline-window .panel-title-row h2 {
      font-size:0.9rem;
    }
    .timeline-window .log-feed {
      max-height:54vh;
      padding:18px 18px 22px;
      background:linear-gradient(180deg, rgba(255,255,255,0.92), rgba(255,255,255,0.68));
      border-radius:18px;
      border:1px solid rgba(15,23,42,0.10);
    }
    .timeline-window .feed-empty {
      left:32px;
      right:32px;
      top:32px;
      bottom:32px;
    }
	    .timeline-window .stream-view-toggle {
	      display:flex;
	      gap:0.35rem;
	      align-items:center;
	      flex-wrap:wrap;
	    }
    .timeline-window .stream-view-toggle .chip-button {
      padding:0.38rem 0.8rem;
      font-size:0.72rem;
      letter-spacing:0.14em;
    }
	    body.stream-view-logs #eventsPanel { display:none !important; }
	    body.stream-view-events #streamLogsPane { display:none !important; }
	    .talker-list {
	      display:flex;
	      flex-direction:column;
	      gap:0.55rem;
	    }
	    .talker-row {
	      display:flex;
	      justify-content:space-between;
	      gap:0.85rem;
	      border-radius:18px;
	      border:1px solid rgba(15,23,42,0.10);
	      background:rgba(15,23,42,0.02);
	      padding:10px 12px;
	      cursor:pointer;
	    }
	    .talker-row:hover,
	    .talker-row:focus-visible {
	      outline:none;
	      border-color:rgba(37,99,235,0.30);
	      background:rgba(37,99,235,0.05);
	    }
	    .talker-row .left {
	      min-width:0;
	      flex:1;
	      display:flex;
	      flex-direction:column;
	      gap:0.15rem;
	    }
	    .talker-row .left strong {
	      font-size:0.9rem;
	      letter-spacing:-0.01em;
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	    }
	    .talker-row .left span {
	      font-size:0.82rem;
	      color:var(--muted);
	      overflow:hidden;
	      text-overflow:ellipsis;
	      white-space:nowrap;
	    }
	    .talker-row .badge {
	      border-radius:999px;
	      border:1px solid rgba(15,23,42,0.14);
	      background:rgba(255,255,255,0.70);
	      color:var(--muted);
	      font-size:0.72rem;
	      letter-spacing:0.14em;
	      text-transform:uppercase;
	      padding:0.18rem 0.65rem;
	      flex:0 0 auto;
	    }
    .timeline-window-events .event-list {
      margin-top:12px;
      max-height:54vh;
      overflow:auto;
      padding-right:6px;
    }
    .timeline-head {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:1rem;
      margin-bottom:18px;
      position:relative;
      z-index:1;
    }
    .timeline-actions {
      display:flex;
      gap:0.6rem;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .timeline-readout {
      display:flex;
      flex-wrap:wrap;
      gap:0.5rem;
      align-items:center;
      margin-top:0.65rem;
      position:relative;
      z-index:1;
    }
    .timeline-readout .chip-inline {
      text-transform:none;
      letter-spacing:0.02em;
      font-size:0.82rem;
      background:rgba(15,23,42,0.04);
      color:var(--muted);
    }
    .timeline-copy .eyebrow {
      margin:0;
      text-transform:uppercase;
      letter-spacing:0.24em;
      font-size:0.72rem;
      color:var(--muted);
    }
    .timeline-track {
      position:relative;
      width:100%;
      height:220px;
      border-radius:22px;
      background:
        linear-gradient(90deg, rgba(255,255,255,0.12) 0, rgba(255,255,255,0.12) var(--timeline-label-width), rgba(12,12,16,0.12) var(--timeline-label-width), rgba(12,12,16,0.2) 100%),
        linear-gradient(180deg, rgba(12,12,16,0.06), rgba(12,12,16,0.18));
      border:1px solid rgba(15,15,20,0.25);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.15), inset 0 -2px 6px rgba(0,0,0,0.2);
      overflow:hidden;
      cursor:pointer;
      backdrop-filter:blur(4px);
    }
    .timeline-mini {
      margin-top:0.6rem;
      border-radius:16px;
      border:1px solid rgba(15,15,20,0.18);
      background:linear-gradient(180deg, rgba(12,12,16,0.06), rgba(12,12,16,0.14));
      overflow:hidden;
      position:relative;
      height:54px;
      cursor:pointer;
    }
    .timeline-mini canvas {
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }
    .timeline-track::after {
      content:"";
      position:absolute;
      inset:0;
      background:linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0));
      pointer-events:none;
    }
    .timeline-track canvas {
      position:absolute;
      top:0;
      left:0;
      width:100%;
      height:100%;
      pointer-events:none;
    }
    .timeline-scrubber {
      position:absolute;
      top:0;
      bottom:0;
      width:2px;
      background:rgba(255,255,255,0.92);
      transform:translateX(-50%);
      box-shadow:0 0 0 1px rgba(15,23,42,0.14), 0 18px 36px rgba(37,99,235,0.25);
      outline:none;
    }
    .timeline-scrubber::after {
      content:"";
      position:absolute;
    }
    .timeline-scrubber::after {
      top:12px;
      left:50%;
      width:16px;
      height:22px;
      transform:translateX(-50%);
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.22);
      background:linear-gradient(180deg, #fdfdfd 0%, #e7edf5 35%, #aeb7c6 60%, #f4f7fb 100%);
      box-shadow:0 10px 24px rgba(37,99,235,0.28), inset 0 1px 0 rgba(255,255,255,0.82);
    }
    .timeline-scrubber:focus-visible {
      box-shadow:0 0 0 3px rgba(37,99,235,0.35), 0 10px 24px rgba(37,99,235,0.3);
    }
    .timeline-tooltip {
      position:absolute;
      top:-56px;
      padding:0.35rem 0.9rem;
      border-radius:999px;
      background:rgba(15,23,42,0.92);
      color:#fff;
      font-size:0.78rem;
      pointer-events:none;
      white-space:nowrap;
      box-shadow:0 16px 32px rgba(15,23,42,0.2);
      transform:translate(-50%,-4px);
      opacity:0;
      transition:opacity 160ms var(--ease), transform 160ms var(--ease);
    }
    .timeline-tooltip::after {
      content:"";
      position:absolute;
      bottom:-6px;
      left:50%;
      transform:translateX(-50%);
      border-width:6px 6px 0 6px;
      border-style:solid;
      border-color:rgba(15,23,42,0.92) transparent transparent transparent;
    }
    .timeline-tooltip.is-visible {
      opacity:1;
      transform:translate(-50%, -10px);
    }
    .timeline-tooltip[hidden] { display:none; }
    .graph-panel {
      padding:28px 32px;
    }
    .graph-panel.hidden {
      display:none;
    }
    .graph-node-list {
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem;
    }
    .graph-node-pill {
      border:1px solid rgba(15,23,42,0.15);
      border-radius:999px;
      padding:0.4rem 1rem;
      font-size:0.85rem;
      cursor:pointer;
      background:rgba(248,250,252,0.7);
      transition:background 140ms var(--ease), border-color 140ms var(--ease), color 140ms var(--ease);
    }
    .graph-node-pill:hover,
    .graph-node-pill:focus-visible {
      border-color:var(--accent);
      color:var(--accent);
      outline:none;
    }
    .graph-node-pill.status-failed {
      border-color:#ef4444;
      color:#ef4444;
    }
    .graph-node-pill.status-running {
      border-color:var(--accent);
      color:var(--accent);
    }
    .graph-node-pill.status-cached {
      border-color:#0ea5e9;
      color:#0ea5e9;
    }
    .graph-node-pill.status-completed {
      border-color:rgba(15,23,42,0.2);
      color:#0f172a;
      background:linear-gradient(180deg, #fdfefe, #e0e5ee);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.8), inset 0 -1px 0 rgba(15,23,42,0.08);
    }
    .graph-node-pill.active {
      background:rgba(37,99,235,0.08);
      border-color:var(--accent);
      color:var(--accent);
    }
    .health-panel.hidden { display:none; }
    .health-list {
      display:flex;
      flex-direction:column;
      gap:0.75rem;
      margin-top:1rem;
    }
    .health-row {
      display:flex;
      flex-direction:column;
      gap:0.35rem;
      padding:0.7rem 0.9rem;
      border-radius:16px;
      border:1px solid rgba(15,23,42,0.08);
      background:rgba(248,250,252,0.65);
    }
    .health-head {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1rem;
    }
    .health-name {
      font-weight:600;
      font-size:0.95rem;
      color:var(--text);
    }
    .health-meta {
      color:var(--muted);
      font-size:0.8rem;
      letter-spacing:0.12em;
      text-transform:uppercase;
      white-space:nowrap;
    }
    .health-strip {
      display:flex;
      height:10px;
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(15,23,42,0.08);
      background:rgba(15,23,42,0.04);
    }
    .health-seg {
      flex:1;
      background:rgba(15,23,42,0.12);
    }
    .health-seg.ok { background:rgba(34,197,94,0.42); }
    .health-seg.warn { background:rgba(251,191,36,0.5); }
    .health-seg.bad { background:rgba(239,68,68,0.5); }
    .manifest-panel.hidden {
      display:none;
    }
    .manifest-grid {
      display:grid;
      grid-template-columns: 1fr 1.2fr;
      gap:1rem;
      align-items:start;
      margin-top:1rem;
    }
    @media (max-width: 1100px) {
      .manifest-grid {
        grid-template-columns: 1fr;
      }
    }
    .manifest-list input[type="search"] {
      width:100%;
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.12);
      padding:0.65rem 1rem;
      font-size:0.95rem;
      background:rgba(255,255,255,0.75);
      margin-bottom:0.8rem;
    }
    .manifest-list input[type="search"]:focus-visible {
      outline:3px solid rgba(37,99,235,0.25);
      border-color:var(--accent);
    }
    .manifest-node-list { display:flex; flex-direction:column; gap:0.4rem; }
    .manifest-tree {
      display:flex;
      flex-direction:column;
      gap:0.35rem;
    }
    .manifest-tree details {
      border-radius:16px;
      border:1px solid rgba(15,23,42,0.10);
      background:rgba(15,23,42,0.02);
      padding:0.35rem 0.5rem;
    }
    .manifest-tree summary {
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:0.75rem;
      cursor:pointer;
      padding:0.25rem 0.35rem;
      border-radius:12px;
    }
    .manifest-tree summary::-webkit-details-marker { display:none; }
    .manifest-tree summary:focus-visible { outline:3px solid rgba(37,99,235,0.25); }
    .manifest-tree .manifest-row {
      display:flex;
      align-items:center;
      gap:0.55rem;
      flex-wrap:wrap;
    }
    .manifest-tree .manifest-name {
      font-weight:600;
      color:var(--text);
      letter-spacing:-0.01em;
    }
    .manifest-tree .manifest-kind {
      font-size:0.75rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .manifest-tree .manifest-children {
      margin-top:0.4rem;
      padding-left:1rem;
      display:flex;
      flex-direction:column;
      gap:0.35rem;
      border-left:2px solid rgba(15,23,42,0.08);
    }
    .sidebar .manifest-grid { grid-template-columns:1fr; }
    .sidebar .manifest-yaml { max-height:340px; }

    .entity-grid {
      display:grid;
      grid-template-columns:1fr;
      gap:0.85rem;
    }
    .entity-block {
      border-radius:18px;
      border:1px solid rgba(15,23,42,0.10);
      background:rgba(15,23,42,0.02);
      padding:14px 16px;
    }
    .entity-block h3 {
      margin:0 0 8px;
      font-size:0.82rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
      display:flex;
      justify-content:space-between;
      gap:0.65rem;
      align-items:center;
    }
    .entity-list {
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem;
    }
    .entity-pill {
      border-radius:999px;
      border:1px solid rgba(15,23,42,0.14);
      background:rgba(255,255,255,0.75);
      color:var(--text);
      font-size:0.82rem;
      padding:0.18rem 0.75rem;
      cursor:pointer;
      transition:transform 140ms var(--ease), border-color 140ms var(--ease), background 140ms var(--ease);
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .entity-pill:hover,
    .entity-pill:focus-visible {
      outline:none;
      transform:translateY(-1px);
      border-color:rgba(37,99,235,0.35);
      background:rgba(37,99,235,0.06);
      color:var(--accent);
    }
    .entity-pill.badge-warn { border-color:rgba(251,191,36,0.55); }
    .entity-pill.badge-fail { border-color:rgba(239,68,68,0.55); }

    .bookmark-list {
      display:flex;
      flex-direction:column;
      gap:0.55rem;
    }
    .bookmark-row {
      display:flex;
      align-items:center;
      gap:0.6rem;
      border-radius:18px;
      border:1px solid rgba(15,23,42,0.10);
      background:rgba(15,23,42,0.02);
      padding:10px 12px;
    }
    .bookmark-row .label {
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      gap:0.15rem;
    }
    .bookmark-row .label strong {
      font-size:0.9rem;
      letter-spacing:-0.01em;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .bookmark-row .label span {
      font-size:0.82rem;
      color:var(--muted);
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .bookmark-row .actions {
      display:flex;
      gap:0.35rem;
      flex-wrap:wrap;
    }

    .manifest-detail-head {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:1rem;
      margin-bottom:0.6rem;
    }
    .manifest-detail-actions {
      display:flex;
      gap:0.45rem;
      flex-wrap:wrap;
      justify-content:flex-end;
      align-items:center;
    }
    .manifest-breadcrumbs {
      margin:0 0 0.6rem;
      font-size:0.85rem;
      color:var(--muted);
      line-height:1.3;
      word-break:break-word;
    }
    .manifest-breadcrumbs button {
      border:none;
      background:none;
      color:inherit;
      cursor:pointer;
      padding:0;
      text-decoration:underline;
    }
    .manifest-breadcrumbs button:hover,
    .manifest-breadcrumbs button:focus-visible {
      outline:none;
      color:var(--accent);
    }
    .manifest-links {
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem;
      margin-bottom:0.6rem;
    }
    .manifest-links .link-label {
      display:inline-flex;
      align-items:center;
      gap:0.5rem;
      font-size:0.75rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
      margin-right:0.2rem;
    }
    .session-nav {
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem;
      margin-top:0.65rem;
    }
    #laneFilterBlock .chip-tray {
      display:flex;
      flex-wrap:wrap;
      gap:0.45rem;
    }
    .manifest-yaml {
      background:rgba(15,23,42,0.04);
      border:1px solid rgba(15,23,42,0.08);
      border-radius:16px;
      padding:1rem 1.1rem;
      overflow:auto;
      max-height:520px;
      font-size:0.85rem;
      line-height:1.35;
      white-space:pre;
    }
    .metric-chip {
      border-radius:18px;
      padding:0.4rem 1rem;
      background:rgba(15,23,42,0.04);
      border:1px solid rgba(15,23,42,0.08);
      min-width:140px;
      display:flex;
      flex-direction:column;
      gap:0.15rem;
    }
    .metric-chip.status-chip {
      min-width:160px;
    }
    .metric-label {
      font-size:0.75rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .metric-value {
      font-size:1.2rem;
      font-weight:600;
      color:var(--text);
    }
    .status-pill {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:0.2rem 0.9rem;
      border-radius:999px;
      text-transform:uppercase;
      letter-spacing:0.08em;
      font-size:0.85rem;
      font-weight:600;
      border:1px solid transparent;
    }
    .status-pill.status-building {
      color:#1d4ed8;
      background:rgba(37,99,235,0.12);
      border-color:rgba(37,99,235,0.3);
    }
    .status-pill.status-success {
      color:#047857;
      background:rgba(16,185,129,0.15);
      border-color:rgba(16,185,129,0.35);
    }
    .status-pill.status-failed {
      color:#b91c1c;
      background:rgba(239,68,68,0.15);
      border-color:rgba(239,68,68,0.35);
    }
    .panel-heading {
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:1rem;
      margin-bottom:1.25rem;
    }
    .panel-heading h2 {
      margin:0;
      font-size:1.25rem;
      letter-spacing:0.02em;
    }
    .eyebrow {
      text-transform:uppercase;
      letter-spacing:0.2em;
      font-size:0.75rem;
      color:var(--muted);
      margin:0 0 0.35rem;
    }
    .heatmap-panel { display:none; }
    .heatmap-panel.active { display:block; }
    .service-grid {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      gap:1rem;
    }
    .score-card {
      border-radius:24px;
      padding:24px;
      background:var(--surface-soft);
      border:1px solid rgba(15,23,42,0.08);
      box-shadow:inset 0 1px 0 rgba(255,255,255,0.6);
      display:flex;
      flex-direction:column;
      gap:0.6rem;
      min-height:160px;
    }
    .score-card.pass { border-color:rgba(34,197,94,0.35); }
    .score-card.warn { border-color:rgba(251,191,36,0.6); }
    .score-card.fail { border-color:rgba(239,68,68,0.65); }
    .score-card-head {
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:0.75rem;
    }
    .score-card-head .label {
      font-size:0.95rem;
      font-weight:600;
      letter-spacing:0.04em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .score-badge {
      border-radius:999px;
      padding:0.2rem 0.8rem;
      border:1px solid rgba(15,23,42,0.12);
      font-size:0.7rem;
      letter-spacing:0.14em;
      text-transform:uppercase;
      color:var(--muted);
    }
    .score-card.fail .score-badge { color:var(--fail); border-color:rgba(239,68,68,0.5); }
    .score-card.warn .score-badge { color:var(--warn); border-color:rgba(251,191,36,0.5); }
    .score-card strong {
      font-size:2rem;
      letter-spacing:-0.03em;
      margin:0;
    }
    .score-card.pass strong { color:#0f172a; }
    .score-card.warn strong { color:#b45309; }
    .score-card.fail strong { color:#b91c1c; }
    .score-card .meta {
      margin:0;
      font-size:0.9rem;
      color:var(--muted);
    }
    .summary {
      margin:0;
      font-size:0.9rem;
      color:var(--muted);
    }
    .summary.failure { color:var(--fail); font-weight:600; }
    .hotspot-list {
      list-style:none;
      margin:0.5rem 0 0;
      padding:0;
      display:flex;
      flex-direction:column;
      gap:0.35rem;
    }
    .hotspot-row {
      display:flex;
      justify-content:space-between;
      font-size:0.85rem;
      color:var(--muted);
    }
    .hotspot-name { flex:1; margin-right:0.5rem; }
    .hotspot-meta { font-weight:600; color:#0f172a; }
    .sr-only {
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip:rect(0,0,0,0);
      white-space:nowrap;
      border:0;
    }
  </style>
</head>
<body data-filters-enabled="{{if .FiltersEnabled}}true{{else}}false{{end}}"{{if .ForceStatic}} data-ktl-static="true"{{end}}{{if .CaptureID}} data-capture-id="{{.CaptureID}}"{{end}}>
  <div class="chrome">
    <header>
      {{if .FiltersEnabled}}
      <div class="header-copy">
        {{if .Title}}<h1>{{.Title}}</h1>{{end}}
        {{if .ClusterInfo}}<p class="subtitle">{{.ClusterInfo}}</p>{{end}}
      </div>
      {{end}}
		      <div class="header-actions">
			        <button id="popoutTrigger" class="icon-button" type="button" aria-label="Open pop-out window" title="Pop out log feed">⇱</button>
			        <button id="sidebarToggle" class="filter-toggle" type="button" aria-pressed="false" title="Toggle sidebar">Sidebar</button>
			        <button id="filterToggle" class="filter-toggle" type="button" aria-expanded="false" aria-controls="filterPanel">Filters</button>
			        <button id="resetDefaults" class="filter-toggle" type="button" title="Reset UI to defaults">Reset</button>
			        <button id="captureToggle" class="cta-button" type="button" hidden aria-hidden="true">Start capture</button>
			        <button id="copySelected" class="filter-toggle" type="button" hidden aria-hidden="true" title="Copy selected lines">Copy selected</button>
			        <div class="status-chip" id="statusChip">Connecting…</div>
		      </div>
		    </header>
    <div class="layout">
      <div class="sidebar" id="sidebar">
	        <section class="panel capture-panel" id="sessionPanel" hidden aria-live="polite">
	          <div>
	            <p class="eyebrow">Capture</p>
	            <h2 id="sessionTitle">Session</h2>
	            <p class="summary" id="sessionSummary"></p>
	            <div class="session-stats" id="sessionStats" aria-label="Capture statistics">
	              <div class="metric-chip"><span class="metric-label">Lines</span><span class="metric-value" id="statLines">0</span></div>
	              <div class="metric-chip"><span class="metric-label">Pods</span><span class="metric-value" id="statPods">0</span></div>
	              <div class="metric-chip"><span class="metric-label">Namespaces</span><span class="metric-value" id="statNamespaces">0</span></div>
	              <div class="metric-chip"><span class="metric-label">Errors</span><span class="metric-value" id="statErrors">0</span></div>
	              <div class="metric-chip"><span class="metric-label">Warnings</span><span class="metric-value" id="statWarnings">0</span></div>
	              <div class="metric-chip"><span class="metric-label">Restarts</span><span class="metric-value" id="statRestarts">0</span></div>
	            </div>
	            <div class="session-controls" id="sessionControls">
	              <input id="timeStart" type="text" placeholder="Start (RFC3339, e.g. 2025-12-16T01:02:03Z)" aria-label="Time range start"/>
	              <input id="timeEnd" type="text" placeholder="End (RFC3339)" aria-label="Time range end"/>
	              <input id="jumpToTime" type="text" placeholder="Jump to time (RFC3339)" aria-label="Jump to time"/>
	              <button id="applyTimeRange" class="cta-button" type="button">Apply range</button>
	              <button id="clearTimeRange" class="cta-button" type="button">Clear range</button>
	              <button id="jumpToTimeBtn" class="cta-button" type="button">Jump</button>
	              <div class="session-nav">
	                <button id="jumpNextError" class="cta-button" type="button">Next error</button>
	                <button id="jumpNextEvent" class="cta-button" type="button">Next event</button>
	                <button id="jumpNextRestart" class="cta-button" type="button">Next restart</button>
	              </div>
	              <div class="session-nav">
	                <button id="jumpFirstError" class="cta-button" type="button">First error</button>
	                <button id="jumpFirstWarning" class="cta-button" type="button">First warn</button>
	                <button id="jumpFirstRestart" class="cta-button" type="button">First restart</button>
	              </div>
	              <p class="hint"></p>
	            </div>
	          </div>
	          <div class="session-actions">
	            <button id="copyReplayCmd" class="cta-button" type="button">Copy replay command</button>
          </div>
        </section>
        <section class="panel filter-panel" id="filterPanel">
          <div class="filter-head">
            <h2>Filters</h2>
            <div class="session-actions">
              <button id="saveQuery" type="button" class="link-button">Save</button>
              <button id="clearFilters" type="button" class="link-button">Reset</button>
            </div>
          </div>
        <label class="sr-only" for="filterSearch">Add log filter</label>
        <div class="filter-search-row">
          <input id="filterSearch" type="search" placeholder="Search logs" autocomplete="off" />
        </div>
        <div class="search-chip-tray preview hidden" id="searchPreviewTray" role="list" aria-label="Preview filters"></div>
	        <label class="sr-only" for="findSearch">Find within results</label>
	        <div class="filter-search-row">
	          <input id="findSearch" type="search" placeholder="Find within results (/, n/p to navigate)" autocomplete="off" />
	          <div class="find-actions" aria-label="Find navigation">
	            <button id="findPrev" class="mini-btn" type="button" title="Previous match">Prev</button>
	            <button id="findNext" class="mini-btn" type="button" title="Next match">Next</button>
	            <button id="errPrev" class="mini-btn" type="button" title="Previous error/warn">Err ◀</button>
	            <button id="errNext" class="mini-btn" type="button" title="Next error/warn">Err ▶</button>
	          </div>
	        </div>
        <div class="search-chip-tray" id="searchChipTray" role="list" aria-label="Search filters"></div>
        <div class="search-chip-tray" id="savedQueryTray" role="list" aria-label="Saved queries"></div>
        <p class="filter-hint">Type to preview · press <code>Enter</code> to pin chips. Prefixes: <code>ns:</code> namespace, <code>pod:</code> pod, <code>c:</code> container, <code>src:</code> source. Use <code>!token</code> to exclude.</p>
          <div class="chip-stack" id="quickFilterBlock">
            <div class="chip-stack-head">
              <span class="chip-meta">Quick</span>
            </div>
            <div class="chip-tray" role="group" aria-label="Quick filters">
              <button type="button" class="chip-button" data-quick-filter="onlyErrors" aria-pressed="false">Errors/Warns</button>
              <button type="button" class="chip-button" data-quick-filter="onlyOOMKilled" aria-pressed="false" disabled>OOMKilled</button>
              <button type="button" class="chip-button" data-quick-filter="onlyRestarts" aria-pressed="false" disabled>Restarts &gt; 0</button>
              <button type="button" class="chip-button" data-quick-filter="onlyNotReady" aria-pressed="false" disabled>Not Ready</button>
            </div>
          </div>
          <div class="chip-stack" id="laneFilterBlock">
            <div class="chip-stack-head">
              <span class="chip-meta">Lanes</span>
            </div>
            <div class="chip-tray" role="group" aria-label="Lane filters">
              <button type="button" class="chip-button active" data-lane="pod" aria-pressed="true">Pod logs</button>
              <button type="button" class="chip-button active" data-lane="event" aria-pressed="true">Events</button>
              <button type="button" class="chip-button active" data-lane="node" aria-pressed="true">Node</button>
              <button type="button" class="chip-button active" data-lane="system" aria-pressed="true">System</button>
            </div>
          </div>
          <div class="chip-stack hidden" id="datasetFilterBlock">
            <div class="chip-stack-head">
              <span class="chip-meta">Dataset</span>
            </div>
            <div class="chip-tray" role="group" aria-label="Dataset filters">
              <button type="button" class="chip-button active" data-dataset="left" aria-pressed="true">Left</button>
              <button type="button" class="chip-button active" data-dataset="right" aria-pressed="true">Right</button>
            </div>
          </div>
          <div class="filter-grid">
            <div class="chip-stack">
              <div class="chip-stack-head">
                <span class="chip-meta" id="namespaceMeta">0 ACTIVE</span>
              </div>
              <div id="namespaceFilters" class="chip-tray" role="group" aria-label="Namespace filters"></div>
            </div>
            <div class="chip-stack">
              <div class="chip-stack-head">
                <span class="chip-meta" id="podMeta">0 ACTIVE</span>
              </div>
              <div id="podFilters" class="chip-tray" role="group" aria-label="Pod filters"></div>
            </div>
          </div>
        </section>
	        <section class="panel compact" id="entitiesPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Entities</h2>
	            <span class="chip-inline" id="entitiesSummary">—</span>
	          </div>
	          <p class="subtle">Click to filter. Shift-click adds; Alt-click excludes.</p>
	          <div class="entity-grid" id="entitiesGrid"></div>
	        </section>
	        <section class="panel compact" id="topTalkersPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Top Talkers</h2>
	            <div class="stream-view-toggle" role="group" aria-label="Top talkers mode">
	              <button id="talkersByLines" type="button" class="chip-button active" aria-pressed="true">Lines</button>
	              <button id="talkersByErrors" type="button" class="chip-button" aria-pressed="false">Errors</button>
	            </div>
	          </div>
	          <p class="subtle">Click to focus. Shift-click adds. Uses visible pod logs only.</p>
	          <div class="talker-list" id="topTalkersList"></div>
	        </section>
	        <section class="panel session-panel" id="eventInspectorPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Event</h2>
	            <span class="chip-inline" id="eventInspectorChip">—</span>
	          </div>
          <p class="subtle" id="eventInspectorSummary">Select an event to inspect.</p>
          <div class="session-actions">
            <button id="eventRelatedLogs" class="mini-btn primary" type="button">Related ±30s</button>
            <button id="eventFocusPods" class="mini-btn" type="button">Focus pods</button>
            <button id="eventFocusResource" class="mini-btn" type="button">View resource</button>
            <button id="eventClose" class="mini-btn" type="button">Close</button>
          </div>
	          <pre class="manifest-yaml" id="eventInspectorBody" style="max-height:260px; margin-top:0.75rem;"></pre>
	        </section>
	        {{if not .CaptureID}}
	        <section class="panel compact" id="eventsPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Events</h2>
	            <span class="chip-inline" id="eventsSummaryChip">—</span>
	          </div>
	          <label class="sr-only" for="eventsSearch">Filter events</label>
	          <div class="filter-search-row">
	            <input id="eventsSearch" type="search" placeholder="Filter events (reason/message/kind/name)" autocomplete="off" />
	          </div>
	          <div class="event-list" id="eventsList"></div>
	        </section>
	        {{end}}
	        <section class="panel manifest-panel hidden" id="manifestPanel" aria-hidden="true">
	          <div class="panel-heading">
	            <div>
	              <p class="eyebrow">Manifests</p>
	              <h2>Captured Resources</h2>
            </div>
            <span class="chip-inline" id="manifestSummaryChip">—</span>
          </div>
          <div class="manifest-grid">
            <div class="manifest-list">
              <label class="sr-only" for="manifestSearch">Filter manifests</label>
              <input id="manifestSearch" type="search" placeholder="Filter manifests (e.g. deploy/, ns:prod, kind:pod)" autocomplete="off" />
              <div class="manifest-node-list" id="manifestNodeList" role="list"></div>
            </div>
            <div class="manifest-detail">
	              <div class="manifest-detail-head">
	                <p class="eyebrow" id="manifestDetailTitle">Select a resource</p>
	                <div class="manifest-detail-actions">
	                  <button id="pinManifest" class="mini-btn" type="button">Pin</button>
	                  <button id="manifestShowPods" class="mini-btn" type="button">Show pods</button>
	                  <button id="manifestShowEvents" class="mini-btn" type="button">Show events</button>
	                  <button id="manifestCompare" class="mini-btn" type="button">Compare</button>
	                  <button id="copyManifestYaml" class="mini-btn" type="button">Copy YAML</button>
	                </div>
	              </div>
              <p class="manifest-breadcrumbs" id="manifestBreadcrumbs"></p>
              <div class="manifest-links" id="manifestLinks"></div>
              <pre class="manifest-yaml" id="manifestYaml"></pre>
            </div>
          </div>
        </section>
        <section class="panel diff-panel hidden" id="diffPanel" aria-live="polite" aria-hidden="true">
          <div class="panel-heading">
            <div>
              <p class="eyebrow">Diff</p>
              <h2>What Changed</h2>
            </div>
            <span class="chip-inline" id="diffSummaryChip">—</span>
          </div>
          <div class="diff-grid">
            <div class="diff-box">
              <h3 id="diffLeftTitle">Only Left</h3>
              <ul class="diff-list" id="diffOnlyLeft"></ul>
            </div>
            <div class="diff-box">
              <h3 id="diffRightTitle">Only Right</h3>
              <ul class="diff-list" id="diffOnlyRight"></ul>
            </div>
          </div>
          <div class="diff-box">
            <h3>Changed Pods</h3>
            <ul class="diff-list" id="diffChanged"></ul>
          </div>
        </section>
	        <section class="panel context-panel" id="contextPanel" hidden aria-live="polite">
	          <h2>Context</h2>
	          <p class="summary" id="contextSummary"></p>
	          <div class="context-grid" id="contextGrid"></div>
	        </section>
	        <section class="panel compact" id="contextLinesPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Context Lines</h2>
	            <div class="session-actions">
	              <button id="contextRadius20" class="mini-btn" type="button">±20</button>
	              <button id="contextRadius50" class="mini-btn" type="button">±50</button>
	              <button id="copyContextLines" class="mini-btn primary" type="button">Copy</button>
	            </div>
	          </div>
	          <p class="subtle" id="contextLinesSummary">Select a log line to view context.</p>
	          <pre class="manifest-yaml" id="contextLinesBody" style="max-height:360px; margin-top:0.75rem;"></pre>
	        </section>
	        <section class="panel compact" id="bookmarksPanel" hidden aria-live="polite">
	          <div class="panel-title-row">
	            <h2>Bookmarks</h2>
	            <div class="session-actions">
	              <button id="exportBookmarks" class="mini-btn" type="button">Export</button>
	              <button id="clearBookmarks" class="mini-btn" type="button">Clear</button>
	            </div>
	          </div>
	          <div class="bookmark-list" id="bookmarkList"></div>
	        </section>
      </div>
      <div class="main">
        <section class="panel compact active-filters hidden" id="activeFiltersBar" aria-live="polite" aria-hidden="true">
          <div class="active-filters-row">
            <div class="active-filters-chips" id="activeFiltersChips"></div>
            <div class="active-filters-actions">
              <button id="activeFiltersClear" class="mini-btn danger" type="button">Clear</button>
            </div>
          </div>
        </section>
        <section id="buildMetrics" class="panel build-metrics hidden" aria-live="polite">
          <div class="metric-chip">
            <span class="metric-label">Cache hits</span>
            <span class="metric-value" id="metricCacheHits">0</span>
          </div>
          <div class="metric-chip">
            <span class="metric-label">Cache misses</span>
            <span class="metric-value" id="metricCacheMisses">0</span>
          </div>
          <div class="metric-chip">
            <span class="metric-label">Elapsed</span>
            <span class="metric-value" id="metricElapsed">—</span>
          </div>
          <div class="metric-chip status-chip">
            <span class="metric-label">Status</span>
            <span class="metric-value status-pill status-building" id="metricStatus">Building</span>
          </div>
        </section>
        <section class="panel timeline-panel hidden" id="timelinePanel" aria-hidden="true">
          <div class="timeline-head">
            <div class="timeline-copy">
              <p class="eyebrow">Log Timeline</p>
            </div>
            <div class="timeline-actions">
              <button id="timelineFit" class="cta-button" type="button">Fit</button>
              <button id="timelineZoomOut" class="cta-button" type="button">Zoom out</button>
              <button id="timelineZoomIn" class="cta-button" type="button">Zoom in</button>
              <button id="timelineSnap" class="cta-button" type="button" aria-pressed="false" title="Snap scrubbing to markers">Snap</button>
              <button id="timelineClearSelection" class="cta-button" type="button">Clear selection</button>
            </div>
          </div>
          <div class="timeline-track" id="timelineTrack">
            <canvas id="timelineCanvas" aria-hidden="true"></canvas>
            <div id="timelineScrubber" class="timeline-scrubber" role="slider" aria-label="Log timeline" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" tabindex="0"></div>
          </div>
          <div class="timeline-mini" id="timelineMini">
            <!-- mini canvas removed -->
          </div>
          <div class="timeline-readout" id="timelineReadout" aria-live="polite">
            <span class="chip-inline" id="timelineWindowChip">window: —</span>
            <span class="chip-inline" id="timelinePlayheadChip">playhead: —</span>
            <span class="chip-inline" id="timelineSelectionChip">selection: —</span>
          </div>
          <div id="timelineTooltip" class="timeline-tooltip" hidden></div>
          {{if .CaptureID}}
          <div class="timeline-windows" aria-label="Capture windows">
            <div class="timeline-window timeline-window-stream" aria-label="Logs and events">
              <div class="panel-title-row">
                <h2>Stream</h2>
                <div class="stream-view-toggle" role="group" aria-label="Stream view">
                  <button id="streamViewBoth" type="button" class="chip-button active" aria-pressed="true">All</button>
                  <button id="streamViewLogs" type="button" class="chip-button" aria-pressed="false">Logs</button>
                  <button id="streamViewEvents" type="button" class="chip-button" aria-pressed="false">Events</button>
                </div>
              </div>
              <div id="streamLogsPane">
                <div id="logFeed" class="log-feed"></div>
                <div id="feedEmpty" class="feed-empty hidden" role="status" aria-live="polite" aria-atomic="true">
                  <div class="feed-empty-inner">
                    <p class="feed-empty-title" id="feedEmptyTitle">Waiting for logs…</p>
                    <p class="feed-empty-sub" id="feedEmptySub">If this stays empty, check the stream status or clear filters.</p>
                    <div class="feed-empty-actions" id="feedEmptyActions">
                      <input id="captureUploadInput" type="file" accept=".tar.gz,.tgz,.tar,.sqlite,.sqlite3,.db" hidden />
                      <button id="captureUploadChoose" class="mini-btn primary" type="button">Open capture artifact</button>
                      <button id="feedEmptyClear" class="mini-btn danger" type="button">Clear all</button>
                    </div>
                  </div>
                </div>
                <div id="feedLiveBadge" class="feed-live-badge" aria-live="polite" aria-atomic="true">Live</div>
                <button id="resumeAutoScroll" type="button" class="follow-indicator hidden" aria-label="Resume auto-scroll" title="Resume auto-scroll">
                  <span class="follow-label">Back to live</span>
                  <span class="follow-time" id="resumeAutoScrollTime">—</span>
                </button>
              </div>
              <div id="eventsPanel" hidden aria-live="polite">
                <div class="panel-title-row" style="margin-top:16px;">
                  <h2>Events</h2>
                  <span class="chip-inline" id="eventsSummaryChip">—</span>
                </div>
                <label class="sr-only" for="eventsSearch">Filter events</label>
                <div class="filter-search-row">
                  <input id="eventsSearch" type="search" placeholder="Filter events (reason/message/kind/name)" autocomplete="off" />
                </div>
                <div class="event-list" id="eventsList"></div>
              </div>
            </div>
          </div>
          {{end}}
        </section>
        {{if not .CaptureID}}
	        <section class="panel log-panel" aria-live="polite">
	          <div id="logFeed" class="log-feed"></div>
	          <div id="feedEmpty" class="feed-empty hidden" role="status" aria-live="polite" aria-atomic="true">
	            <div class="feed-empty-inner">
	              <p class="feed-empty-title" id="feedEmptyTitle">Waiting for logs…</p>
	              <p class="feed-empty-sub" id="feedEmptySub">If this stays empty, check the stream status or clear filters.</p>
	              <div class="feed-empty-actions" id="feedEmptyActions">
	                <input id="captureUploadInput" type="file" accept=".tar.gz,.tgz,.tar,.sqlite,.sqlite3,.db" hidden />
	                <button id="captureUploadChoose" class="mini-btn primary" type="button">Open capture artifact</button>
	                <button id="feedEmptyClear" class="mini-btn danger" type="button">Clear all</button>
	              </div>
	            </div>
	          </div>
	          <div id="feedLiveBadge" class="feed-live-badge" aria-live="polite" aria-atomic="true">Live</div>
	          <button id="resumeAutoScroll" type="button" class="follow-indicator hidden" aria-label="Resume auto-scroll" title="Resume auto-scroll">
	            <span class="follow-label">Back to live</span>
	            <span class="follow-time" id="resumeAutoScrollTime">—</span>
	          </button>
	        </section>
        {{end}}
        <section class="panel heatmap-panel" id="heatmapPanel" hidden>
          <div class="panel-heading">
            <div>
              <p class="eyebrow">Compose Heatmap</p>
              <h2>Service Builds</h2>
            </div>
            <span class="chip-inline" id="heatmapSummaryChip">Awaiting services</span>
          </div>
          <div class="service-grid" id="heatmapGrid" role="list"></div>
        </section>
        <section class="panel graph-panel hidden" id="graphPanel" aria-hidden="true">
          <div class="panel-heading">
            <div>
              <p class="eyebrow">Build Graph</p>
            </div>
            <span class="chip-inline" id="graphSummaryChip">Initializing…</span>
          </div>
          <div class="graph-node-list" id="graphNodeList"></div>
        </section>
        <section class="panel health-panel hidden" id="healthPanel" aria-hidden="true">
          <div class="panel-heading">
            <div>
              <p class="eyebrow">Health</p>
              <h2>Pod State Timeline</h2>
            </div>
            <span class="chip-inline" id="healthSummaryChip">—</span>
          </div>
          <div class="health-list" id="healthList"></div>
        </section>
      </div>
    </div>
  </div>
  {{- if or .ForceStatic .StaticLogsB64 }}
  <textarea id="ktlStaticLogsB64" hidden aria-hidden="true">{{ .StaticLogsB64 }}</textarea>
  {{- end }}
  {{- if .SessionMetaB64 }}
  <textarea id="ktlSessionMetaB64" hidden aria-hidden="true">{{ .SessionMetaB64 }}</textarea>
  {{- end }}
  {{- if .EventsB64 }}
  <textarea id="ktlK8sEventsB64" hidden aria-hidden="true">{{ .EventsB64 }}</textarea>
  {{- end }}
  {{- if .ManifestsB64 }}
  <textarea id="ktlK8sManifestsB64" hidden aria-hidden="true">{{ .ManifestsB64 }}</textarea>
  {{- end }}
  <script>
	    (function() {
	      const feed = document.getElementById('logFeed');
	      const statusChip = document.getElementById('statusChip');
	      const copySelectedBtn = document.getElementById('copySelected');
		      const filterSearch = document.getElementById('filterSearch');
		      const findSearch = document.getElementById('findSearch');
		      const findPrevBtn = document.getElementById('findPrev');
		      const findNextBtn = document.getElementById('findNext');
		      const errPrevBtn = document.getElementById('errPrev');
		      const errNextBtn = document.getElementById('errNext');
		      const searchPreviewTray = document.getElementById('searchPreviewTray');
		      const searchChipTray = document.getElementById('searchChipTray');
		      const savedQueryTray = document.getElementById('savedQueryTray');
      const namespaceFilters = document.getElementById('namespaceFilters');
      const podFilters = document.getElementById('podFilters');
      const namespaceMeta = document.getElementById('namespaceMeta');
	      const podMeta = document.getElementById('podMeta');
	      const clearFiltersBtn = document.getElementById('clearFilters');
	      const saveQueryBtn = document.getElementById('saveQuery');
	      const resetDefaultsBtn = document.getElementById('resetDefaults');
	      const resumeAutoScrollBtn = document.getElementById('resumeAutoScroll');
	      const resumeAutoScrollTime = document.getElementById('resumeAutoScrollTime');
	      const feedLiveBadge = document.getElementById('feedLiveBadge');
	      const feedEmpty = document.getElementById('feedEmpty');
	      const feedEmptyTitle = document.getElementById('feedEmptyTitle');
	      const feedEmptySub = document.getElementById('feedEmptySub');
	      const feedEmptyActions = document.getElementById('feedEmptyActions');
	      const captureUploadInput = document.getElementById('captureUploadInput');
		      const captureUploadChooseBtn = document.getElementById('captureUploadChoose');
		      const feedEmptyClearBtn = document.getElementById('feedEmptyClear');
			      const filterToggle = document.getElementById('filterToggle');
		      const sidebarToggle = document.getElementById('sidebarToggle');
		      const popoutTrigger = document.getElementById('popoutTrigger');
		      const captureToggle = document.getElementById('captureToggle');
		      const sidebar = document.getElementById('sidebar');
		      const activeFiltersBar = document.getElementById('activeFiltersBar');
		      const activeFiltersChips = document.getElementById('activeFiltersChips');
		      const activeFiltersClearBtn = document.getElementById('activeFiltersClear');
      const buildMetricsPanel = document.getElementById('buildMetrics');
      const timelinePanel = document.getElementById('timelinePanel');
      const timelineTrack = document.getElementById('timelineTrack');
      const timelineCanvas = document.getElementById('timelineCanvas');
      const timelineScrubber = document.getElementById('timelineScrubber');
      const timelineTooltip = document.getElementById('timelineTooltip');
      const timelineFitBtn = document.getElementById('timelineFit');
      const timelineZoomOutBtn = document.getElementById('timelineZoomOut');
      const timelineZoomInBtn = document.getElementById('timelineZoomIn');
      const timelineSnapBtn = document.getElementById('timelineSnap');
      const timelineClearSelectionBtn = document.getElementById('timelineClearSelection');
      const timelineReadout = document.getElementById('timelineReadout');
      const timelineWindowChip = document.getElementById('timelineWindowChip');
	      const timelinePlayheadChip = document.getElementById('timelinePlayheadChip');
	      const timelineSelectionChip = document.getElementById('timelineSelectionChip');
	      const streamViewBothBtn = document.getElementById('streamViewBoth');
	      const streamViewLogsBtn = document.getElementById('streamViewLogs');
	      const streamViewEventsBtn = document.getElementById('streamViewEvents');
	      const topTalkersPanel = document.getElementById('topTalkersPanel');
	      const topTalkersList = document.getElementById('topTalkersList');
	      const talkersByLinesBtn = document.getElementById('talkersByLines');
	      const talkersByErrorsBtn = document.getElementById('talkersByErrors');
	      const contextLinesPanel = document.getElementById('contextLinesPanel');
	      const contextLinesSummary = document.getElementById('contextLinesSummary');
	      const contextLinesBody = document.getElementById('contextLinesBody');
	      const contextRadius20Btn = document.getElementById('contextRadius20');
	      const contextRadius50Btn = document.getElementById('contextRadius50');
	      const copyContextLinesBtn = document.getElementById('copyContextLines');
      const timelineMini = document.getElementById('timelineMini');
      const graphPanel = document.getElementById('graphPanel');
      const graphSummaryChip = document.getElementById('graphSummaryChip');
      const graphNodeList = document.getElementById('graphNodeList');
      const graphSvg = document.getElementById('graphSvg');
      const healthPanel = document.getElementById('healthPanel');
      const healthSummaryChip = document.getElementById('healthSummaryChip');
      const healthList = document.getElementById('healthList');
      const metricHitsEl = document.getElementById('metricCacheHits');
      const metricMissesEl = document.getElementById('metricCacheMisses');
      const metricElapsedEl = document.getElementById('metricElapsed');
      const metricStatusEl = document.getElementById('metricStatus');
      const heatmapPanel = document.getElementById('heatmapPanel');
      const heatmapGrid = document.getElementById('heatmapGrid');
      const heatmapSummaryChip = document.getElementById('heatmapSummaryChip');
      const manifestPanel = document.getElementById('manifestPanel');
      const manifestSummaryChip = document.getElementById('manifestSummaryChip');
      const manifestSearch = document.getElementById('manifestSearch');
      const manifestNodeList = document.getElementById('manifestNodeList');
      const manifestYaml = document.getElementById('manifestYaml');
	      const manifestDetailTitle = document.getElementById('manifestDetailTitle');
	      const manifestLinks = document.getElementById('manifestLinks');
	      const copyManifestYamlBtn = document.getElementById('copyManifestYaml');
	      const pinManifestBtn = document.getElementById('pinManifest');
	      const manifestShowPodsBtn = document.getElementById('manifestShowPods');
	      const manifestShowEventsBtn = document.getElementById('manifestShowEvents');
	      const manifestCompareBtn = document.getElementById('manifestCompare');
	      const manifestBreadcrumbs = document.getElementById('manifestBreadcrumbs');
	      const eventsPanel = document.getElementById('eventsPanel');
	      const eventsList = document.getElementById('eventsList');
	      const eventsSummaryChip = document.getElementById('eventsSummaryChip');
	      const eventsSearch = document.getElementById('eventsSearch');
	      const chipFiltersEnabled = document.body.dataset.filtersEnabled !== 'false';
	      const sessionPanel = document.getElementById('sessionPanel');
	      const sessionTitle = document.getElementById('sessionTitle');
	      const sessionSummary = document.getElementById('sessionSummary');
	      const sessionStats = document.getElementById('sessionStats');
	      const statLines = document.getElementById('statLines');
	      const statPods = document.getElementById('statPods');
	      const statNamespaces = document.getElementById('statNamespaces');
	      const statErrors = document.getElementById('statErrors');
	      const statWarnings = document.getElementById('statWarnings');
	      const statRestarts = document.getElementById('statRestarts');
	      const copyReplayCmdBtn = document.getElementById('copyReplayCmd');
	      const copyShareLinkBtn = document.getElementById('copyShareLink');
	      const timeStartInput = document.getElementById('timeStart');
	      const timeEndInput = document.getElementById('timeEnd');
	      const jumpToTimeInput = document.getElementById('jumpToTime');
	      const applyTimeRangeBtn = document.getElementById('applyTimeRange');
	      const clearTimeRangeBtn = document.getElementById('clearTimeRange');
	      const jumpToTimeBtn = document.getElementById('jumpToTimeBtn');
	      const jumpNextErrorBtn = document.getElementById('jumpNextError');
	      const jumpNextEventBtn = document.getElementById('jumpNextEvent');
	      const jumpNextRestartBtn = document.getElementById('jumpNextRestart');
	      const jumpFirstErrorBtn = document.getElementById('jumpFirstError');
	      const jumpFirstWarningBtn = document.getElementById('jumpFirstWarning');
	      const jumpFirstRestartBtn = document.getElementById('jumpFirstRestart');
      const diffPanel = document.getElementById('diffPanel');
      const diffSummaryChip = document.getElementById('diffSummaryChip');
      const diffOnlyLeft = document.getElementById('diffOnlyLeft');
      const diffOnlyRight = document.getElementById('diffOnlyRight');
      const diffChanged = document.getElementById('diffChanged');
      const diffLeftTitle = document.getElementById('diffLeftTitle');
      const diffRightTitle = document.getElementById('diffRightTitle');
      const contextPanel = document.getElementById('contextPanel');
      const contextSummary = document.getElementById('contextSummary');
      const contextGrid = document.getElementById('contextGrid');
      const entitiesPanel = document.getElementById('entitiesPanel');
      const entitiesGrid = document.getElementById('entitiesGrid');
      const entitiesSummary = document.getElementById('entitiesSummary');
      const eventInspectorPanel = document.getElementById('eventInspectorPanel');
      const eventInspectorChip = document.getElementById('eventInspectorChip');
      const eventInspectorSummary = document.getElementById('eventInspectorSummary');
      const eventInspectorBody = document.getElementById('eventInspectorBody');
      const eventRelatedLogsBtn = document.getElementById('eventRelatedLogs');
      const eventFocusPodsBtn = document.getElementById('eventFocusPods');
      const eventFocusResourceBtn = document.getElementById('eventFocusResource');
      const eventCloseBtn = document.getElementById('eventClose');
      const bookmarksPanel = document.getElementById('bookmarksPanel');
      const bookmarkList = document.getElementById('bookmarkList');
      const exportBookmarksBtn = document.getElementById('exportBookmarks');
      const clearBookmarksBtn = document.getElementById('clearBookmarks');
      const urlParams = new URLSearchParams(window.location.search || '');
      const popoutMode = urlParams.has('popout');
      const inlineMetricsEnabled = !chipFiltersEnabled && !!buildMetricsPanel;
      const buildMetrics = {
        container: buildMetricsPanel,
        hitsEl: metricHitsEl,
        missesEl: metricMissesEl,
        elapsedEl: metricElapsedEl,
        statusEl: metricStatusEl,
        cacheHits: 0,
        cacheMisses: 0,
        elapsedLabel: '—',
        startedAt: null,
        timer: null,
        complete: false,
        failureDetail: '',
        status: 'building',
        statusLocked: false,
      };
      const stats = {
        lines: 0,
        namespaces: new Map(),
        pods: new Map(),
      };
	      const entries = [];
	      const logGroupState = new Map(); // groupKey -> { key, title, details, body, countEl, total, visible }
	      const selectedNamespaces = new Set();
	      const selectedPods = new Set();
      const selectedDatasets = new Set(['left', 'right']);
      const searchChipState = new Map();
      const heatmapState = new Map();
      const k8sEventsByPod = new Map();
      const podContextCache = new Map();
      const bookmarksState = {
        items: [],
      };
	      const eventInspectorState = {
	        ts: null,
	        dataset: '',
	        namespace: '',
	        pod: '',
	        kind: '',
	        name: '',
	        payload: null,
	      };
	      const eventsState = {
	        items: [],
	        search: '',
	      };
      const savedQueriesState = {
        items: [],
      };
      const STORAGE_KEYS = {
        sidebarWidth: 'ktl.logui.sidebarWidth',
        sidebarCollapsed: 'ktl.logui.sidebarCollapsed',
        shareBookmarks: 'ktl.logui.bookmarks',
        savedQueries: 'ktl.logui.savedQueries',
        streamView: 'ktl.logui.streamView',
        pinnedManifests: 'ktl.logui.pinnedManifests',
      };
      const manifestState = {
        resources: [],
        filtered: [],
        selected: null,
        selectedCompare: null,
        compareMode: false,
        search: '',
        byKey: new Map(),
        childrenByKey: new Map(),
        roots: [],
        visibleIds: new Set(),
        pinnedIds: new Set(),
      };
	      const podHealthState = {
	        dirty: false,
	        buckets: 40,
	        start: null,
	        end: null,
	        byPod: new Map(), // key -> { ns, pod, buckets: Array<'ok'|'warn'|'bad'|'none'>, restartsMax, notReady, oom, lastTs }
	      };
	      const entryBySeq = new Map(); // seq -> entry
	      const selectedEntrySeqs = new Set();
	      let entrySeq = 0;
	      let selectionAnchorIndex = null;
	      let draggingSelection = false;
	      let contextRadius = 20;
	      let talkersMode = 'lines';
	      let pauseSeqAtStart = 0;
	      let pauseAnchorTimestamp = null;
      let visibleCount = 0;
      let namespaceDirty = false;
      let podDirty = false;
      let MAX_ENTRIES = 4000;
      const FILTER_REFRESH_INTERVAL = 40;
      const ANSI_PATTERN = /\x1B\[([0-9;]*)m/g;
      const ANSI_BASE_COLORS = ['#0f172a','#ef4444','#22c55e','#eab308','#2563eb','#9333ea','#0ea5e9','#f8fafc'];
      const ANSI_BRIGHT_COLORS = ['#475569','#f87171','#4ade80','#fde047','#60a5fa','#d8b4fe','#5eead4','#ffffff'];
      const ANSI_SIMPLE_PALETTE = ANSI_BASE_COLORS.concat(ANSI_BRIGHT_COLORS);
      const ANSI_LEVELS = [0,95,135,175,215,255];
      const SEARCH_PREFIXES = new Set(['ns','namespace','pod','c','container','src','source','glyph']);
      const POD_VALUE_SEPARATOR = '::';
      const TIMELINE_EVENT_TYPES = {
        STATUS: 'status',
        CACHE_HIT: 'cache-hit',
        CACHE_MISS: 'cache-miss',
        FAIL: 'fail',
        K8S_EVENT: 'k8s-event',
        RESTART: 'restart',
        NOT_READY: 'not-ready',
      };
      const TIMELINE_COLORS = {
        'status': '#111111',
        'cache-hit': '#1c1c1c',
        'cache-miss': '#2a2a2a',
        'fail': '#050505',
        'k8s-event': '#111111',
        'restart': '#050505',
        'not-ready': '#050505',
      };
	      let autoScrollEnabled = true;
	      let autoScrollPaused = false;
	      let pauseAnchorLabel = '';
	      let previewSearchText = '';
	      let applyFiltersTimer = null;
	      let filtersCollapsed = true;
      const timelineState = {
        events: [],
        start: null,
        end: null,
        viewStart: null,
        viewEnd: null,
        playhead: null,
        pendingRender: false,
        dragging: false,
        selecting: false,
        selectionStart: null,
        selectionEnd: null,
        highlightedEntry: null,
        hoverId: null,
        lanes: [],
        laneIndex: new Map(),
      };
	      const graphState = {
	        nodes: [],
	        dirty: false,
	        pendingRender: false,
	        activeNodeId: null,
	      };
		      const uiState = {
		        invert: false,
		        snap: false,
		      };
	      let timelineTooltipHideTimeout = null;

	      function readStorage(key) {
	        try {
	          return window.localStorage ? window.localStorage.getItem(key) : null;
	        } catch (_) {
          return null;
        }
      }

      function writeStorage(key, value) {
        try {
          if (!window.localStorage) return;
          window.localStorage.setItem(key, value);
        } catch (_) {
          // ignore
        }
      }

	      function initSidebarPersistence() {
	        if (!sidebar || popoutMode) {
	          return;
	        }
        const collapsed = readStorage(STORAGE_KEYS.sidebarCollapsed);
        if (collapsed === '1') {
          document.body.classList.add('sidebar-collapsed');
        }
        const width = readStorage(STORAGE_KEYS.sidebarWidth);
        if (width) {
          const px = Number.parseInt(width, 10);
          if (Number.isFinite(px) && px >= 300 && px <= 900) {
            sidebar.style.flexBasis = px + 'px';
            sidebar.style.width = px + 'px';
          }
        }
        if (sidebarToggle) {
          const sync = () => {
            const collapsedNow = document.body.classList.contains('sidebar-collapsed');
            sidebarToggle.classList.toggle('active', !collapsedNow);
            sidebarToggle.setAttribute('aria-pressed', collapsedNow ? 'false' : 'true');
            sidebarToggle.textContent = collapsedNow ? 'Sidebar' : 'Sidebar';
          };
          sync();
          sidebarToggle.addEventListener('click', () => {
            document.body.classList.toggle('sidebar-collapsed');
            const collapsedNow = document.body.classList.contains('sidebar-collapsed');
            writeStorage(STORAGE_KEYS.sidebarCollapsed, collapsedNow ? '1' : '0');
            sync();
            scheduleTimelineRender();
          });
        }
        if ('ResizeObserver' in window) {
          const ro = new ResizeObserver(() => {
            const rect = sidebar.getBoundingClientRect();
            if (rect && rect.width) {
              writeStorage(STORAGE_KEYS.sidebarWidth, String(Math.round(rect.width)));
            }
          });
          ro.observe(sidebar);
	        }
	      }

	      function setStreamView(view) {
	        const next = (view === 'logs' || view === 'events') ? view : 'both';
	        writeStorage(STORAGE_KEYS.streamView, next);
	        document.body.classList.toggle('stream-view-logs', next === 'logs');
	        document.body.classList.toggle('stream-view-events', next === 'events');
	        if (streamViewBothBtn) {
	          const active = next === 'both';
	          streamViewBothBtn.classList.toggle('active', active);
	          streamViewBothBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
	        }
	        if (streamViewLogsBtn) {
	          const active = next === 'logs';
	          streamViewLogsBtn.classList.toggle('active', active);
	          streamViewLogsBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
	        }
	        if (streamViewEventsBtn) {
	          const active = next === 'events';
	          streamViewEventsBtn.classList.toggle('active', active);
	          streamViewEventsBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
	        }
	      }

	      function initStreamView() {
	        if (!streamViewBothBtn && !streamViewLogsBtn && !streamViewEventsBtn) {
	          return;
	        }
	        const saved = readStorage(STORAGE_KEYS.streamView);
	        setStreamView(saved || 'both');
	        if (streamViewBothBtn) {
	          streamViewBothBtn.addEventListener('click', () => setStreamView('both'));
	        }
	        if (streamViewLogsBtn) {
	          streamViewLogsBtn.addEventListener('click', () => setStreamView('logs'));
	        }
	        if (streamViewEventsBtn) {
	          streamViewEventsBtn.addEventListener('click', () => setStreamView('events'));
	        }
	      }


		      let captureState = { running: false, id: '', viewerReady: false, artifact: '' };
		      async function fetchCaptureStatus() {
	        try {
	          const res = await fetch('/api/capture/status', { headers: { 'accept': 'application/json' } });
          if (!res.ok) {
            return null;
          }
          return await res.json();
        } catch (_) {
          return null;
        }
      }

      function updateCaptureButton(state) {
        if (!captureToggle) {
          return;
        }
        if (!state) {
          captureToggle.setAttribute('hidden', 'true');
          captureToggle.setAttribute('aria-hidden', 'true');
          return;
        }
        captureState = state;
        captureToggle.removeAttribute('hidden');
        captureToggle.removeAttribute('aria-hidden');
        captureToggle.textContent = state.running ? 'Stop capture' : 'Start capture';
      }

      async function startCapture() {
        const res = await fetch('/api/capture/start', { method: 'POST' });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const state = await res.json();
        updateCaptureButton(state);
      }

      async function stopCapture() {
        const res = await fetch('/api/capture/stop', { method: 'POST' });
        if (!res.ok) {
          throw new Error(await res.text());
        }
        const payload = await res.json();
        const state = payload.status || null;
        updateCaptureButton(state);
        const url = payload.viewerURL || '';
        if (url) {
          window.location.href = url;
        }
      }

	      function setFiltersCollapsed(collapsed) {
	        filtersCollapsed = collapsed;
	        document.body.classList.toggle('filters-collapsed', collapsed);
	        if (filterToggle) {
          filterToggle.setAttribute('aria-expanded', String(!collapsed));
          filterToggle.classList.toggle('active', !collapsed);
        }
      }

      function openPopoutWindow() {
        const features = 'width=1100,height=700,resizable=yes,scrollbars=yes';
        const target = resolvePopoutURL();
        window.open(target, 'ktl-log-popout', features);
      }

      function resolvePopoutURL() {
        try {
          const url = new URL(window.location.href);
          url.searchParams.set('popout', '1');
          url.hash = '';
          return url.toString();
        } catch (_) {
          const base = window.location.pathname || '/';
          return base + '?popout=1';
        }
      }

      function escapeHTML(text) {
        if (text == null) return '';
        return text.replace(/[&<>]/g, function(ch) {
          if (ch === '&') return '&amp;';
          if (ch === '<') return '&lt;';
          if (ch === '>') return '&gt;';
          return ch;
        });
      }

      function cloneStyle(style) {
        return {
          color: style.color,
          bg: style.bg,
          bold: style.bold,
          italic: style.italic,
          underline: style.underline,
        };
      }

      function styleToCSS(style) {
        const parts = [];
        if (style.color) parts.push('color:' + style.color);
        if (style.bg) parts.push('background-color:' + style.bg);
        if (style.bold) parts.push('font-weight:600');
        if (style.italic) parts.push('font-style:italic');
        if (style.underline) parts.push('text-decoration:underline');
        return parts.join(';');
      }

      function clampColor(value) {
        const num = Number(value);
        if (!Number.isFinite(num)) return 0;
        return Math.max(0, Math.min(255, num));
      }

      function ansiSimpleColor(code) {
        if (code >= 30 && code <= 37) {
          return ANSI_BASE_COLORS[code - 30];
        }
        if (code >= 90 && code <= 97) {
          return ANSI_BRIGHT_COLORS[code - 90];
        }
        return null;
      }

      function ansiSimpleBackground(code) {
        if (code >= 40 && code <= 47) {
          return ANSI_BASE_COLORS[code - 40];
        }
        if (code >= 100 && code <= 107) {
          return ANSI_BRIGHT_COLORS[code - 100];
        }
        return null;
      }

      function ansi256Color(index) {
        const num = Number(index);
        if (!Number.isFinite(num)) return null;
        if (num >= 0 && num <= 15) {
          return ANSI_SIMPLE_PALETTE[num];
        }
        if (num >= 16 && num <= 231) {
          let remaining = num - 16;
          const r = Math.floor(remaining / 36);
          remaining -= r * 36;
          const g = Math.floor(remaining / 6);
          const b = remaining - g * 6;
          return 'rgb(' + ANSI_LEVELS[r] + ',' + ANSI_LEVELS[g] + ',' + ANSI_LEVELS[b] + ')';
        }
        if (num >= 232 && num <= 255) {
          const gray = 8 + (num - 232) * 10;
          return 'rgb(' + gray + ',' + gray + ',' + gray + ')';
        }
        return null;
      }

      function ansiToHTML(input) {
        if (!input || input.indexOf('\x1b[') === -1) {
          return null;
        }
        ANSI_PATTERN.lastIndex = 0;
        let lastIndex = 0;
        let segments = [];
        let style = { color: null, bg: null, bold: false, italic: false, underline: false };
        let match;
        while ((match = ANSI_PATTERN.exec(input)) !== null) {
          if (match.index > lastIndex) {
            segments.push({ text: input.slice(lastIndex, match.index), style: cloneStyle(style) });
          }
          applyCodes(match[1]);
          lastIndex = ANSI_PATTERN.lastIndex;
        }
        if (lastIndex < input.length) {
          segments.push({ text: input.slice(lastIndex), style: cloneStyle(style) });
        }
        const html = segments.map(segment => {
          if (!segment.text) return '';
          const escaped = escapeHTML(segment.text);
          const css = styleToCSS(segment.style);
          return css ? '<span style="' + css + '">' + escaped + '</span>' : escaped;
        }).join('');
        return html || null;

        function applyCodes(codeStr) {
          const parts = codeStr && codeStr.length ? codeStr.split(';') : ['0'];
          for (let i = 0; i < parts.length; i++) {
            const raw = parts[i];
            const code = raw === '' ? 0 : Number(raw);
            if (Number.isNaN(code)) {
              continue;
            }
            switch (code) {
              case 0:
                style = { color: null, bg: null, bold: false, italic: false, underline: false };
                break;
              case 1:
                style.bold = true;
                break;
              case 3:
                style.italic = true;
                break;
              case 4:
                style.underline = true;
                break;
              case 22:
                style.bold = false;
                break;
              case 23:
                style.italic = false;
                break;
              case 24:
                style.underline = false;
                break;
              case 39:
                style.color = null;
                break;
              case 49:
                style.bg = null;
                break;
              case 7: {
                const fg = style.color;
                style.color = style.bg || '#0f172a';
                style.bg = fg || '#f8fafc';
                break;
              }
              default:
                if ((code >= 30 && code <= 37) || (code >= 90 && code <= 97)) {
                  const fg = ansiSimpleColor(code);
                  if (fg) style.color = fg;
                } else if ((code >= 40 && code <= 47) || (code >= 100 && code <= 107)) {
                  const bg = ansiSimpleBackground(code);
                  if (bg) style.bg = bg;
                } else if (code === 38 || code === 48) {
                  const isForeground = code === 38;
                  const mode = Number(parts[++i] || 0);
                  if (mode === 2) {
                    const r = clampColor(parts[++i]);
                    const g = clampColor(parts[++i]);
                    const b = clampColor(parts[++i]);
                    const color = 'rgb(' + r + ',' + g + ',' + b + ')';
                    if (isForeground) {
                      style.color = color;
                    } else {
                      style.bg = color;
                    }
                  } else if (mode === 5) {
                    const idx = Number(parts[++i]);
                    const color = ansi256Color(idx);
                    if (color) {
                      if (isForeground) {
                        style.color = color;
                      } else {
                        style.bg = color;
                      }
                    }
                  }
                }
                break;
            }
          }
        }
      }

      function renderANSIInto(element, ansiText, fallbackText) {
        if (!element) return;
        const html = ansiToHTML(ansiText);
        if (html) {
          element.innerHTML = html;
        } else {
          element.textContent = fallbackText || ansiText || '';
        }
      }

      function parseTimestamp(value) {
        if (!value) {
          return null;
        }
        if (value instanceof Date) {
          return value;
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          return new Date(value);
        }
        const text = String(value).trim();
        if (!text) {
          return null;
        }
        const parsed = Date.parse(text);
        if (Number.isNaN(parsed)) {
          return null;
        }
        return new Date(parsed);
      }

      function updateBuildMetrics(log) {
        if (!inlineMetricsEnabled || !buildMetrics.container || !log) {
          return;
        }
        if (!buildMetrics.startedAt) {
          const start = parseTimestamp(log.timestamp || log.ts);
          buildMetrics.startedAt = start || new Date();
          startBuildElapsedTimer();
          setBuildStatus('building');
        }
        const lineText = String(log.message || log.line || log.raw || '');
        const normalizedLine = lineText.toLowerCase();
        const source = (log.source || '').toLowerCase();
        const failureDetail = captureFailureDetail(lineText);
        if (failureDetail) {
          buildMetrics.failureDetail = failureDetail;
        }
        if (source === 'diagnostic') {
          if (normalizedLine.includes('cache hit')) {
            buildMetrics.cacheHits += 1;
            renderBuildMetrics();
          } else if (normalizedLine.includes('cache miss')) {
            buildMetrics.cacheMisses += 1;
            renderBuildMetrics();
          }
        }
        if (normalizedLine.startsWith('summary:')) {
          const idx = lineText.indexOf('{');
          if (idx !== -1) {
            try {
              const summary = JSON.parse(lineText.slice(idx));
              if (Number.isFinite(summary.cacheHits)) {
                buildMetrics.cacheHits = summary.cacheHits;
              }
              if (Number.isFinite(summary.cacheMisses)) {
                buildMetrics.cacheMisses = summary.cacheMisses;
              }
              renderBuildMetrics();
            } catch (_) {
              // ignore parse issues
            }
          }
        }
        if (normalizedLine.startsWith('build failed')) {
          const failedMatch = lineText.match(/Build failed after\s+([^:]+)/i);
          if (failedMatch && failedMatch[1]) {
            buildMetrics.elapsedLabel = failedMatch[1].trim();
          }
          buildMetrics.complete = true;
          buildMetrics.statusLocked = true;
          stopBuildElapsedTimer();
          setBuildStatus('failed', buildMetrics.failureDetail || failureDetail || 'Build failed');
          renderBuildMetrics();
          return;
        }
        if (normalizedLine.startsWith('build finished in')) {
          buildMetrics.elapsedLabel = lineText.replace(/^build finished in/i, '').trim();
          buildMetrics.complete = true;
          buildMetrics.statusLocked = true;
          stopBuildElapsedTimer();
          setBuildStatus('success');
          renderBuildMetrics();
          return;
        }
      }

      function renderBuildMetrics() {
        if (!inlineMetricsEnabled || !buildMetrics.container) {
          return;
        }
        buildMetrics.container.classList.remove('hidden');
        if (buildMetrics.hitsEl) {
          buildMetrics.hitsEl.textContent = buildMetrics.cacheHits.toLocaleString();
        }
        if (buildMetrics.missesEl) {
          buildMetrics.missesEl.textContent = buildMetrics.cacheMisses.toLocaleString();
        }
        if (buildMetrics.elapsedEl) {
          if (buildMetrics.elapsedLabel && buildMetrics.elapsedLabel !== '—') {
            buildMetrics.elapsedEl.textContent = buildMetrics.elapsedLabel;
          } else if (buildMetrics.startedAt) {
            const delta = Date.now() - buildMetrics.startedAt.getTime();
            buildMetrics.elapsedEl.textContent = formatDuration(delta) || '—';
          } else {
            buildMetrics.elapsedEl.textContent = '—';
          }
        }
      }

      function recordTimelineSample(data, entryRecord) {
        if (!timelineTrack || !timelineCanvas || !data || !entryRecord) {
          return;
        }
        const ts = entryRecord.timestamp || parseTimestamp(data.ts || data.timestamp) || new Date();
        if (!ts) {
          return;
        }
        const prevStart = timelineState.start;
        const prevEnd = timelineState.end;
        if (!timelineState.start || ts < timelineState.start) {
          timelineState.start = ts;
        }
        if (!timelineState.end || ts > timelineState.end) {
          timelineState.end = ts;
        }
        // Keep the view window fitted until the user zooms.
        if (!timelineState.viewStart || !timelineState.viewEnd || (prevStart === timelineState.viewStart && prevEnd === timelineState.viewEnd)) {
          timelineState.viewStart = timelineState.start;
          timelineState.viewEnd = timelineState.end;
        }
        const sample = classifyTimelineSample(entryRecord);
        if (sample) {
          timelineState.events.push({
            ts,
            type: sample.type,
            label: sample.label,
          });
          const limit = 1200;
          if (timelineState.events.length > limit) {
            timelineState.events.splice(0, timelineState.events.length - limit);
          }
        }
        updateTimelineVisibility();
        scheduleTimelineRender();
        if (!timelineState.dragging && !timelineState.selecting) {
          timelineState.playhead = ts;
          setScrubberRatio(timeToRatio(ts), false);
          updateTimelineReadout();
        }
      }

	      function addTimelineMarker(ts, type, label, severity, meta) {
        if (!ts) {
          return;
        }
        if (!timelineState.start || ts < timelineState.start) {
          timelineState.start = ts;
        }
        if (!timelineState.end || ts > timelineState.end) {
          timelineState.end = ts;
        }
        timelineState.events.push({
          ts,
          type: type,
          label: label || '',
          severity: severity || '',
          meta: meta || null,
        });
        updateTimelineVisibility();
        scheduleTimelineRender();
      }

      function classifyTimelineSample(entryRecord) {
        if (!entryRecord || !entryRecord.data) {
          return null;
        }
        const data = entryRecord.data;
        const normalizedLine = (entryRecord.normalized && entryRecord.normalized.line) || '';
        const source = (data.source || '').toLowerCase();
        const container = (data.container || '').toLowerCase();
        const glyph = (data.glyph || '').trim();
        const rawLabel = data.line || data.raw || '';
        const label = formatTimelineLabel(rawLabel);
        if (!rawLabel) {
          return null;
        }
        if (entryRecord.flags && entryRecord.flags.restartBump) {
          return { type: TIMELINE_EVENT_TYPES.RESTART, label: 'Restart detected' };
        }
        if (entryRecord.flags && entryRecord.flags.notReadyBump) {
          return { type: TIMELINE_EVENT_TYPES.NOT_READY, label: 'NotReady transition' };
        }
        if (normalizedLine.includes('cache hit')) {
          return { type: TIMELINE_EVENT_TYPES.CACHE_HIT, label };
        }
        if (normalizedLine.includes('cache miss')) {
          return { type: TIMELINE_EVENT_TYPES.CACHE_MISS, label };
        }
        if (glyph === '✖' || normalizedLine.startsWith('build failed')) {
          return { type: TIMELINE_EVENT_TYPES.FAIL, label };
        }
        if (glyph === '⚠' || normalizedLine.includes('failed') || normalizedLine.includes('error:')) {
          return { type: TIMELINE_EVENT_TYPES.FAIL, label };
        }
        if (source === 'build' && container === 'status') {
          return { type: TIMELINE_EVENT_TYPES.STATUS, label };
        }
        if (chipFiltersEnabled || inlineMetricsEnabled) {
          return { type: TIMELINE_EVENT_TYPES.STATUS, label };
        }
        return null;
      }

      function formatTimelineLabel(value) {
        if (!value) {
          return '';
        }
        const trimmed = value.trim();
        const limit = 140;
        if (trimmed.length <= limit) {
          return trimmed;
        }
        return trimmed.slice(0, limit - 1) + '…';
      }

      function getTimelineBeamIntensity(type) {
        switch (type) {
          case TIMELINE_EVENT_TYPES.FAIL:
            return 1.2;
          case TIMELINE_EVENT_TYPES.CACHE_MISS:
            return 0.9;
          case TIMELINE_EVENT_TYPES.CACHE_HIT:
            return 0.65;
          case TIMELINE_EVENT_TYPES.STATUS:
          default:
            return 0.4;
        }
      }

      function colorWithAlpha(hex, alpha) {
        const rgb = hexToRgb(hex);
        const clamped = Math.max(0, Math.min(1, alpha || 0));
        if (!rgb) {
          return 'rgba(0,0,0,' + clamped + ')';
        }
        return 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + clamped + ')';
      }

      function hexToRgb(hex) {
        if (typeof hex !== 'string') {
          return null;
        }
        let value = hex.trim();
        if (value.startsWith('#')) {
          value = value.slice(1);
        }
        if (value.length === 3) {
          value = value.split('').map(ch => ch + ch).join('');
        }
        if (value.length !== 6) {
          return null;
        }
        const num = Number.parseInt(value, 16);
        if (Number.isNaN(num)) {
          return null;
        }
        return {
          r: (num >> 16) & 255,
          g: (num >> 8) & 255,
          b: num & 255,
        };
      }

      function updateTimelineVisibility() {
        if (!timelinePanel) {
          return;
        }
        const captureMode = !!(document.body && document.body.dataset && document.body.dataset.captureId);
        const hasEmbeddedWindows = !!document.querySelector('.timeline-windows');
        const hasWindow = !!(timelineState.start && timelineState.end);
        if (captureMode && hasEmbeddedWindows) {
          timelinePanel.classList.remove('hidden');
          timelinePanel.removeAttribute('aria-hidden');
          timelinePanel.classList.toggle('timeline-no-window', !hasWindow);
          return;
        }
        if (!hasWindow) {
          timelinePanel.classList.add('hidden');
          timelinePanel.setAttribute('aria-hidden', 'true');
        } else {
          timelinePanel.classList.remove('hidden');
          timelinePanel.removeAttribute('aria-hidden');
        }
      }

      function scheduleTimelineRender() {
        if (timelineState.pendingRender || !timelineTrack || !timelineCanvas) {
          return;
        }
        timelineState.pendingRender = true;
        window.requestAnimationFrame(renderTimeline);
      }

      function timelineLabelWidthPx() {
        const root = document.documentElement;
        if (!root) {
          return 168;
        }
        const raw = window.getComputedStyle(root).getPropertyValue('--timeline-label-width') || '';
        const parsed = Number.parseInt(String(raw).replace('px', '').trim(), 10);
        return Number.isFinite(parsed) ? parsed : 168;
      }

      function timelineWindowStart() {
        return timelineState.viewStart || timelineState.start;
      }

      function timelineWindowEnd() {
        return timelineState.viewEnd || timelineState.end;
      }

      function setTimelineView(start, end) {
        if (!start || !end) {
          timelineState.viewStart = null;
          timelineState.viewEnd = null;
          scheduleTimelineRender();
          updateTimelineReadout();
          return;
        }
        const s = start instanceof Date ? start : parseTimestamp(start);
        const e = end instanceof Date ? end : parseTimestamp(end);
        if (!s || !e) {
          return;
        }
        if (e <= s) {
          return;
        }
        timelineState.viewStart = s;
        timelineState.viewEnd = e;
        scheduleTimelineRender();
        updateTimelineReadout();
      }

      function fitTimelineView() {
        if (!timelineState.start || !timelineState.end) {
          return;
        }
        setTimelineView(timelineState.start, timelineState.end);
      }

      function zoomTimeline(factor, centerTs) {
        if (!timelineState.start || !timelineState.end) {
          return;
        }
        const globalStart = timelineState.start.getTime();
        const globalEnd = timelineState.end.getTime();
        if (globalEnd <= globalStart) {
          return;
        }
        const viewStart = timelineWindowStart() || timelineState.start;
        const viewEnd = timelineWindowEnd() || timelineState.end;
        const currentSpan = Math.max(1000, viewEnd.getTime() - viewStart.getTime());
        const nextSpan = Math.min(globalEnd - globalStart, Math.max(2500, Math.floor(currentSpan * factor)));
        const center = centerTs instanceof Date ? centerTs : (timelineState.playhead || ratioToTimestamp(0.5) || new Date(globalEnd));
        const centerMs = Math.min(globalEnd, Math.max(globalStart, center.getTime()));
        let nextStart = centerMs - Math.floor(nextSpan / 2);
        let nextEnd = centerMs + Math.floor(nextSpan / 2);
        if (nextStart < globalStart) {
          nextEnd += (globalStart - nextStart);
          nextStart = globalStart;
        }
        if (nextEnd > globalEnd) {
          nextStart -= (nextEnd - globalEnd);
          nextEnd = globalEnd;
        }
        nextStart = Math.max(globalStart, nextStart);
        nextEnd = Math.min(globalEnd, Math.max(nextStart + 1, nextEnd));
        setTimelineView(new Date(nextStart), new Date(nextEnd));
      }

      function tickIntervalMs(spanMs) {
        if (!spanMs || !Number.isFinite(spanMs) || spanMs <= 0) {
          return 60 * 1000;
        }
        if (spanMs >= 24 * 60 * 60 * 1000) return 2 * 60 * 60 * 1000;
        if (spanMs >= 6 * 60 * 60 * 1000) return 60 * 60 * 1000;
        if (spanMs >= 2 * 60 * 60 * 1000) return 30 * 60 * 1000;
        if (spanMs >= 30 * 60 * 1000) return 5 * 60 * 1000;
        if (spanMs >= 5 * 60 * 1000) return 60 * 1000;
        if (spanMs >= 60 * 1000) return 10 * 1000;
        return 2 * 1000;
      }

      function formatTick(ts) {
        if (!ts) return '';
        try {
          return ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
        } catch (_) {
          return ts.toISOString();
        }
      }

      function renderTimelineMini() {
        // timelineMiniCanvas removed.
        return;
      }

      function fmtClock(ts) {
        if (!ts) return '—';
        try {
          return ts.toLocaleString();
        } catch (_) {
          return String(ts);
        }
      }

      function updateTimelineReadout() {
        if (!timelineReadout) {
          return;
        }
        const viewStart = timelineWindowStart();
        const viewEnd = timelineWindowEnd();
        if (timelineWindowChip) {
          if (viewStart && viewEnd) {
            timelineWindowChip.textContent = 'window: ' + fmtClock(viewStart) + ' → ' + fmtClock(viewEnd);
          } else {
            timelineWindowChip.textContent = 'window: —';
          }
        }
        if (timelinePlayheadChip) {
          timelinePlayheadChip.textContent = 'playhead: ' + (timelineState.playhead ? fmtClock(timelineState.playhead) : '—');
        }
        if (timelineSelectionChip) {
          if (timeRange.start && timeRange.end) {
            timelineSelectionChip.textContent = 'selection: ' + fmtClock(timeRange.start) + ' → ' + fmtClock(timeRange.end);
          } else {
            timelineSelectionChip.textContent = 'selection: —';
          }
        }
        if (timelineSnapBtn) {
          timelineSnapBtn.classList.toggle('active', uiState.snap);
          timelineSnapBtn.setAttribute('aria-pressed', uiState.snap ? 'true' : 'false');
        }
      }

      function formatLaneLabel(lane) {
        if (!lane) {
          return '';
        }
        if (lane.type === 'event') return 'Events';
        if (lane.type === 'node') return 'Node';
        if (lane.type === 'system') return 'System';
        if (lane.type === 'pod') return lane.label || 'Pod';
        return lane.label || lane.key || '';
      }

      function computeTimelineLanes() {
        const out = [];
        const activePods = selectedPods.size ? Array.from(selectedPods) : Array.from(stats.pods.entries()).sort((a, b) => b[1] - a[1]).slice(0, 6).map(pair => pair[0]);

        if (lanes.event) out.push({ key: 'event', type: 'event' });
        if (lanes.node) out.push({ key: 'node', type: 'node' });
        if (lanes.system) out.push({ key: 'system', type: 'system' });
        if (lanes.pod) {
          activePods.slice(0, 6).forEach(value => {
            const detail = decodePodValue(value);
            out.push({ key: 'pod:' + value, type: 'pod', podValue: value, label: formatPodDisplay(detail.namespace, detail.pod) });
          });
          out.push({ key: 'pod:other', type: 'pod', podValue: '', label: 'Other pods' });
        }

        timelineState.lanes = out;
        timelineState.laneIndex = new Map();
        out.forEach((lane, idx) => timelineState.laneIndex.set(lane.key, idx));
        return out;
      }

      function laneKeyForEntry(entry, lanesSpec) {
        if (!entry || !entry.normalized) {
          return null;
        }
        const src = entry.normalized.source || '';
        if (src === 'event') {
          return 'event';
        }
        if (src === 'node') {
          return 'node';
        }
        if (src !== 'pod') {
          return 'system';
        }
        const value = entry.keys ? entry.keys.podValue : '';
        if (!value) {
          return 'pod:other';
        }
        const direct = 'pod:' + value;
        if (lanesSpec && lanesSpec.some(l => l.key === direct)) {
          return direct;
        }
        return 'pod:other';
      }

      function renderTimeline() {
        timelineState.pendingRender = false;
        if (!timelineTrack || !timelineCanvas) {
          return;
        }
        if (!timelineState.start || !timelineState.end) {
          return;
        }
        const width = timelineTrack.clientWidth;
        const height = timelineTrack.clientHeight;
        if (!width || !height) {
          return;
        }
        const labelWidth = Math.min(width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, width - labelWidth);
        const dpr = window.devicePixelRatio || 1;
        timelineCanvas.width = width * dpr;
        timelineCanvas.height = height * dpr;
        timelineCanvas.style.width = width + 'px';
        timelineCanvas.style.height = height + 'px';
        const ctx = timelineCanvas.getContext('2d');
        if (!ctx) {
          return;
        }
        ctx.save();
        ctx.scale(dpr, dpr);
        ctx.clearRect(0, 0, width, height);

        const lanesSpec = computeTimelineLanes();
        const laneCount = Math.max(1, lanesSpec.length);
        const paddingTop = 10;
        const paddingBottom = 10;
        const available = Math.max(1, height - paddingTop - paddingBottom);
        const laneHeight = Math.max(18, Math.floor(available / laneCount));

        ctx.font = '600 12px "SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(15,23,42,0.65)';

        for (let i = 0; i < laneCount; i++) {
          const y = paddingTop + i * laneHeight;
          if (i % 2 === 1) {
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.fillRect(labelWidth, y, plotWidth, laneHeight);
          }
          ctx.fillStyle = 'rgba(15,23,42,0.65)';
          ctx.fillText(formatLaneLabel(lanesSpec[i]), 14, y + laneHeight / 2);
          ctx.strokeStyle = 'rgba(255,255,255,0.07)';
          ctx.beginPath();
          ctx.moveTo(labelWidth, y + laneHeight);
          ctx.lineTo(width, y + laneHeight);
          ctx.stroke();
        }

        const viewStart = timelineWindowStart() || timelineState.start;
        const viewEnd = timelineWindowEnd() || timelineState.end;
        const startMs = viewStart.getTime();
        const endMs = viewEnd.getTime();
        const spanMs = Math.max(1, endMs - startMs);
        const lastXByLane = new Array(laneCount).fill(-Infinity);
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (!entry || entry.visible === false || !entry.timestamp) {
            continue;
          }
          const ts = entry.timestamp.getTime();
          if (ts < startMs || ts > endMs) {
            continue;
          }
          const key = laneKeyForEntry(entry, lanesSpec);
          const idx = timelineState.laneIndex.get(key);
          if (idx == null) {
            continue;
          }
          const ratio = (ts - startMs) / spanMs;
          const x = labelWidth + Math.max(0, Math.min(plotWidth, ratio * plotWidth));
          if (x - lastXByLane[idx] < 2) {
            continue;
          }
          lastXByLane[idx] = x;
          const y = paddingTop + idx * laneHeight;
          const sev = isErrorOrWarn(entry) ? 0.95 : 0.5;
          ctx.fillStyle = colorWithAlpha('#111111', sev);
          ctx.fillRect(x, y + 3, 2, Math.max(2, laneHeight - 6));
        }

        // Overlay notable markers (restarts, k8s events, failures) as beams across the plot area.
        const events = timelineState.events;
        let lastBeamX = -Infinity;
        const MIN_BEAM_GAP = 22;
        for (let i = 0; i < events.length; i++) {
          const ev = events[i];
          const ratio = timeToRatio(ev.ts);
          const x = labelWidth + Math.max(1, Math.min(plotWidth - 1, ratio * plotWidth));
          if (ev.type === TIMELINE_EVENT_TYPES.K8S_EVENT) {
            const idx = timelineState.laneIndex.get('event');
            if (idx != null) {
              const y = paddingTop + idx * laneHeight + laneHeight / 2;
              ctx.fillStyle = ev.severity === 'fail' ? 'rgba(239,68,68,0.85)' : 'rgba(15,23,42,0.65)';
              ctx.beginPath();
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.fill();
            }
            continue;
          }
          if (x - lastBeamX < MIN_BEAM_GAP) {
            continue;
          }
          lastBeamX = x;
          const color = TIMELINE_COLORS[ev.type] || '#1a1a1a';
          const intensity = getTimelineBeamIntensity(ev.type);
          const gradient = ctx.createLinearGradient(x, paddingTop, x, height - paddingBottom);
          gradient.addColorStop(0, colorWithAlpha(color, 0));
          gradient.addColorStop(0.35, colorWithAlpha(color, 0.25 * intensity));
          gradient.addColorStop(0.85, colorWithAlpha(color, 0.55 * intensity));
          gradient.addColorStop(1, colorWithAlpha(color, 0));
          ctx.strokeStyle = gradient;
          ctx.lineWidth = Math.max(2, 2.5 * intensity);
          ctx.beginPath();
          ctx.moveTo(x, paddingTop);
          ctx.lineTo(x, height - paddingBottom);
          ctx.stroke();
        }

        if (timelineState.selectionStart && timelineState.selectionEnd) {
          const a = Math.min(timelineState.selectionStart.getTime(), timelineState.selectionEnd.getTime());
          const b = Math.max(timelineState.selectionStart.getTime(), timelineState.selectionEnd.getTime());
          const ra = (a - startMs) / spanMs;
          const rb = (b - startMs) / spanMs;
          const x0 = labelWidth + Math.max(0, Math.min(plotWidth, ra * plotWidth));
          const x1 = labelWidth + Math.max(0, Math.min(plotWidth, rb * plotWidth));
          ctx.fillStyle = 'rgba(37,99,235,0.10)';
          ctx.fillRect(Math.min(x0, x1), 0, Math.abs(x1 - x0), height);
          ctx.strokeStyle = 'rgba(37,99,235,0.35)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x0, 0);
          ctx.lineTo(x0, height);
          ctx.moveTo(x1, 0);
          ctx.lineTo(x1, height);
          ctx.stroke();
        }

        // Time ticks along the bottom of the plot.
        const tickMs = tickIntervalMs(spanMs);
        const firstTick = Math.ceil(startMs / tickMs) * tickMs;
        ctx.font = '600 11px "SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.70)';
        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        for (let t = firstTick; t <= endMs; t += tickMs) {
          const ratio = (t - startMs) / spanMs;
          const x = labelWidth + ratio * plotWidth;
          ctx.beginPath();
          ctx.moveTo(x, height - paddingBottom);
          ctx.lineTo(x, height - paddingBottom + 6);
          ctx.stroke();
          const text = formatTick(new Date(t));
          ctx.fillText(text, x + 4, height - 8);
        }

        ctx.restore();
        // renderTimelineMini removed
      }

      function timeToRatio(ts) {
        const start = timelineWindowStart();
        const end = timelineWindowEnd();
        if (!start || !end) {
          return 1;
        }
        const startMs = start.getTime();
        const endMs = end.getTime();
        if (end <= start) {
          return 1;
        }
        return (ts.getTime() - startMs) / (endMs - startMs);
      }

      function ratioToTimestamp(ratio) {
        const start = timelineWindowStart();
        const end = timelineWindowEnd();
        if (!start || !end) {
          return null;
        }
        const startMs = start.getTime();
        const endMs = end.getTime();
        const clamped = Math.min(1, Math.max(0, ratio));
        return new Date(startMs + (endMs - startMs) * clamped);
      }

      function setScrubberRatio(ratio, updateAria = true) {
        if (!timelineScrubber || !timelineTrack) {
          return;
        }
        const clamped = Math.min(1, Math.max(0, ratio));
        const rect = timelineTrack.getBoundingClientRect();
        const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, rect.width - labelWidth);
        timelineScrubber.style.left = (labelWidth + clamped * plotWidth) + 'px';
        if (updateAria) {
          timelineScrubber.setAttribute('aria-valuenow', Math.round(clamped * 100));
        }
      }

      function handleTimelinePointerDown(event) {
        if (!timelineTrack) {
          return;
        }
        const isShift = !!event.shiftKey;
        if (isShift) {
          timelineState.selecting = true;
          timelineState.dragging = false;
          timelineState.selectionStart = null;
          timelineState.selectionEnd = null;
        } else {
          timelineState.dragging = true;
          timelineState.selecting = false;
        }
        autoScrollPaused = true;
        autoScrollEnabled = false;
        updateAutoScrollUI();
        document.addEventListener('mousemove', handleTimelinePointerMove);
        document.addEventListener('mouseup', handleTimelinePointerUp);
        document.addEventListener('touchmove', handleTimelinePointerMove, { passive: false });
        document.addEventListener('touchend', handleTimelinePointerUp);
        handleTimelinePointerMove(event);
        event.preventDefault();
      }

      function handleTimelinePointerMove(event) {
        if (!timelineTrack) {
          return;
        }
        const clientX = (event.touches && event.touches.length > 0) ? event.touches[0].clientX : event.clientX;
        const rect = timelineTrack.getBoundingClientRect();
        if (!rect.width) {
          return;
        }
        const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, rect.width - labelWidth);
        let ratio = (clientX - rect.left - labelWidth) / plotWidth;
        ratio = Math.min(1, Math.max(0, ratio));
        setScrubberRatio(ratio);
        const targetTs = ratioToTimestamp(ratio);
        if (targetTs) {
          const snapped = snapToMarker(targetTs);
          timelineState.playhead = snapped;
          updateTimelineReadout();
        }
        if (timelineState.selecting && targetTs) {
          if (!timelineState.selectionStart) {
            timelineState.selectionStart = targetTs;
          }
          timelineState.selectionEnd = targetTs;
          scheduleTimelineRender();
          showTimelineTooltipAt(clientX, targetTs);
          return;
        }
        if (timelineState.dragging && targetTs) {
          const snapped = snapToMarker(targetTs);
          setScrubberRatio(timeToRatio(snapped));
          seekTimelineRatio(timeToRatio(snapped), true);
          showTimelineTooltipAt(clientX, snapped);
        }
      }

      function handleTimelinePointerUp() {
        document.removeEventListener('mousemove', handleTimelinePointerMove);
        document.removeEventListener('mouseup', handleTimelinePointerUp);
        document.removeEventListener('touchmove', handleTimelinePointerMove);
        document.removeEventListener('touchend', handleTimelinePointerUp);
        if (timelineState.selecting && timelineState.selectionStart && timelineState.selectionEnd) {
          const a = timelineState.selectionStart;
          const b = timelineState.selectionEnd;
          setTimeRange(new Date(Math.min(a.getTime(), b.getTime())), new Date(Math.max(a.getTime(), b.getTime())));
        }
        timelineState.dragging = false;
        timelineState.selecting = false;
        hideTimelineTooltip();
      }

      function handleTimelineTrackClick(event) {
        if (timelineState.dragging || timelineState.selecting) {
          return;
        }
        const rect = timelineTrack.getBoundingClientRect();
        if (!rect.width) {
          return;
        }
        const clientX = event.clientX;
        const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, rect.width - labelWidth);
        const ratio = Math.min(1, Math.max(0, (clientX - rect.left - labelWidth) / plotWidth));
        const nearest = findNearestTimelineEvent(ratio);
        if (nearest) {
          const evRatio = nearest.ratio != null ? nearest.ratio : timeToRatio(nearest.ts);
          const evX = rect.left + labelWidth + evRatio * plotWidth;
          const diffPx = Math.abs(evX - clientX);
          if (diffPx <= 12 && nearest.type === TIMELINE_EVENT_TYPES.K8S_EVENT) {
            if (focusOnTimelineEvent(nearest)) {
              setScrubberRatio(evRatio);
              return;
            }
          }
        }
        setScrubberRatio(ratio);
        seekTimelineRatio(ratio, true);
      }

      function handleTimelineHover(event) {
        if (!timelineTrack || timelineState.dragging || timelineState.selecting) {
          return;
        }
        const rect = timelineTrack.getBoundingClientRect();
        if (!rect.width) {
          return;
        }
        const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, rect.width - labelWidth);
        const ratio = Math.min(1, Math.max(0, (event.clientX - rect.left - labelWidth) / plotWidth));
        const nearest = findNearestTimelineEvent(ratio);
        if (nearest) {
          showTimelineTooltipForEvent(nearest, event.clientX);
        } else {
          const ts = ratioToTimestamp(ratio);
          if (ts) {
            showTimelineTooltipAt(event.clientX, ts);
          }
        }
      }

      function handleTimelineLeave() {
        if (timelineState.dragging) {
          return;
        }
        hideTimelineTooltip();
      }

      function findNearestTimelineEvent(ratio) {
        if (timelineState.events.length === 0 || ratio == null) {
          return null;
        }
        let best = null;
        let bestDiff = Infinity;
        for (let i = 0; i < timelineState.events.length; i++) {
          const ev = timelineState.events[i];
          const evRatio = timeToRatio(ev.ts);
          const diff = Math.abs(evRatio - ratio);
          if (diff < bestDiff) {
            best = { ...ev, ratio: evRatio };
            bestDiff = diff;
          }
        }
        return best;
      }

      function snapToMarker(targetTs) {
        if (!uiState.snap || !targetTs || timelineState.events.length === 0) {
          return targetTs;
        }
        const viewStart = timelineWindowStart() || timelineState.start;
        const viewEnd = timelineWindowEnd() || timelineState.end;
        if (!viewStart || !viewEnd) {
          return targetTs;
        }
        const spanMs = Math.max(1, viewEnd.getTime() - viewStart.getTime());
        const threshold = Math.max(750, Math.floor(spanMs * 0.01));
        let best = null;
        let bestDiff = Infinity;
        for (let i = 0; i < timelineState.events.length; i++) {
          const ev = timelineState.events[i];
          if (!ev || !ev.ts) continue;
          const diff = Math.abs(ev.ts.getTime() - targetTs.getTime());
          if (diff < bestDiff) {
            best = ev.ts;
            bestDiff = diff;
          }
        }
        if (best && bestDiff <= threshold) {
          return best;
        }
        return targetTs;
      }

      function seekTimelineRatio(ratio, fromUser = false) {
        const targetTs = ratioToTimestamp(ratio);
        if (!targetTs) {
          return;
        }
        scrollFeedToTimestamp(targetTs, fromUser);
      }

      function scrollFeedToTimestamp(targetTs, fromUser) {
        if (!targetTs || entries.length === 0) {
          return;
        }
        let candidate = null;
        for (let i = entries.length - 1; i >= 0; i--) {
          const entry = entries[i];
          if (entry && entry.visible) {
            candidate = entry;
            break;
          }
        }
        if (!candidate) {
          candidate = entries[entries.length - 1];
        }
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (!entry.timestamp) {
            continue;
          }
          if (entry.visible === false) {
            continue;
          }
          if (entry.timestamp >= targetTs) {
            candidate = entry;
            break;
          }
        }
        if (!candidate || !candidate.element) {
          return;
        }
        autoScrollEnabled = false;
        autoScrollPaused = true;
        updateAutoScrollUI();
        candidate.element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        highlightTimelineEntry(candidate);
        if (fromUser && candidate) {
          selectEntry(candidate);
        }
      }

      function highlightTimelineEntry(entry) {
        if (timelineState.highlightedEntry && timelineState.highlightedEntry.element) {
          timelineState.highlightedEntry.element.classList.remove('focused');
        }
        timelineState.highlightedEntry = entry;
        if (entry && entry.element) {
          entry.element.classList.add('focused');
        }
        syncGraphHighlight(entry);
      }

      function showTimelineTooltipAt(clientX, timestamp) {
        if (!timelineTooltip) {
          return;
        }
        revealTimelineTooltip();
        timelineTooltip.textContent = timestamp.toLocaleTimeString();
        positionTimelineTooltip(clientX);
      }

      function showTimelineTooltipForEvent(eventData, clientX) {
        if (!timelineTooltip || !eventData) {
          return;
        }
        const timeLabel = eventData.ts.toLocaleTimeString();
        revealTimelineTooltip();
        timelineTooltip.textContent = timeLabel + ' · ' + eventData.label;
        const rect = timelineTrack.getBoundingClientRect();
        const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
        const plotWidth = Math.max(1, rect.width - labelWidth);
        const x = clientX || (rect.left + labelWidth + eventData.ratio * plotWidth);
        positionTimelineTooltip(x);
      }

      function positionTimelineTooltip(clientX) {
        if (!timelineTooltip || !timelineTrack) {
          return;
        }
        const rect = timelineTrack.getBoundingClientRect();
        if (!rect.width) {
          return;
        }
        const x = Math.min(rect.right - 8, Math.max(rect.left + 8, clientX));
        timelineTooltip.style.left = (x - rect.left) + 'px';
      }

      function hideTimelineTooltip() {
        concealTimelineTooltip();
      }

      function revealTimelineTooltip() {
        if (!timelineTooltip) {
          return;
        }
        window.clearTimeout(timelineTooltipHideTimeout);
        timelineTooltip.hidden = false;
        requestAnimationFrame(() => {
          timelineTooltip.classList.add('is-visible');
        });
      }

      function concealTimelineTooltip() {
        if (!timelineTooltip) {
          return;
        }
        timelineTooltip.classList.remove('is-visible');
        window.clearTimeout(timelineTooltipHideTimeout);
        timelineTooltipHideTimeout = window.setTimeout(() => {
          timelineTooltip.hidden = true;
        }, 170);
      }

      function initTimeline() {
        window.addEventListener('resize', scheduleTimelineRender);
        timelineTrack.addEventListener('mousedown', handleTimelinePointerDown);
        timelineTrack.addEventListener('touchstart', function(event) {
          handleTimelinePointerDown(event);
        }, { passive: false });
        timelineTrack.addEventListener('click', handleTimelineTrackClick);
        timelineTrack.addEventListener('mousemove', handleTimelineHover);
        timelineTrack.addEventListener('mouseleave', handleTimelineLeave);
        timelineTrack.addEventListener('wheel', function(event) {
          if (!event.ctrlKey && !event.metaKey) {
            return;
          }
          event.preventDefault();
          const rect = timelineTrack.getBoundingClientRect();
          const labelWidth = Math.min(rect.width - 60, Math.max(120, timelineLabelWidthPx()));
          const plotWidth = Math.max(1, rect.width - labelWidth);
          const ratio = Math.min(1, Math.max(0, (event.clientX - rect.left - labelWidth) / plotWidth));
          const center = ratioToTimestamp(ratio);
          const factor = event.deltaY < 0 ? 0.6 : 1.6;
          zoomTimeline(factor, center);
        }, { passive: false });
        if (timelineMini) {
          timelineMini.addEventListener('click', (event) => {
            const rect = timelineMini.getBoundingClientRect();
            if (!rect.width || !timelineState.start || !timelineState.end) return;
            const ratio = Math.min(1, Math.max(0, (event.clientX - rect.left) / rect.width));
            const ts = new Date(timelineState.start.getTime() + (timelineState.end.getTime() - timelineState.start.getTime()) * ratio);
            timelineState.playhead = ts;
            const viewStart = timelineWindowStart() || timelineState.start;
            const viewEnd = timelineWindowEnd() || timelineState.end;
            const span = Math.max(2500, viewEnd.getTime() - viewStart.getTime());
            setTimelineView(new Date(ts.getTime() - span / 2), new Date(ts.getTime() + span / 2));
            setScrubberRatio(timeToRatio(ts));
            seekTimelineRatio(timeToRatio(ts), true);
            updateTimelineReadout();
          });
        }
        timelineScrubber.addEventListener('keydown', function(event) {
          const step = (event.shiftKey ? 0.1 : 0.05);
          if (event.key === 'ArrowLeft') {
            const current = Number(timelineScrubber.getAttribute('aria-valuenow') || '100') / 100;
            const next = Math.max(0, current - step);
            setScrubberRatio(next);
            seekTimelineRatio(next, true);
            event.preventDefault();
          } else if (event.key === 'ArrowRight') {
            const current = Number(timelineScrubber.getAttribute('aria-valuenow') || '100') / 100;
            const next = Math.min(1, current + step);
            setScrubberRatio(next);
            seekTimelineRatio(next, true);
            event.preventDefault();
          }
        });
        if (timelineFitBtn) {
          timelineFitBtn.addEventListener('click', () => {
            fitTimelineView();
            setScrubberRatio(1);
            seekTimelineRatio(1, true);
          });
        }
        if (timelineZoomInBtn) {
          timelineZoomInBtn.addEventListener('click', () => zoomTimeline(0.6, timelineState.playhead));
        }
        if (timelineZoomOutBtn) {
          timelineZoomOutBtn.addEventListener('click', () => zoomTimeline(1.6, timelineState.playhead));
        }
        if (timelineSnapBtn) {
          timelineSnapBtn.addEventListener('click', () => {
            uiState.snap = !uiState.snap;
            updateTimelineReadout();
          });
        }
        if (timelineClearSelectionBtn) {
          timelineClearSelectionBtn.addEventListener('click', () => {
            timelineState.selectionStart = null;
            timelineState.selectionEnd = null;
            setTimeRange(null, null);
            scheduleTimelineRender();
          });
        }
        updateTimelineVisibility();
        updateTimelineReadout();
        setScrubberRatio(1, false);
      }

      function focusOnTimelineEvent(eventData) {
        if (!eventData || !eventData.ts) {
          return false;
        }
        const ts = eventData.ts instanceof Date ? eventData.ts : parseTimestamp(eventData.ts);
        if (!ts) {
          return false;
        }
        const meta = eventData.meta || null;
        const ns = meta && (meta.namespace || meta.involvedNamespace) ? String(meta.namespace || meta.involvedNamespace) : '';
        const pod = meta && meta.pod ? String(meta.pod) : '';
        const ds = meta && meta.dataset ? String(meta.dataset) : '';

        if (ds) {
          const block = document.getElementById('datasetFilterBlock');
          if (block && !block.classList.contains('hidden')) {
            selectedDatasets.clear();
            selectedDatasets.add(ds);
            renderDatasetChips();
          }
        }

        if (chipFiltersEnabled && (ns || pod)) {
          selectedNamespaces.clear();
          selectedPods.clear();
          if (ns) {
            selectedNamespaces.add(ns);
          }
          if (pod) {
            selectedPods.add(makePodValue(ns, pod));
          }
          renderNamespaceChips(true);
          renderPodChips(true);
          updateFilterMeta();
        }

        setEventInspector({
          type: meta && meta.type ? meta.type : '',
          reason: meta && meta.reason ? meta.reason : '',
          namespace: ns,
          involvedKind: meta && meta.involvedKind ? meta.involvedKind : '',
          involvedName: meta && meta.involvedName ? meta.involvedName : '',
          involvedNamespace: meta && meta.involvedNamespace ? meta.involvedNamespace : '',
          kind: meta && meta.involvedKind ? meta.involvedKind : '',
          name: meta && meta.involvedName ? meta.involvedName : '',
          pod: meta && meta.pod ? meta.pod : '',
          message: meta && meta.message ? meta.message : '',
          dataset: ds,
        }, ts, ds);

        const start = new Date(ts.getTime() - 30 * 1000);
        const end = new Date(ts.getTime() + 30 * 1000);
        setTimeRange(start, end);
        scrollFeedToTimestamp(ts, true);
        return true;
      }

      function handleGraphSnapshot(snapshot) {
        if (!graphPanel || !snapshot) {
          return;
        }
        const rawNodes = Array.isArray(snapshot.nodes) ? snapshot.nodes : [];
        const visibleNodes = rawNodes
          .filter(node => {
            if (!node || !node.id) {
              return false;
            }
            const label = (node.label || '').trim();
            if (!label) {
              return false;
            }
            if (label.startsWith('[internal')) {
              return false;
            }
            return true;
          })
          .map(node => ({
            id: node.id,
            label: node.label || node.id,
            status: (node.status || (node.cached ? 'cached' : 'pending')).toLowerCase(),
            cached: !!node.cached,
            current: Number(node.current) || 0,
            total: Number(node.total) || 0,
            error: node.error || '',
          }));
        graphState.nodes = visibleNodes;
        graphState.dirty = true;
        updateGraphSummary();
        updateGraphVisibility();
        scheduleGraphRender();
      }

      function updateGraphSummary() {
        if (!graphSummaryChip) {
          return;
        }
        const total = graphState.nodes.length;
        if (!total) {
          graphSummaryChip.textContent = 'Awaiting vertices';
          return;
        }
        let completed = 0;
        let failed = 0;
        graphState.nodes.forEach(node => {
          if (node.status === 'failed') {
            failed += 1;
          } else if (node.status === 'completed' || node.status === 'cached') {
            completed += 1;
          }
        });
        const parts = [total + ' steps'];
        if (completed) {
          parts.push(completed + ' done');
        }
        if (failed) {
          parts.push(failed + ' failed');
        }
        graphSummaryChip.textContent = parts.join(' · ');
      }

      function updateGraphVisibility() {
        if (!graphPanel) {
          return;
        }
        if (graphState.nodes.length === 0) {
          graphPanel.classList.add('hidden');
          graphPanel.setAttribute('aria-hidden', 'true');
        } else {
          graphPanel.classList.remove('hidden');
          graphPanel.removeAttribute('aria-hidden');
        }
      }

      function scheduleGraphRender() {
        if (!graphState.dirty || graphState.pendingRender || graphState.nodes.length === 0) {
          return;
        }
        graphState.pendingRender = true;
        window.requestAnimationFrame(renderGraphList);
      }

      function renderGraphList() {
        graphState.pendingRender = false;
        if (!graphState.dirty || graphState.nodes.length === 0 || !graphNodeList) {
          return;
        }
        graphState.dirty = false;
        graphNodeList.innerHTML = '';
        const nodes = graphState.nodes.slice();
        nodes.sort((a, b) => {
          const order = statusRank(a.status) - statusRank(b.status);
          if (order === 0) {
            return a.label.localeCompare(b.label);
          }
          return order;
        });
        nodes.forEach(node => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'graph-node-pill status-' + (node.status || 'pending');
          pill.dataset.nodeId = node.id;
          pill.textContent = node.label;
          pill.addEventListener('click', () => focusEntryForNode(node));
          graphNodeList.appendChild(pill);
        });
        applyGraphNodeHighlight();
      }

      function statusRank(status) {
        switch (status) {
          case 'failed':
            return 0;
          case 'running':
            return 1;
          case 'cached':
            return 2;
          case 'completed':
            return 3;
          default:
            return 4;
        }
      }

      function focusEntryForNode(node) {
        if (!node || !node.label) {
          return;
        }
        const targetLabel = node.label.toLowerCase();
        let candidate = null;
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (!entry || !entry.data) continue;
          const podLabel = (entry.data.pod || '').toLowerCase();
          if (podLabel === targetLabel) {
            candidate = entry;
            break;
          }
        }
        if (!candidate) {
          return;
        }
        autoScrollEnabled = false;
        autoScrollPaused = true;
        updateAutoScrollUI();
        candidate.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        highlightTimelineEntry(candidate);
      }

      function syncGraphHighlight(entry) {
        if (!entry || !entry.data) {
          graphState.activeNodeId = null;
          applyGraphNodeHighlight();
          return;
        }
        const targetLabel = (entry.data.pod || '').trim().toLowerCase();
        if (!targetLabel) {
          graphState.activeNodeId = null;
          applyGraphNodeHighlight();
          return;
        }
        let matchId = null;
        graphState.nodes.forEach(node => {
          if (!matchId && node.label && node.label.toLowerCase() === targetLabel) {
            matchId = node.id;
          }
        });
        graphState.activeNodeId = matchId;
        applyGraphNodeHighlight();
      }

      function applyGraphNodeHighlight() {
        if (graphSvg) {
          graphSvg.querySelectorAll('.graph-node').forEach(group => {
            const nodeId = group.dataset.nodeId;
            const circle = group.querySelector('circle');
            if (nodeId && nodeId === graphState.activeNodeId) {
              group.classList.add('active');
              if (circle) circle.classList.add('active');
            } else {
              group.classList.remove('active');
              if (circle) circle.classList.remove('active');
            }
          });
        }
        if (graphNodeList) {
          graphNodeList.querySelectorAll('.graph-node-pill').forEach(pill => {
            if (pill.dataset.nodeId === graphState.activeNodeId) {
              pill.classList.add('active');
            } else {
              pill.classList.remove('active');
            }
          });
        }
      }

      function setBuildStatus(state, detailOverride) {
        if (!inlineMetricsEnabled || !buildMetrics.statusEl) {
          return;
        }
        let next = 'building';
        const normalized = (state || '').toLowerCase();
        if (normalized === 'success' || normalized === 'succeeded' || normalized === 'ok') {
          next = 'success';
        } else if (normalized === 'failed' || normalized === 'failure' || normalized === 'error') {
          next = 'failed';
        }
        buildMetrics.status = next;
        const label = next === 'success' ? 'Success' : next === 'failed' ? 'Failed' : 'Building';
        buildMetrics.statusEl.textContent = label;
        buildMetrics.statusEl.classList.remove('status-building', 'status-success', 'status-failed');
        buildMetrics.statusEl.classList.add('status-' + next);
        if (next === 'failed') {
          const detail = detailOverride || buildMetrics.failureDetail || '';
          if (detail) {
            buildMetrics.failureDetail = detail;
            buildMetrics.statusEl.setAttribute('title', detail);
            buildMetrics.statusEl.setAttribute('aria-label', label + ': ' + detail);
          } else {
            buildMetrics.statusEl.removeAttribute('title');
            buildMetrics.statusEl.setAttribute('aria-label', label);
          }
        } else {
          buildMetrics.failureDetail = '';
          buildMetrics.statusEl.removeAttribute('title');
          buildMetrics.statusEl.setAttribute('aria-label', label);
        }
      }

      function captureFailureDetail(line) {
        if (!line) {
          return '';
        }
        const trimmed = line.trim();
        if (trimmed.toLowerCase().startsWith('failed ')) {
          const match = trimmed.match(/^Failed\s+([^:]+)(?::\s*(.+))?/i);
          if (match) {
            const step = (match[1] || '').trim();
            const message = (match[2] || '').trim();
            if (step) {
              return message ? step + ': ' + message : step;
            }
          }
        }
        const summaryMatch = trimmed.match(/Build failed(?: after [^:]+)?:\s*(.+)$/i);
        if (summaryMatch && summaryMatch[1]) {
          return summaryMatch[1].trim();
        }
        return '';
      }

      function startBuildElapsedTimer() {
        if (!inlineMetricsEnabled || buildMetrics.timer || !buildMetrics.startedAt) {
          return;
        }
        buildMetrics.timer = setInterval(() => {
          if (buildMetrics.complete) {
            return;
          }
          renderBuildMetrics();
        }, 1000);
      }

      function stopBuildElapsedTimer() {
        if (buildMetrics.timer) {
          clearInterval(buildMetrics.timer);
          buildMetrics.timer = null;
        }
      }

      function handleHeatmapSummary(summary) {
        if (!summary || !summary.service) {
          return;
        }
        heatmapState.set(summary.service, summary);
        renderHeatmap();
      }

      function renderHeatmap() {
        if (!heatmapPanel || !heatmapGrid) {
          return;
        }
        if (heatmapState.size === 0) {
          heatmapPanel.classList.remove('active');
          heatmapPanel.setAttribute('hidden', 'true');
          heatmapGrid.innerHTML = '';
          if (heatmapSummaryChip) {
            heatmapSummaryChip.textContent = 'Awaiting services';
          }
          return;
        }
        heatmapPanel.classList.add('active');
        heatmapPanel.removeAttribute('hidden');
        if (heatmapSummaryChip) {
          const count = heatmapState.size;
          heatmapSummaryChip.textContent = count + (count === 1 ? ' service' : ' services');
        }
        const rows = Array.from(heatmapState.values());
        rows.sort((a, b) => {
          const order = { fail: 0, warn: 1, pass: 2 };
          const diff = (order[(a && (a.status || '').toLowerCase())] ?? 3) - (order[(b && (b.status || '').toLowerCase())] ?? 3);
          if (diff !== 0) return diff;
          if (a && b && a.service && b.service) {
            return a.service.localeCompare(b.service);
          }
          return 0;
        });
        heatmapGrid.innerHTML = '';
        rows.forEach(summary => {
          heatmapGrid.appendChild(renderHeatmapCard(summary));
        });
      }

      function renderHeatmapCard(summary) {
        const card = document.createElement('article');
        card.className = 'score-card ' + resolveStatusClass(summary && summary.status);
        card.setAttribute('data-service', summary && summary.service ? summary.service : '');
        const head = document.createElement('div');
        head.className = 'score-card-head';
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = summary && summary.service ? summary.service : 'service';
        const badge = document.createElement('span');
        badge.className = 'score-badge';
        badge.textContent = (summary && summary.status ? summary.status : 'pass').toUpperCase();
        head.appendChild(label);
        head.appendChild(badge);
        card.appendChild(head);

        const totalLayers = Number(summary && summary.stepsTotal) || 0;
        const cachedLayers = Number(summary && summary.stepsCached) || 0;
        const cachedPercent = totalLayers > 0 ? Math.round((cachedLayers / totalLayers) * 100) : (summary && summary.cacheHits ? 100 : 0);
        const strong = document.createElement('strong');
        strong.textContent = cachedPercent + '% cached';
        card.appendChild(strong);

        const meta = document.createElement('p');
        meta.className = 'meta';
        meta.textContent = [
          (summary && typeof summary.cacheHits === 'number' ? summary.cacheHits : 0) + ' hits',
          (summary && typeof summary.cacheMisses === 'number' ? summary.cacheMisses : 0) + ' misses',
          (Number(summary && summary.stepsExecuted) || 0) + ' executed',
        ].join(' · ');
        card.appendChild(meta);

        if (summary && Array.isArray(summary.hotspots) && summary.hotspots.length) {
          const list = document.createElement('ul');
          list.className = 'hotspot-list';
          summary.hotspots.forEach(h => {
            if (!h) return;
            const row = document.createElement('li');
            row.className = 'hotspot-row';
            const name = document.createElement('span');
            name.className = 'hotspot-name';
            name.textContent = h.name || 'layer';
            const metaSpan = document.createElement('span');
            metaSpan.className = 'hotspot-meta';
            metaSpan.textContent = formatDuration(h.durationMs);
            row.appendChild(name);
            row.appendChild(metaSpan);
            list.appendChild(row);
          });
          card.appendChild(list);
        }

        const summaryLine = document.createElement('p');
        summaryLine.className = 'summary';
        const durationText = formatDuration(summary && summary.durationMs);
        summaryLine.textContent = 'Duration ' + durationText + ' · ' + (Number(summary && summary.stepsExecuted) || 0) + ' executed / ' + (Number(summary && summary.stepsCached) || 0) + ' cached';
        card.appendChild(summaryLine);
        if (summary && summary.failedStep) {
          const failureLine = document.createElement('p');
          failureLine.className = 'summary failure';
          failureLine.textContent = summary.failedStep + ': ' + (summary.failureMessage || 'failed');
          card.appendChild(failureLine);
        }
        return card;
      }

      function resolveStatusClass(status) {
        const value = (status || '').toLowerCase();
        if (value === 'fail' || value === 'failure' || value === 'error') return 'fail';
        if (value === 'warn' || value === 'warning') return 'warn';
        return 'pass';
      }

      function formatDuration(value) {
        const ms = Number(value);
        if (!Number.isFinite(ms) || ms <= 0) {
          return '—';
        }
        if (ms < 1000) {
          return Math.round(ms) + ' ms';
        }
        const seconds = ms / 1000;
        if (seconds < 60) {
          return seconds >= 10 ? Math.round(seconds) + ' s' : seconds.toFixed(1) + ' s';
        }
        const minutes = Math.floor(seconds / 60);
        const remaining = Math.round(seconds % 60);
        if (minutes >= 60) {
          const hours = Math.floor(minutes / 60);
        const remMinutes = minutes % 60;
          return hours + 'h ' + remMinutes + 'm';
        }
        return minutes + 'm ' + (remaining < 10 ? '0' : '') + remaining + 's';
      }

      function makePodValue(namespace, pod) {
        return encodeURIComponent(namespace || '') + POD_VALUE_SEPARATOR + encodeURIComponent(pod || '');
      }

	      function decodePodValue(value) {
	        const idx = value.indexOf(POD_VALUE_SEPARATOR);
	        const rawNs = idx === -1 ? value : value.slice(0, idx);
	        const rawPod = idx === -1 ? '' : value.slice(idx + POD_VALUE_SEPARATOR.length);
	        return {
	          namespace: decodeURIComponent(rawNs || ''),
	          pod: decodeURIComponent(rawPod || ''),
	        };
	      }

	      function matchesEventSearch(ev, search) {
	        const q = String(search || '').trim().toLowerCase();
	        if (!q) return true;
	        const hay = [
	          ev && ev.reason ? ev.reason : '',
	          ev && ev.message ? ev.message : '',
	          ev && ev.involvedKind ? ev.involvedKind : '',
	          ev && ev.involvedName ? ev.involvedName : '',
	          ev && ev.type ? ev.type : '',
	          ev && ev.namespace ? ev.namespace : (ev && ev.involvedNamespace ? ev.involvedNamespace : ''),
	        ].join(' ').toLowerCase();
	        return hay.includes(q);
	      }

		      function renderEventsPanel() {
		        if (!eventsPanel || !eventsList || !eventsSummaryChip) {
		          return;
		        }
		        const all = Array.isArray(eventsState.items) ? eventsState.items : [];
	        if (!all.length) {
	          eventsPanel.setAttribute('hidden', 'true');
	          return;
	        }
	        const selectedPodsList = Array.from(selectedPods.values());
	        const selectedNamespacesList = Array.from(selectedNamespaces.values());
	        const filtered = [];
	        all.forEach(ev => {
	          if (!ev) return;
	          if (!matchesEventSearch(ev, eventsState.search)) return;
	          const ts = parseTimestamp(ev.ts || ev.lastTimestamp || ev.time);
	          if (timeRange.start && ts && ts < timeRange.start) return;
	          if (timeRange.end && ts && ts > timeRange.end) return;
	          const ns = String(ev.namespace || ev.involvedNamespace || '');
	          if (selectedNamespacesList.length && !selectedNamespaces.has(ns)) {
	            return;
	          }
	          if (selectedPodsList.length) {
	            const kind = String(ev.involvedKind || '');
	            const name = String(ev.involvedName || '');
	            if (kind.toLowerCase() !== 'pod' || !name) {
	              return;
	            }
	            const pv = makePodValue(ns, name);
	            if (!selectedPods.has(pv)) {
	              return;
	            }
		          }
		          filtered.push({ ev, ts });
		        });

		        filtered.sort((a, b) => {
		          const am = a.ts ? a.ts.getTime() : 0;
		          const bm = b.ts ? b.ts.getTime() : 0;
		          if (bm !== am) return bm - am;
		          return 0;
		        });

		        eventsPanel.removeAttribute('hidden');
		        eventsSummaryChip.textContent = filtered.length + ' shown · ' + all.length + ' total';
		        eventsList.innerHTML = '';
		        const shown = filtered.slice(0, 80);
		        shown.forEach(item => {
	          const ev = item.ev;
	          const ts = item.ts || new Date();
	          const row = document.createElement('div');
	          const typ = String(ev.type || '').toLowerCase();
	          row.className = 'event-row ' + (typ === 'warning' ? 'fail' : '');
	          row.tabIndex = 0;

	          const head = document.createElement('div');
	          head.className = 'head';
	          const title = document.createElement('div');
	          title.className = 'title';
	          const parts = [];
	          if (ev.reason) parts.push(String(ev.reason));
	          const obj = (ev.involvedKind && ev.involvedName) ? (String(ev.involvedKind) + '/' + String(ev.involvedName)) : '';
	          if (obj) parts.push(obj);
	          title.textContent = parts.length ? parts.join(' · ') : (ev.type || 'Event');
	          const chip = document.createElement('span');
	          chip.className = 'chip-inline';
	          chip.textContent = formatTick(ts);
		          head.appendChild(title);
		          head.appendChild(chip);

		          const rel = document.createElement('button');
		          rel.type = 'button';
		          rel.className = 'mini-btn';
		          rel.textContent = 'Logs ±30s';
		          rel.title = 'Jump to related logs';
		          rel.addEventListener('click', (evt) => {
		            evt.stopPropagation();
		            setEventInspector(ev, ts, ev.dataset || '');
		            showRelatedLogsWindow();
		          });
		          head.appendChild(rel);

	          const metaLine = document.createElement('p');
	          metaLine.className = 'meta';
	          metaLine.textContent = (ev.message ? String(ev.message) : '').slice(0, 220);

	          row.appendChild(head);
	          row.appendChild(metaLine);

		          const focus = () => {
		            focusOnTimelineEvent({
		              ts,
		              meta: {
	                type: ev.type || '',
	                reason: ev.reason || '',
	                message: ev.message || '',
	                dataset: ev.dataset || '',
	                namespace: ev.namespace || ev.involvedNamespace || '',
	                involvedKind: ev.involvedKind || '',
	                involvedName: ev.involvedName || '',
	                involvedNamespace: ev.involvedNamespace || '',
	                pod: (String(ev.involvedKind || '').toLowerCase() === 'pod') ? (ev.involvedName || '') : '',
	              },
	            });
	          };
	          row.addEventListener('click', focus);
	          row.addEventListener('keydown', (evt) => {
	            if (evt.key === 'Enter' || evt.key === ' ') {
	              evt.preventDefault();
	              focus();
	            }
	          });
	          eventsList.appendChild(row);
	        });
	        if (filtered.length > shown.length) {
	          const more = document.createElement('p');
	          more.className = 'subtle';
	          more.textContent = '… +' + (filtered.length - shown.length) + ' more (refine filters to narrow)';
	          eventsList.appendChild(more);
	        }
	      }

	      function logGroupKeyForData(data) {
	        const ds = (data && data.dataset) ? String(data.dataset) : '';
	        const ns = (data && data.namespace) ? String(data.namespace) : '';
	        const pod = (data && data.pod) ? String(data.pod) : '';
	        const c = (data && data.container) ? String(data.container) : '';
	        return [ds, ns, pod, c].join('|');
	      }

	      function logGroupTitleForData(data) {
	        const ds = (data && data.dataset) ? String(data.dataset) : '';
	        const ns = (data && data.namespace) ? String(data.namespace) : '';
	        const pod = (data && data.pod) ? String(data.pod) : '';
	        const c = (data && data.container) ? String(data.container) : '';
	        const parts = [];
	        if (ds) parts.push(ds.toUpperCase());
	        if (ns || pod) parts.push((ns || '-') + '/' + (pod || '-'));
	        if (c) parts.push('[' + c + ']');
	        return parts.length ? parts.join(' · ') : 'Logs';
	      }

	      function getOrCreateLogGroup(groupKey, title) {
	        if (!feed) {
	          return null;
	        }
	        if (logGroupState.has(groupKey)) {
	          return logGroupState.get(groupKey);
	        }
	        const details = document.createElement('details');
	        details.className = 'log-group';
	        details.open = true;
	        details.dataset.groupKey = groupKey;

	        const summary = document.createElement('summary');
	        const t = document.createElement('span');
	        t.className = 'group-title';
	        t.textContent = title || 'Logs';
	        const count = document.createElement('span');
	        count.className = 'group-count';
	        count.textContent = '0/0';
	        summary.appendChild(t);
	        summary.appendChild(count);
	        details.appendChild(summary);

	        const body = document.createElement('div');
	        body.className = 'group-body';
	        details.appendChild(body);
	        feed.appendChild(details);

	        const record = { key: groupKey, title: title || 'Logs', details, body, countEl: count, total: 0, visible: 0 };
	        logGroupState.set(groupKey, record);
	        return record;
	      }

	      function updateLogGroupUI(group) {
	        if (!group) {
	          return;
	        }
	        if (group.countEl) {
	          group.countEl.textContent = group.visible + '/' + group.total;
	        }
	        if (group.details) {
	          group.details.classList.toggle('hidden', group.visible === 0);
	        }
	      }

	      function severityClassForEntry(entryRecord) {
	        if (!entryRecord || !entryRecord.normalized) {
	          return '';
	        }
	        const line = entryRecord.normalized.line || '';
	        if (/\b(fatal|panic)\b/.test(line)) {
	          return 'level-fail';
	        }
	        if (/\b(error|warn|warning)\b/.test(line)) {
	          return 'level-warn';
	        }
	        return '';
	      }

      function formatNamespaceDisplay(ns) {
        return ns ? ns : '(default)';
      }

      function formatPodDisplay(ns, pod) {
        const podLabel = pod || '(pod)';
        const nsLabel = formatNamespaceDisplay(ns);
        return podLabel + ' · ' + nsLabel;
      }

      function updateEventStats(log) {
        eventStats.lines += 1;
        const namespace = log.namespace || '';
        const podValue = makeEventPodValue(namespace, log.pod || '');
        const nsCount = eventStats.namespaces.get(namespace) || 0;
        eventStats.namespaces.set(namespace, nsCount + 1);
        if (nsCount === 0) {
          eventNamespaceDirty = true;
        }
        const podCount = eventStats.pods.get(podValue) || 0;
        eventStats.pods.set(podValue, podCount + 1);
        if (podCount === 0) {
          eventPodDirty = true;
        }
        maybeRenderEventNamespaceChips();
        maybeRenderEventPodChips();
        updateEventFilterMeta();
      }

      function updateStats(data) {
        if (isCaptureMode) {
          return;
        }
        if (!chipFiltersEnabled) {
          return;
        }
        stats.lines += 1;
        const namespace = data.namespace || '';
        const podValue = makePodValue(namespace, data.pod || '');
        const nsCount = stats.namespaces.get(namespace) || 0;
        stats.namespaces.set(namespace, nsCount + 1);
        if (nsCount === 0) namespaceDirty = true;
        const podCount = stats.pods.get(podValue) || 0;
        stats.pods.set(podValue, podCount + 1);
        if (podCount === 0) podDirty = true;
        maybeRenderNamespaceChips();
        maybeRenderPodChips();
        updateFilterMeta();
      }

      const quickFilters = {
        onlyErrors: false,
        onlyOOMKilled: false,
        onlyRestarts: false,
        onlyNotReady: false,
      };
	      const findState = {
	        term: '',
	        matchCount: 0,
	        current: null,
	      };
	      const lanes = {
	        pod: true,
	        event: true,
	        node: true,
	        system: true,
      };
	      const timeRange = {
	        start: null,
	        end: null,
	      };

	      function setQuickFilter(name, value) {
	        if (!(name in quickFilters)) {
	          return;
	        }
        quickFilters[name] = !!value;
        const btn = document.querySelector('[data-quick-filter="' + name + '"]');
        if (btn) {
          btn.classList.toggle('active', quickFilters[name]);
          btn.setAttribute('aria-pressed', quickFilters[name] ? 'true' : 'false');
        }
      }

      function toggleQuickFilter(name) {
        setQuickFilter(name, !quickFilters[name]);
        applyFilters();
      }

      function setLaneEnabled(name, value) {
        if (!(name in lanes)) {
          return;
        }
        lanes[name] = !!value;
      }

      function renderLaneChips() {
        const block = document.getElementById('laneFilterBlock');
        if (!block) {
          return;
        }
        block.querySelectorAll('.chip-button[data-lane]').forEach(btn => {
          const lane = btn.dataset.lane || '';
          const active = lanes[lane] !== false;
          btn.classList.toggle('active', active);
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
      }

      function laneForEntry(entry) {
        const src = (entry && entry.normalized && entry.normalized.source) ? entry.normalized.source : '';
        if (src === 'event') {
          return 'event';
        }
        if (src === 'node' || src === 'node-log' || src === 'nodelog' || src === 'kubelet' || src === 'containerd') {
          return 'node';
        }
        if (src === 'capture' || src === 'pod' || src === 'logs' || src === 'k8s') {
          return 'pod';
        }
        return 'system';
      }

      function renderDatasetChips() {
        const block = document.getElementById('datasetFilterBlock');
        if (!block) {
          return;
        }
        block.classList.remove('hidden');
        block.setAttribute('aria-hidden', 'false');
        block.querySelectorAll('.chip-button[data-dataset]').forEach(btn => {
          const ds = btn.dataset.dataset || '';
          const active = selectedDatasets.has(ds);
          btn.classList.toggle('active', active);
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
      }

      function enableDatasetFilters() {
        const block = document.getElementById('datasetFilterBlock');
        if (!block) {
          return;
        }
        if (!block.classList.contains('hidden')) {
          return;
        }
        renderDatasetChips();
        const tray = block.querySelector('[aria-label="Dataset filters"]');
        if (tray) {
          tray.addEventListener('click', function(event) {
            const target = event.target.closest('.chip-button');
            if (!target || !target.dataset) {
              return;
            }
            const ds = target.dataset.dataset || '';
            if (!ds) {
              return;
            }
            if (selectedDatasets.has(ds)) {
              selectedDatasets.delete(ds);
            } else {
              selectedDatasets.add(ds);
            }
            renderDatasetChips();
            applyFilters();
          });
        }
      }

	      function isErrorOrWarn(entry) {
	        if (!entry || !entry.normalized) {
	          return false;
	        }
	        const line = entry.normalized.line || '';
	        return /\b(error|fatal|panic|warn|warning)\b/.test(line);
	      }

	      function isError(entry) {
	        if (!entry || !entry.normalized) return false;
	        const line = entry.normalized.line || '';
	        return /\b(error|fatal|panic)\b/.test(line);
	      }

	      function isWarning(entry) {
	        if (!entry || !entry.normalized) return false;
	        const line = entry.normalized.line || '';
	        return /\b(warn|warning)\b/.test(line);
	      }

      function hasRestarts(entry) {
        const ctx = entry && entry.data && entry.data.ktl;
        const podState = ctx && ctx.podState;
        const containers = podState && Array.isArray(podState.containers) ? podState.containers : null;
        if (!containers) {
          return false;
        }
        return containers.some(c => c && typeof c.restartCount === 'number' && c.restartCount > 0);
      }

      function isNotReady(entry) {
        const ctx = entry && entry.data && entry.data.ktl;
        const podState = ctx && ctx.podState;
        if (!podState) {
          return false;
        }
        const conditions = podState.conditions || {};
        const ready = conditions.Ready || conditions.ready;
        if (typeof ready === 'string' && ready.toLowerCase() !== 'true') {
          return true;
        }
        const containers = Array.isArray(podState.containers) ? podState.containers : [];
        return containers.some(c => c && c.ready === false);
      }

      function isOOMKilled(entry) {
        const ctx = entry && entry.data && entry.data.ktl;
        const podState = ctx && ctx.podState;
        const containers = podState && Array.isArray(podState.containers) ? podState.containers : null;
        if (!containers) {
          return false;
        }
        return containers.some(c => {
          const state = (c && c.state ? String(c.state) : '').toLowerCase();
          const last = (c && c.lastState ? String(c.lastState) : '').toLowerCase();
          return state.includes('oomkilled') || last.includes('oomkilled') || last.includes('oom killed');
        });
      }

      function parseTimeInput(value) {
        const raw = (value || '').trim();
        if (!raw) {
          return null;
        }
        const ts = Date.parse(raw);
        if (!Number.isFinite(ts)) {
          return null;
        }
        return new Date(ts);
      }

	      function setTimeRange(start, end) {
	        timeRange.start = start || null;
	        timeRange.end = end || null;
	        if (timeStartInput) {
	          timeStartInput.value = timeRange.start ? timeRange.start.toISOString() : '';
        }
        if (timeEndInput) {
          timeEndInput.value = timeRange.end ? timeRange.end.toISOString() : '';
	        }
	        updateTimelineReadout();
	        applyFilters();
	      }

	      function setTimeRangeNoApply(start, end) {
	        timeRange.start = start || null;
	        timeRange.end = end || null;
	        if (timeStartInput) {
	          timeStartInput.value = timeRange.start ? timeRange.start.toISOString() : '';
	        }
	        if (timeEndInput) {
	          timeEndInput.value = timeRange.end ? timeRange.end.toISOString() : '';
	        }
	        updateTimelineReadout();
	      }

		      function clearAllFocus() {
		        uiState.invert = false;
		        clearSelectedEntries();
	        if (filterSearch) {
	          filterSearch.value = '';
	        }
        if (findSearch) {
          findSearch.value = '';
          findState.term = '';
          findState.current = null;
        }
	        clearSearchChips();
	        Object.keys(quickFilters).forEach(k => setQuickFilter(k, false));
	        if (chipFiltersEnabled) {
	          selectedNamespaces.clear();
	          selectedPods.clear();
	          renderNamespaceChips(true);
	          renderPodChips(true);
	          updateFilterMeta();
	        }
		        setTimeRangeNoApply(null, null);
		        applyFilters();
		      }

		      function resetToDefaults() {
		        setStreamView('both');
		        uiState.invert = false;
		        uiState.snap = false;
		        talkersMode = 'lines';
		        contextRadius = 20;
		        previewSearchText = '';
		        renderSearchPreviewChips();
		        if (timelineSnapBtn) {
		          timelineSnapBtn.classList.toggle('active', false);
		          timelineSnapBtn.setAttribute('aria-pressed', 'false');
		        }
	        if (filterSearch) {
	          filterSearch.value = '';
	        }
	        previewSearchText = '';
	        renderSearchPreviewChips();
	        if (findSearch) {
	          findSearch.value = '';
	          findState.term = '';
	          findState.current = null;
	        }
	        clearSearchChips();
		        Object.keys(quickFilters).forEach(k => setQuickFilter(k, false));
		        Object.keys(lanes).forEach(k => setLaneEnabled(k, true));
		        renderLaneChips();
		        selectedDatasets.clear();
		        selectedDatasets.add('left');
		        selectedDatasets.add('right');
		        renderDatasetChips();
		        if (chipFiltersEnabled) {
		          selectedNamespaces.clear();
		          selectedPods.clear();
		          renderNamespaceChips(true);
		          renderPodChips(true);
		          updateFilterMeta();
		        }
		        clearSelectedEntries();
		        timelineState.viewStart = null;
		        timelineState.viewEnd = null;
		        timelineState.playhead = null;
		        setTimeRangeNoApply(null, null);
	        scheduleTimelineRender();
	        autoScrollEnabled = true;
	        autoScrollPaused = false;
	        updateAutoScrollUI();
	        maybeScrollToBottom(true);
	        applyFilters();
	      }


      function getShareState() {
        const rect = sidebar ? sidebar.getBoundingClientRect() : null;
        return {
          invert: uiState.invert,
          snap: uiState.snap,
          ns: Array.from(selectedNamespaces.values()),
          pods: Array.from(selectedPods.values()),
          datasets: Array.from(selectedDatasets.values()),
          search: Array.from(searchChipState.keys()),
          quick: { ...quickFilters },
          lanes: { ...lanes },
          time: {
            start: timeRange.start ? timeRange.start.toISOString() : '',
            end: timeRange.end ? timeRange.end.toISOString() : '',
          },
          timeline: {
            viewStart: timelineState.viewStart ? timelineState.viewStart.toISOString() : '',
            viewEnd: timelineState.viewEnd ? timelineState.viewEnd.toISOString() : '',
            playhead: timelineState.playhead ? timelineState.playhead.toISOString() : '',
          },
          ui: {
            sidebarCollapsed: document.body.classList.contains('sidebar-collapsed'),
            sidebarWidth: rect && rect.width ? Math.round(rect.width) : 0,
          },
          bookmarks: bookmarksState.items.slice(-50).map(b => {
            if (!b) return null;
            return {
              id: b.id || '',
              ts: b.ts || '',
              label: b.label || '',
              ns: b.ns || '',
              pod: b.pod || '',
              container: b.container || '',
              source: b.source || '',
            };
          }).filter(Boolean),
        };
      }

      function encodeTextToBase64(text) {
        if (!text) {
          return '';
        }
        const bytes = new TextEncoder().encode(text);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
      }

      function decodeBase64ToTextUrlSafe(b64) {
        if (!b64) {
          return '';
        }
        const normalized = b64.replaceAll('-', '+').replaceAll('_', '/');
        const padded = normalized + '==='.slice((normalized.length + 3) % 4);
        const binary = atob(padded);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return new TextDecoder('utf-8').decode(bytes);
      }

      function applyShareState(state) {
        if (!state) {
          return;
        }
        if (typeof state.invert === 'boolean') {
          uiState.invert = state.invert;
        }
        if (typeof state.snap === 'boolean') {
          uiState.snap = state.snap;
        }
        if (chipFiltersEnabled) {
          selectedNamespaces.clear();
          selectedPods.clear();
          if (Array.isArray(state.ns)) {
            state.ns.forEach(ns => selectedNamespaces.add(ns));
          }
          if (Array.isArray(state.pods)) {
            state.pods.forEach(p => selectedPods.add(p));
          }
          renderNamespaceChips(true);
          renderPodChips(true);
          updateFilterMeta();
        }
        clearSearchChips();
        if (Array.isArray(state.search)) {
          state.search.forEach(token => {
            addSearchChip(String(token));
          });
        }
        if (state.quick) {
          Object.keys(quickFilters).forEach(k => setQuickFilter(k, !!state.quick[k]));
        }
        if (state.lanes) {
          Object.keys(lanes).forEach(k => setLaneEnabled(k, !!state.lanes[k]));
          renderLaneChips();
        }
        if (Array.isArray(state.datasets)) {
          selectedDatasets.clear();
          state.datasets.forEach(v => selectedDatasets.add(v));
          renderDatasetChips();
        }
        if (state.time) {
          const start = parseTimeInput(state.time.start);
          const end = parseTimeInput(state.time.end);
          timeRange.start = start;
          timeRange.end = end;
          if (timeStartInput) timeStartInput.value = start ? start.toISOString() : '';
          if (timeEndInput) timeEndInput.value = end ? end.toISOString() : '';
        }

        if (state.timeline) {
          const viewStart = parseTimeInput(state.timeline.viewStart);
          const viewEnd = parseTimeInput(state.timeline.viewEnd);
          if (viewStart && viewEnd) {
            timelineState.viewStart = viewStart;
            timelineState.viewEnd = viewEnd;
          } else {
            timelineState.viewStart = null;
            timelineState.viewEnd = null;
          }
          const play = parseTimeInput(state.timeline.playhead);
          if (play) {
            timelineState.playhead = play;
          }
        }

        if (state.ui && sidebar && !popoutMode) {
          if (state.ui.sidebarWidth && Number.isFinite(state.ui.sidebarWidth)) {
            const px = Math.max(300, Math.min(900, Number(state.ui.sidebarWidth)));
            sidebar.style.flexBasis = px + 'px';
            sidebar.style.width = px + 'px';
          }
          if (state.ui.sidebarCollapsed) {
            document.body.classList.add('sidebar-collapsed');
          } else {
            document.body.classList.remove('sidebar-collapsed');
          }
        }

        if (Array.isArray(state.bookmarks)) {
          bookmarksState.items = state.bookmarks.slice(-200);
          persistBookmarks();
          renderBookmarks();
        }

        updateTimelineReadout();
      }

      function renderDiffList(el, items, limit = 20) {
        if (!el) {
          return;
        }
        el.innerHTML = '';
        const shown = items.slice(0, limit);
        shown.forEach(item => {
          const li = document.createElement('li');
          li.textContent = item;
          el.appendChild(li);
        });
        if (items.length > shown.length) {
          const li = document.createElement('li');
          li.textContent = '… +' + (items.length - shown.length) + ' more';
          el.appendChild(li);
        }
      }

      function summarizePodContext(ctx) {
        if (!ctx || !ctx.podState) {
          return { restarts: 0, notReady: false, owner: '' };
        }
        const podState = ctx.podState;
        const containers = Array.isArray(podState.containers) ? podState.containers : [];
        let restarts = 0;
        let notReady = false;
        containers.forEach(c => {
          if (!c) return;
          if (typeof c.restartCount === 'number') {
            restarts += c.restartCount;
          }
          if (c.ready === false) {
            notReady = true;
          }
        });
        const owners = Array.isArray(ctx.owners) ? ctx.owners : [];
        let owner = '';
        if (owners.length) {
          const last = owners[owners.length - 1];
          owner = (last.kind || '') + '/' + (last.name || '');
          if (last.hash) owner += '@' + last.hash;
          if (last.revision) owner += '#' + last.revision;
        }
        return { restarts, notReady, owner };
      }

      function isOOMKilledState(ctx) {
        const podState = ctx && ctx.podState;
        const containers = podState && Array.isArray(podState.containers) ? podState.containers : null;
        if (!containers) return false;
        return containers.some(c => {
          const state = (c && c.state ? String(c.state) : '').toLowerCase();
          const last = (c && c.lastState ? String(c.lastState) : '').toLowerCase();
          return state.includes('oomkilled') || last.includes('oomkilled') || last.includes('oom killed');
        });
      }

      function markHealth(entryRecord) {
        if (!entryRecord || !entryRecord.data || !entryRecord.timestamp) return;
        const ctx = entryRecord.data.ktl || null;
        if (!ctx || !ctx.podState) return;
        const ns = entryRecord.keys ? String(entryRecord.keys.namespace || '') : '';
        const podValue = entryRecord.keys ? entryRecord.keys.podValue : '';
        const decoded = decodePodValue(podValue);
        const pod = decoded.pod || String(entryRecord.data.pod || '');
        const ts = entryRecord.timestamp;
        if (!podHealthState.start || ts < podHealthState.start) podHealthState.start = ts;
        if (!podHealthState.end || ts > podHealthState.end) podHealthState.end = ts;
        if (!podValue) return;
        let state = podHealthState.byPod.get(podValue);
        if (!state) {
          state = { ns, pod, buckets: Array(podHealthState.buckets).fill('none'), restartsMax: 0, notReady: false, oom: false, lastTs: ts };
          podHealthState.byPod.set(podValue, state);
        }
        state.lastTs = ts;
        const summary = summarizePodContext(ctx);
        state.restartsMax = Math.max(state.restartsMax, summary.restarts || 0);
        state.notReady = state.notReady || !!summary.notReady;
        state.oom = state.oom || isOOMKilledState(ctx);
        podHealthState.dirty = true;
      }

      function bucketIndex(ts) {
        if (!podHealthState.start || !podHealthState.end) return 0;
        const start = podHealthState.start.getTime();
        const end = podHealthState.end.getTime();
        const span = Math.max(1, end - start);
        const ratio = (ts.getTime() - start) / span;
        const idx = Math.floor(Math.max(0, Math.min(0.999999, ratio)) * podHealthState.buckets);
        return Math.max(0, Math.min(podHealthState.buckets - 1, idx));
      }

      function updateHealthBuckets(entryRecord) {
        if (!entryRecord || !entryRecord.timestamp || !entryRecord.keys) return;
        const ctx = entryRecord.data && entryRecord.data.ktl ? entryRecord.data.ktl : null;
        if (!ctx || !ctx.podState) return;
        const key = entryRecord.keys.podValue;
        const state = podHealthState.byPod.get(key);
        if (!state) return;
        const idx = bucketIndex(entryRecord.timestamp);
        let sev = 'ok';
        if (entryRecord.flags && entryRecord.flags.restartBump) sev = 'bad';
        if (entryRecord.flags && entryRecord.flags.notReadyBump) sev = 'bad';
        if (isOOMKilledState(ctx)) sev = 'bad';
        if (sev === 'ok' && isErrorOrWarn(entryRecord)) sev = 'warn';
        const current = state.buckets[idx];
        const rank = v => (v === 'bad' ? 3 : v === 'warn' ? 2 : v === 'ok' ? 1 : 0);
        if (rank(sev) > rank(current)) {
          state.buckets[idx] = sev;
          podHealthState.dirty = true;
        }
      }

      function renderHealthPanel() {
        if (!healthPanel || !healthList) return;
        const pods = Array.from(podHealthState.byPod.values());
        if (pods.length === 0) {
          healthPanel.classList.add('hidden');
          healthPanel.setAttribute('aria-hidden', 'true');
          return;
        }
        healthPanel.classList.remove('hidden');
        healthPanel.removeAttribute('aria-hidden');
        if (healthSummaryChip) {
          healthSummaryChip.textContent = pods.length + ' pods';
        }
        pods.sort((a, b) => {
          const score = p => (p.oom ? 1000 : 0) + (p.notReady ? 200 : 0) + (p.restartsMax || 0);
          return score(b) - score(a);
        });
        const top = pods.slice(0, 12);
        healthList.innerHTML = '';
        top.forEach(p => {
          const row = document.createElement('div');
          row.className = 'health-row';
          const head = document.createElement('div');
          head.className = 'health-head';
          const name = document.createElement('div');
          name.className = 'health-name';
          name.textContent = p.pod + ' · ' + formatNamespaceDisplay(p.ns);
          const meta = document.createElement('div');
          meta.className = 'health-meta';
          const parts = [];
          if (p.restartsMax) parts.push('restarts ' + p.restartsMax);
          if (p.notReady) parts.push('notready');
          if (p.oom) parts.push('oom');
          meta.textContent = parts.length ? parts.join(' · ') : 'ok';
          head.appendChild(name);
          head.appendChild(meta);
          const strip = document.createElement('div');
          strip.className = 'health-strip';
          p.buckets.forEach(v => {
            const seg = document.createElement('div');
            seg.className = 'health-seg' + (v && v !== 'none' ? ' ' + v : '');
            strip.appendChild(seg);
          });
          row.appendChild(head);
          row.appendChild(strip);
          row.addEventListener('click', () => {
            if (chipFiltersEnabled) {
              selectedNamespaces.clear();
              selectedPods.clear();
              if (p.ns) selectedNamespaces.add(p.ns);
              const pv = makePodValue(p.ns, p.pod);
              if (pv) selectedPods.add(pv);
              renderNamespaceChips(true);
              renderPodChips(true);
              updateFilterMeta();
              applyFilters();
            }
          });
          healthList.appendChild(row);
        });
        podHealthState.dirty = false;
      }

      function finalizeDiffPanel() {
        // Enable a diff summary when dataset labels are present in embedded logs.
        if (!diffPanel || entries.length === 0) {
          return;
        }
        const hasDataset = entries.some(e => e && e.keys && e.keys.dataset);
        if (!hasDataset) {
          return;
        }
        const byDataset = new Map([
          ['left', new Map()],
          ['right', new Map()],
        ]);
        entries.forEach(e => {
          const ds = (e.keys && e.keys.dataset) ? e.keys.dataset : '';
          if (!ds || !byDataset.has(ds)) {
            return;
          }
          const perPod = byDataset.get(ds);
          const key = e.keys.podValue;
          const prev = perPod.get(key) || { lines: 0, ctx: null };
          prev.lines += 1;
          if (e.data && e.data.ktl) {
            prev.ctx = e.data.ktl;
          }
          perPod.set(key, prev);
        });
        const leftPods = Array.from(byDataset.get('left').keys());
        const rightPods = Array.from(byDataset.get('right').keys());
        const leftSet = new Set(leftPods);
        const rightSet = new Set(rightPods);
        const onlyLeft = leftPods.filter(p => !rightSet.has(p)).sort();
        const onlyRight = rightPods.filter(p => !leftSet.has(p)).sort();
        const both = leftPods.filter(p => rightSet.has(p)).sort();
        const changed = [];
        both.forEach(podValue => {
          const l = byDataset.get('left').get(podValue);
          const r = byDataset.get('right').get(podValue);
          const ls = summarizePodContext(l && l.ctx);
          const rs = summarizePodContext(r && r.ctx);
          if (ls.restarts !== rs.restarts || ls.notReady !== rs.notReady || ls.owner !== rs.owner) {
            const parts = [];
            if (ls.owner !== rs.owner) {
              parts.push('owner ' + (ls.owner || '-') + ' → ' + (rs.owner || '-'));
            }
            if (ls.restarts !== rs.restarts) {
              parts.push('restarts ' + ls.restarts + ' → ' + rs.restarts);
            }
            if (ls.notReady !== rs.notReady) {
              parts.push('ready ' + (ls.notReady ? 'no' : 'yes') + ' → ' + (rs.notReady ? 'no' : 'yes'));
            }
            changed.push(podValue + ': ' + parts.join(', '));
          }
        });

        if (diffLeftTitle) diffLeftTitle.textContent = 'Only ' + (document.querySelector('[data-dataset=\"left\"]')?.textContent || 'Left');
        if (diffRightTitle) diffRightTitle.textContent = 'Only ' + (document.querySelector('[data-dataset=\"right\"]')?.textContent || 'Right');
        renderDiffList(diffOnlyLeft, onlyLeft.map(v => v.replace(POD_VALUE_SEPARATOR, '/')));
        renderDiffList(diffOnlyRight, onlyRight.map(v => v.replace(POD_VALUE_SEPARATOR, '/')));
        renderDiffList(diffChanged, changed.map(v => v.replace(POD_VALUE_SEPARATOR, '/')), 24);
        if (diffSummaryChip) {
          diffSummaryChip.textContent = onlyLeft.length + ' left-only · ' + onlyRight.length + ' right-only · ' + changed.length + ' changed';
        }
        diffPanel.classList.remove('hidden');
        diffPanel.removeAttribute('aria-hidden');
      }

	      let hashUpdatePending = false;
	      function scheduleHashUpdate() {
	        if (hashUpdatePending) {
	          return;
	        }
	        hashUpdatePending = true;
	        setTimeout(() => {
	          hashUpdatePending = false;
	          updateShareHashNow();
	        }, 150);
	      }

	      function updateShareHashNow() {
	        const encoded = encodeTextToBase64(JSON.stringify(getShareState()));
	        if (!encoded) {
	          return;
	        }
	        const next = 'ktl=' + encoded;
	        if (window.location.hash.replace(/^#/, '') !== next) {
	          window.history.replaceState(null, '', window.location.pathname + window.location.search + '#' + next);
	        }
	      }

	      function copyShareLinkNow() {
	        updateShareHashNow();
	        copyText(window.location.href);
	      }

	      async function uploadCaptureArtifact(file) {
	        if (!file) {
	          return;
	        }
	        if (statusChip) {
	          statusChip.textContent = 'Uploading…';
	        }
	        if (feedEmptySub) {
	          feedEmptySub.textContent = 'Uploading ' + (file.name || 'capture') + '…';
	        }
	        const form = new FormData();
	        form.append('file', file, file.name || 'capture');
	        try {
	          const res = await fetch('/api/capture/upload', { method: 'POST', body: form });
	          if (!res.ok) {
	            const text = await res.text();
	            throw new Error(text || ('upload failed: ' + res.status));
	          }
	          const payload = await res.json();
	          const url = payload && payload.viewerURL ? String(payload.viewerURL) : '';
	          if (!url) {
	            throw new Error('upload succeeded but viewerURL missing');
	          }
	          window.location.href = url;
	        } catch (err) {
	          console.error('capture upload failed', err);
	          if (statusChip) {
	            statusChip.textContent = 'Error';
	          }
	          if (feedEmptySub) {
	            feedEmptySub.textContent = 'Upload failed: ' + String(err && err.message ? err.message : err);
	          }
	        }
	      }

      function renderContextChip(label, obj) {
        if (!contextGrid || !obj) {
          return;
        }
        const card = document.createElement('div');
        card.className = 'context-chip';
        const head = document.createElement('p');
        head.className = 'label';
        head.textContent = label;
        const pre = document.createElement('pre');
        try {
          pre.textContent = JSON.stringify(obj, null, 2);
        } catch (err) {
          pre.textContent = String(obj);
        }
        card.appendChild(head);
        card.appendChild(pre);
        contextGrid.appendChild(card);
      }

      function renderActionChip(entryRecord) {
        if (!contextGrid || !entryRecord || !entryRecord.data) {
          return;
        }
        const data = entryRecord.data;
        const card = document.createElement('div');
        card.className = 'context-chip';
        const head = document.createElement('p');
        head.className = 'label';
        head.textContent = 'Actions';
        const wrap = document.createElement('div');
        wrap.style.display = 'flex';
        wrap.style.flexWrap = 'wrap';
        wrap.style.gap = '0.45rem';
        const b = document.createElement('button');
        b.type = 'button';
        b.className = 'mini-btn primary';
        b.textContent = 'Bookmark';
        b.addEventListener('click', () => addBookmarkFromData(data));
        wrap.appendChild(b);

        const jump = document.createElement('button');
        jump.type = 'button';
        jump.className = 'mini-btn';
        jump.textContent = 'Jump';
        jump.addEventListener('click', () => {
          const ts = parseTimestamp(data.ts || data.timestamp || data.displayTs);
          if (ts) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
            scrollFeedToTimestamp(ts, true);
          }
        });
        wrap.appendChild(jump);

        const openManifest = document.createElement('button');
        openManifest.type = 'button';
        openManifest.className = 'mini-btn';
        openManifest.textContent = 'View manifest';
        openManifest.addEventListener('click', () => {
          if (!manifestPanel || manifestPanel.classList.contains('hidden')) {
            return;
          }
          const ns = String(data.namespace || '');
          const pod = String(data.pod || '');
          if (!ns || !pod) {
            return;
          }
          // Prefer the Pod manifest; fallback to last owner.
          const ds = String(data.dataset || '');
          const podId = manifestKeyId({ kind: 'Pod', namespace: ns, name: pod }, ds);
          let target = manifestState.byKey.get(podId) || null;
          if (!target && data.ktl && Array.isArray(data.ktl.owners) && data.ktl.owners.length) {
            const ownerKey = data.ktl.owners[data.ktl.owners.length - 1];
            const ownerId = manifestKeyId(ownerKey, ds);
            target = manifestState.byKey.get(ownerId) || null;
          }
          if (target) {
            selectManifestResource(target);
            manifestPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        });
        wrap.appendChild(openManifest);

        card.appendChild(head);
        card.appendChild(wrap);
        contextGrid.appendChild(card);
      }

      function clearContextSection(label) {
        if (!contextGrid) return;
        const nodes = Array.from(contextGrid.querySelectorAll('.context-chip'));
        nodes.forEach(node => {
          const head = node.querySelector('.label');
          if (head && (head.textContent || '').trim() === label) {
            node.remove();
          }
        });
      }

      function ownerMatches(entry, kind, name) {
        const owners = entry && entry.data && entry.data.ktl && Array.isArray(entry.data.ktl.owners) ? entry.data.ktl.owners : [];
        if (!owners.length) {
          return false;
        }
        const k = String(kind || '').toLowerCase();
        const n = String(name || '').toLowerCase();
        return owners.some(o => o && String(o.kind || '').toLowerCase() === k && String(o.name || '').toLowerCase() === n);
      }

      function gatherRelatedPods(kind, name, dataset) {
        const pods = new Set();
        const k = String(kind || '').toLowerCase();
        const n = String(name || '').toLowerCase();
        const ds = String(dataset || '');
        if (!k || !n) {
          return pods;
        }
        entries.forEach(entry => {
          if (!entry || !entry.keys) return;
          if (ds && entry.keys.dataset !== ds) return;
          if (ownerMatches(entry, k, n)) {
            pods.add(entry.keys.podValue);
          }
        });
        return pods;
      }

      function computeLikelyCauseSnippets(evEntry) {
        const out = [];
        if (!evEntry || !evEntry.data) {
          return out;
        }
        const ev = evEntry.data.ktl && evEntry.data.ktl.event ? evEntry.data.ktl.event : null;
        if (!ev || !evEntry.timestamp) {
          return out;
        }
        const kind = String(ev.kind || '');
        const name = String(ev.name || '');
        const ns = String(ev.namespace || '');
        const ds = String(evEntry.data.dataset || '');
        const center = evEntry.timestamp;
        const windowMs = 45 * 1000;
        const start = new Date(center.getTime() - windowMs);
        const end = new Date(center.getTime() + windowMs);
        const candidates = [];
        for (let i = 0; i < entries.length; i++) {
          const entry = entries[i];
          if (!entry || !entry.timestamp) continue;
          if (entry.timestamp < start || entry.timestamp > end) continue;
          if (ds && entry.keys && entry.keys.dataset !== ds) continue;
          if (entry.normalized && entry.normalized.source === 'event') continue;

          let match = false;
          if (String(kind).toLowerCase() === 'pod') {
            match = (entry.keys && entry.keys.namespace === ns && entry.data && String(entry.data.pod || '') === name);
          } else {
            match = ownerMatches(entry, kind, name);
          }
          if (!match) continue;
          const severity = (isErrorOrWarn(entry) ? 3 : 0) + (entry.flags && entry.flags.restartBump ? 2 : 0) + (entry.flags && entry.flags.notReadyBump ? 1 : 0);
          const delta = Math.abs(entry.timestamp.getTime() - center.getTime());
          const score = severity * 100000 - delta;
          candidates.push({ entry, score });
        }
        candidates.sort((a, b) => b.score - a.score);
        candidates.slice(0, 8).forEach(item => {
          const e = item.entry;
          const line = (e.data && (e.data.line || e.data.raw)) ? String(e.data.line || e.data.raw) : '';
          out.push({
            ts: e.data.displayTs || e.data.ts || '',
            namespace: e.keys ? e.keys.namespace : '',
            pod: e.data.pod || '',
            container: e.data.container || '',
            line: formatTimelineLabel(line),
          });
        });
        return out;
      }

      function renderLikelyCause(evEntry) {
        clearContextSection('Likely cause');
        const snippets = computeLikelyCauseSnippets(evEntry);
        if (!snippets.length) {
          return;
        }
        renderContextChip('Likely cause', snippets);
      }

      function setEventInspector(payload, ts, dataset) {
        if (!eventInspectorPanel || !eventInspectorBody || !eventInspectorSummary || !eventInspectorChip) {
          return;
        }
        if (!payload) {
          eventInspectorPanel.setAttribute('hidden', 'true');
          return;
        }
        const meta = payload;
        const when = ts instanceof Date ? ts : parseTimestamp(ts);
        const kind = String(meta.kind || meta.involvedKind || '');
        const name = String(meta.name || meta.involvedName || '');
        const ns = String(meta.namespace || meta.involvedNamespace || '');
        const pod = String(meta.pod || '');
        const reason = String(meta.reason || '');
        const typ = String(meta.type || '');
        const msg = String(meta.message || meta.raw || '');
        const headParts = [];
        if (typ) headParts.push(typ);
        if (reason) headParts.push(reason);
        if (kind && name) headParts.push(kind + '/' + name);
        eventInspectorChip.textContent = headParts.join(' · ') || 'Event';
        const summaryParts = [];
        if (when) summaryParts.push(when.toISOString());
        if (ns) summaryParts.push('ns ' + ns);
        if (pod) summaryParts.push('pod ' + pod);
        eventInspectorSummary.textContent = summaryParts.join(' · ') || '—';

        eventInspectorState.ts = when || null;
        eventInspectorState.dataset = String(dataset || meta.dataset || '');
        eventInspectorState.namespace = ns;
        eventInspectorState.pod = pod;
        eventInspectorState.kind = kind;
        eventInspectorState.name = name;
        eventInspectorState.payload = meta;

        const printable = {
          ts: when ? when.toISOString() : '',
          type: typ,
          reason: reason,
          namespace: ns,
          involvedKind: kind,
          involvedName: name,
          pod: pod,
          message: msg,
        };
	        eventInspectorBody.textContent = JSON.stringify(printable, null, 2);
	        eventInspectorPanel.removeAttribute('hidden');
	      }

      function wireEventInspectorButtons() {
        if (eventRelatedLogsBtn) {
          eventRelatedLogsBtn.addEventListener('click', showRelatedLogsWindow);
        }
        if (eventFocusPodsBtn) {
          eventFocusPodsBtn.addEventListener('click', focusPodsForEvent);
        }
        if (eventFocusResourceBtn) {
          eventFocusResourceBtn.addEventListener('click', openResourceForEvent);
        }
        if (eventCloseBtn) {
          eventCloseBtn.addEventListener('click', () => {
            if (eventInspectorPanel) {
              eventInspectorPanel.setAttribute('hidden', 'true');
            }
          });
        }
      }

      function focusPodsForEvent() {
        const ns = String(eventInspectorState.namespace || '');
        const pod = String(eventInspectorState.pod || '');
        const kind = String(eventInspectorState.kind || '');
        const name = String(eventInspectorState.name || '');
        const ds = String(eventInspectorState.dataset || '');
        if (chipFiltersEnabled) {
          selectedNamespaces.clear();
          selectedPods.clear();
          if (ns) {
            selectedNamespaces.add(ns);
          }
          if (ns && pod) {
            selectedPods.add(makePodValue(ns, pod));
          } else if (kind && name) {
            const related = gatherRelatedPods(kind, name, ds);
            if (related.size) {
              Array.from(related).slice(0, 20).forEach(v => selectedPods.add(v));
            }
          }
          renderNamespaceChips(true);
          renderPodChips(true);
          updateFilterMeta();
          applyFilters();
          return;
        }
        if (pod && addSearchChip('pod:' + pod)) {
          applyFilters();
        }
      }

      function openResourceForEvent() {
        if (!manifestPanel || manifestPanel.classList.contains('hidden')) {
          return;
        }
        const ns = String(eventInspectorState.namespace || '');
        const kind = String(eventInspectorState.kind || '');
        const name = String(eventInspectorState.name || '');
        const ds = String(eventInspectorState.dataset || '');
        if (!kind || !name) {
          return;
        }
        const id = manifestKeyId({ kind: kind, namespace: ns, name: name }, ds);
        const target = manifestState.byKey.get(id) || null;
        if (target) {
          selectManifestResource(target);
          manifestPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }

      function showRelatedLogsWindow() {
        const center = eventInspectorState.ts;
        if (!center) {
          return;
        }
        const start = new Date(center.getTime() - 30 * 1000);
        const end = new Date(center.getTime() + 30 * 1000);
        setTimeRange(start, end);
        focusPodsForEvent();
        autoScrollEnabled = false;
        autoScrollPaused = true;
        updateAutoScrollUI();
        scrollFeedToTimestamp(center, true);
      }

      function eventPodKey(dataset, podValue) {
        if (!dataset) {
          return podValue;
        }
        return dataset + POD_VALUE_SEPARATOR + podValue;
      }

      let selectedEntry = null;
      let ktlQuickFiltersEnabled = false;
      function enableKTLQuickFilters() {
        if (ktlQuickFiltersEnabled) {
          return;
        }
        ktlQuickFiltersEnabled = true;
        ['onlyOOMKilled', 'onlyRestarts', 'onlyNotReady'].forEach(name => {
          const btn = document.querySelector('[data-quick-filter="' + name + '"]');
          if (btn) {
            btn.removeAttribute('disabled');
          }
        });
      }
	      function clearSelectedEntries() {
	        selectedEntrySeqs.forEach(seq => {
	          const entry = entryBySeq.get(seq);
	          if (entry && entry.element) {
	            entry.element.classList.remove('selected');
	          }
	        });
	        selectedEntrySeqs.clear();
	        updateCopySelectedButton();
	      }

	      function updateCopySelectedButton() {
	        if (!copySelectedBtn) {
	          return;
	        }
	        const n = selectedEntrySeqs.size;
	        if (!n) {
	          copySelectedBtn.setAttribute('hidden', 'true');
	          copySelectedBtn.setAttribute('aria-hidden', 'true');
	          return;
	        }
	        copySelectedBtn.removeAttribute('hidden');
	        copySelectedBtn.removeAttribute('aria-hidden');
	        copySelectedBtn.textContent = 'Copy selected (' + n + ')';
	      }

	      function setSelectedRangeByIndex(startIdx, endIdx, additive) {
	        if (!additive) {
	          clearSelectedEntries();
	        }
	        const a = Math.max(0, Math.min(startIdx, endIdx));
	        const b = Math.min(entries.length - 1, Math.max(startIdx, endIdx));
	        for (let i = a; i <= b; i++) {
	          const entry = entries[i];
	          if (!entry || !entry.seq) continue;
	          selectedEntrySeqs.add(entry.seq);
	          if (entry.element) {
	            entry.element.classList.add('selected');
	          }
	        }
	        updateCopySelectedButton();
	      }

	      function toggleSelectedEntry(entryRecord, additive) {
	        if (!entryRecord || !entryRecord.seq) {
	          return;
	        }
	        if (!additive) {
	          clearSelectedEntries();
	        }
	        if (selectedEntrySeqs.has(entryRecord.seq)) {
	          selectedEntrySeqs.delete(entryRecord.seq);
	          if (entryRecord.element) entryRecord.element.classList.remove('selected');
	        } else {
	          selectedEntrySeqs.add(entryRecord.seq);
	          if (entryRecord.element) entryRecord.element.classList.add('selected');
	        }
	        updateCopySelectedButton();
	      }

	      function copySelectedLines() {
	        if (!selectedEntrySeqs.size) {
	          return;
	        }
	        const selected = Array.from(selectedEntrySeqs)
	          .map(seq => entryBySeq.get(seq))
	          .filter(Boolean)
	          .sort((a, b) => (a.seq || 0) - (b.seq || 0));
	        const lines = selected.map(entry => {
	          const ts = entry.timestamp ? entry.timestamp.toISOString() : '';
	          const ns = entry.keys && entry.keys.namespace ? String(entry.keys.namespace) : '';
	          const podValue = entry.keys && entry.keys.podValue ? String(entry.keys.podValue) : '';
	          const pod = podValue ? decodePodValue(podValue).pod : '';
	          const c = entry.data && entry.data.container ? String(entry.data.container) : '';
	          const src = entry.data && entry.data.source ? String(entry.data.source) : '';
	          const raw = (entry.data && (entry.data.line || entry.data.raw)) ? String(entry.data.line || entry.data.raw) : '';
	          const left = [ts, ns && pod ? (ns + '/' + pod) : '', c ? ('[' + c + ']') : '', src ? ('{' + src + '}') : '']
	            .filter(Boolean)
	            .join(' ');
	          return (left ? left + ' ' : '') + raw;
	        });
	        copyText(lines.join('\n'));
	      }

	      function handleEntryPointerSelection(evt, entryRecord) {
	        if (!entryRecord) {
	          return false;
	        }
	        const idx = entries.indexOf(entryRecord);
	        const hasIdx = idx >= 0;
	        const additive = !!(evt && (evt.metaKey || evt.ctrlKey));
	        const range = !!(evt && evt.shiftKey);

	        if (range && hasIdx) {
	          const anchor = selectionAnchorIndex == null ? idx : selectionAnchorIndex;
	          setSelectedRangeByIndex(anchor, idx, additive);
	          selectionAnchorIndex = idx;
	          return true;
	        }
	        if (additive) {
	          toggleSelectedEntry(entryRecord, true);
	          selectionAnchorIndex = hasIdx ? idx : null;
	          return true;
	        }
	        // Plain click: focus single entry and clear multi-select.
	        clearSelectedEntries();
	        selectionAnchorIndex = hasIdx ? idx : null;
	        return false;
	      }

	      function selectEntry(entryRecord) {
	        if (!entryRecord) {
	          return;
	        }
	        if (selectedEntry && selectedEntry.element) {
	          selectedEntry.element.classList.remove('focused');
	        }
	        selectedEntry = entryRecord;
	        if (selectedEntry.element) {
	          selectedEntry.element.classList.add('focused');
	        }
	        renderContextLines();
	        if (!contextPanel || !contextGrid || !contextSummary) {
	          return;
	        }
        const data = entryRecord.data || {};
        const ctx = data.ktl || null;
        contextGrid.innerHTML = '';
        if (!ctx) {
          contextPanel.setAttribute('hidden', 'true');
          if (entryRecord.normalized && entryRecord.normalized.source === 'event' && data && data.ktl && data.ktl.event) {
            setEventInspector(data.ktl.event, entryRecord.timestamp, entryRecord.keys ? entryRecord.keys.dataset : '');
          }
          return;
        }
        contextSummary.textContent = (data.displayTs || data.ts || '') + ' · ' + (data.namespace || '-') + '/' + (data.pod || '-') + ' [' + (data.container || '-') + ']';
        renderActionChip(entryRecord);
        renderContextChip('Pod', ctx.podState);
        renderContextChip('Node', ctx.nodeState);
        if (Array.isArray(ctx.owners) && ctx.owners.length) {
          renderContextChip('Owners', ctx.owners);
        }
        if (ctx.event) {
          renderContextChip('Event', ctx.event);
          setEventInspector(ctx.event, entryRecord.timestamp, entryRecord.keys ? entryRecord.keys.dataset : '');
          renderLikelyCause(entryRecord);
          if (chipFiltersEnabled && ctx.event.kind && ctx.event.name) {
            const kind = String(ctx.event.kind || '');
            const name = String(ctx.event.name || '');
            const ds = entryRecord.keys ? String(entryRecord.keys.dataset || '') : '';
            if (kind.toLowerCase() === 'pod') {
              if (ctx.event.namespace) {
                selectedNamespaces.clear();
                selectedNamespaces.add(String(ctx.event.namespace));
              }
              if (ctx.event.namespace && name) {
                selectedPods.clear();
                selectedPods.add(makePodValue(String(ctx.event.namespace), name));
              }
            } else {
              const related = gatherRelatedPods(kind, name, ds);
              if (related.size) {
                selectedPods.clear();
                Array.from(related).slice(0, 20).forEach(v => selectedPods.add(v));
              }
            }
            renderNamespaceChips(true);
            renderPodChips(true);
            updateFilterMeta();
            applyFilters();
          }
        }
        const events = k8sEventsByPod.get(eventPodKey(entryRecord.keys.dataset, entryRecord.keys.podValue)) || [];
        if (events.length) {
          renderContextChip('Events', events.slice(-12));
        }
        contextPanel.removeAttribute('hidden');
      }

      function appendEntry(data) {
        if (data && typeof data.source === 'string' && data.source.toLowerCase() === 'heatmap') {
          const payload = data.raw || data.line || '';
          if (payload) {
            try {
              const parsed = typeof payload === 'string' ? JSON.parse(payload) : payload;
              handleHeatmapSummary(parsed);
            } catch (err) {
              console.warn('heatmap parse error', err);
            }
          }
          return;
        }
        if (data && typeof data.source === 'string' && data.source.toLowerCase() === 'graph') {
          const payload = data.raw || data.line || data.lineAnsi || '';
          if (payload) {
            try {
              const parsed = typeof payload === 'string' ? JSON.parse(payload) : payload;
              handleGraphSnapshot(parsed);
            } catch (err) {
              console.warn('graph parse error', err);
            }
          }
          return;
        }

        if (inlineMetricsEnabled) {
          updateBuildMetrics(data);
        }

        const entry = document.createElement('article');
        entry.className = 'log-entry';
        const meta = document.createElement('div');
        meta.className = 'meta';
        const badge = document.createElement('span');
        badge.className = 'chip-inline';
        badge.textContent = (data.glyph || '●') + ' ' + (data.source || 'pod');
        meta.appendChild(badge);
        if (data.dataset) {
          const ds = document.createElement('span');
          ds.className = 'chip-inline';
          ds.textContent = String(data.dataset).toUpperCase();
          meta.appendChild(ds);
        }
        const tsBtn = document.createElement('button');
        tsBtn.type = 'button';
        tsBtn.className = 'meta-pill';
        tsBtn.textContent = String(data.displayTs || data.ts || '');
        tsBtn.title = 'Jump to this timestamp';
        tsBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const ts = parseTimestamp(data.ts || data.timestamp || data.displayTs);
          if (ts) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
            scrollFeedToTimestamp(ts, true);
          }
        });
        meta.appendChild(tsBtn);

        const sep = document.createElement('span');
        sep.textContent = ' · ';
        meta.appendChild(sep);

        const podBtn = document.createElement('button');
        podBtn.type = 'button';
        podBtn.className = 'meta-pill';
        const nsText = String(data.namespace || '-');
        const podText = String(data.pod || '-');
        podBtn.textContent = nsText + '/' + podText;
        podBtn.title = 'Filter to this pod (Shift-click to add)';
        podBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          if (!chipFiltersEnabled) {
            return;
          }
          const ns = String(data.namespace || '');
          const pod = String(data.pod || '');
          if (!evt.shiftKey) {
            selectedNamespaces.clear();
            selectedPods.clear();
          }
          if (ns) {
            selectedNamespaces.add(ns);
          }
          if (ns && pod) {
            selectedPods.add(makePodValue(ns, pod));
          }
          renderNamespaceChips(true);
          renderPodChips(true);
          updateFilterMeta();
          applyFilters();
        });
        meta.appendChild(podBtn);

        const contSep = document.createElement('span');
        contSep.textContent = ' [';
        meta.appendChild(contSep);

        const contBtn = document.createElement('button');
        contBtn.type = 'button';
        contBtn.className = 'meta-pill';
        contBtn.textContent = String(data.container || '-');
        contBtn.title = 'Add container filter';
        contBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const c = String(data.container || '').trim();
          if (!c) {
            return;
          }
          if (addSearchChip('c:' + c)) {
            applyFilters();
          }
        });
        meta.appendChild(contBtn);

        const contClose = document.createElement('span');
        contClose.textContent = ']';
        meta.appendChild(contClose);

        const actions = document.createElement('div');
        actions.className = 'meta-actions';
        const copyLineBtn = document.createElement('button');
        copyLineBtn.type = 'button';
        copyLineBtn.className = 'mini-btn';
        copyLineBtn.textContent = 'Copy';
        copyLineBtn.title = 'Copy raw line';
        copyLineBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const text = String(data.raw || data.line || '');
          copyText(text);
        });
        actions.appendChild(copyLineBtn);

        const copyJSONBtn = document.createElement('button');
        copyJSONBtn.type = 'button';
        copyJSONBtn.className = 'mini-btn';
        copyJSONBtn.textContent = 'JSON';
        copyJSONBtn.title = 'Copy JSON record';
        copyJSONBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          try {
            copyText(JSON.stringify(data, null, 2));
          } catch (_) {
            copyText(String(data));
          }
        });
        actions.appendChild(copyJSONBtn);

        const copyKubectlBtn = document.createElement('button');
        copyKubectlBtn.type = 'button';
        copyKubectlBtn.className = 'mini-btn';
        copyKubectlBtn.textContent = 'kubectl';
        copyKubectlBtn.title = 'Copy kubectl logs command';
        copyKubectlBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const ns = String(data.namespace || '');
          const pod = String(data.pod || '');
          const c = String(data.container || '');
          const base = ['kubectl', 'logs'];
          if (ns) base.push('-n', ns);
          if (pod) base.push(pod);
          if (c) base.push('-c', c);
          base.push('--since=10m');
          copyText(base.join(' '));
        });
        actions.appendChild(copyKubectlBtn);

        const bookmarkBtn = document.createElement('button');
        bookmarkBtn.type = 'button';
        bookmarkBtn.className = 'mini-btn primary';
        bookmarkBtn.textContent = '☆';
        bookmarkBtn.title = 'Bookmark this line';
        bookmarkBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          addBookmarkFromData(data);
        });
        actions.appendChild(bookmarkBtn);

        meta.appendChild(actions);
        const line = document.createElement('div');
        line.className = 'log-line';
	        const ansiSource = data.lineAnsi || data.raw || '';
	        const fallbackText = data.line || data.raw || '';
	        renderANSIInto(line, ansiSource, fallbackText);
	        entry.appendChild(meta);
	        entry.appendChild(line);

	        const normalized = {
	          namespace: (data.namespace || '').toLowerCase(),
	          pod: (data.pod || '').toLowerCase(),
          container: (data.container || '').toLowerCase(),
          source: (data.source || '').toLowerCase(),
          glyph: (data.glyph || '').toLowerCase(),
	          dataset: (data.dataset || '').toLowerCase(),
	          line: (fallbackText || '').toLowerCase(),
	        };
	        const podValue = makePodValue(data.namespace || '', data.pod || '');
		        const groupKey = logGroupKeyForData(data);
		        const groupTitle = logGroupTitleForData(data);
		        const entryRecord = {
		          seq: ++entrySeq,
		          element: entry,
		          data,
		          timestamp: parseTimestamp(data.ts || data.timestamp) || new Date(),
		          normalized,
	          keys: {
	            namespace: data.namespace || '',
	            podValue,
	            dataset: data.dataset || '',
	            groupKey,
	          },
		          visible: true,
		          flags: {},
		        };
		        entry.dataset.entrySeq = String(entryRecord.seq);
		        entryBySeq.set(entryRecord.seq, entryRecord);
	        const sevClass = severityClassForEntry(entryRecord);
	        if (sevClass) {
	          entry.classList.add(sevClass);
	        }
	        const group = getOrCreateLogGroup(groupKey, groupTitle);
	        if (group && group.body) {
	          group.total += 1;
	          group.body.appendChild(entry);
	          updateLogGroupUI(group);
	        } else if (feed) {
	          feed.appendChild(entry);
	        }
	        if (data && data.ktl) {
	          const key = (entryRecord.keys.dataset || '') + '|' + entryRecord.keys.podValue;
	          const next = summarizePodContext(data.ktl);
	          const prev = podContextCache.get(key) || null;
          if (prev) {
            if (typeof prev.restarts === 'number' && typeof next.restarts === 'number' && next.restarts > prev.restarts) {
              entryRecord.flags.restartBump = true;
            }
            if (prev.notReady === false && next.notReady === true) {
              entryRecord.flags.notReadyBump = true;
            }
          }
          podContextCache.set(key, next);
        }
        entries.push(entryRecord);
        markHealth(entryRecord);
        updateHealthBuckets(entryRecord);
        if (data && data.ktl && data.ktl.podState) {
          enableKTLQuickFilters();
        }
        if (data && data.dataset) {
          enableDatasetFilters();
        }
	        entry.tabIndex = 0;
	        entry.addEventListener('click', (evt) => {
	          if (handleEntryPointerSelection(evt, entryRecord)) {
	            return;
	          }
	          selectEntry(entryRecord);
	        });
	        entry.addEventListener('mousedown', (evt) => {
	          if (!evt || evt.button !== 0 || !evt.shiftKey) {
	            return;
	          }
	          const idx = entries.indexOf(entryRecord);
	          if (idx < 0) {
	            return;
	          }
	          draggingSelection = true;
	          const additive = !!(evt.metaKey || evt.ctrlKey);
	          selectionAnchorIndex = selectionAnchorIndex == null ? idx : selectionAnchorIndex;
	          setSelectedRangeByIndex(selectionAnchorIndex, idx, additive);
	          evt.preventDefault();
	        });
	        entry.addEventListener('mouseenter', (evt) => {
	          if (!draggingSelection) {
	            return;
	          }
	          const idx = entries.indexOf(entryRecord);
	          if (idx < 0 || selectionAnchorIndex == null) {
	            return;
	          }
	          setSelectedRangeByIndex(selectionAnchorIndex, idx, true);
	          evt.preventDefault();
	        });
	        entry.addEventListener('keydown', (evt) => {
	          if (evt.key === 'Enter' || evt.key === ' ') {
	            evt.preventDefault();
	            selectEntry(entryRecord);
	          }
	        });
        recordTimelineSample(data, entryRecord);
        if (podHealthState.dirty) {
          renderHealthPanel();
        }
        if (entries.length > MAX_ENTRIES) {
          trimEntries();
        }
        applyFiltersToEntry(entryRecord);
      }

      function jumpToNext(predicate) {
        if (!predicate || entries.length === 0) {
          return;
        }
        let startIdx = 0;
        if (timelineState.highlightedEntry) {
          const idx = entries.indexOf(timelineState.highlightedEntry);
          if (idx >= 0) {
            startIdx = idx + 1;
          }
        } else if (selectedEntry) {
          const idx = entries.indexOf(selectedEntry);
          if (idx >= 0) {
            startIdx = idx + 1;
          }
        }
        for (let i = startIdx; i < entries.length; i++) {
          const entry = entries[i];
          if (!entry || entry.visible === false) continue;
          if (predicate(entry)) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
            entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            highlightTimelineEntry(entry);
            selectEntry(entry);
            return;
          }
        }
      }

      function jumpToPrev(predicate) {
        if (!predicate || entries.length === 0) {
          return;
        }
        let startIdx = entries.length - 1;
        if (timelineState.highlightedEntry) {
          const idx = entries.indexOf(timelineState.highlightedEntry);
          if (idx >= 0) {
            startIdx = idx - 1;
          }
        } else if (selectedEntry) {
          const idx = entries.indexOf(selectedEntry);
          if (idx >= 0) {
            startIdx = idx - 1;
          }
        }
        for (let i = startIdx; i >= 0; i--) {
          const entry = entries[i];
          if (!entry || entry.visible === false) continue;
          if (predicate(entry)) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            pauseAnchorLabel = '';
            updateAutoScrollUI();
            entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            highlightTimelineEntry(entry);
            selectEntry(entry);
            return;
          }
        }
      }

      function matchesFind(entry) {
        const term = (findState.term || '').trim().toLowerCase();
        if (!term) return false;
        if (!entry || !entry.normalized) return false;
        const line = entry.normalized.line || '';
        return line.includes(term);
      }

	      function updateFindMatches() {
        findState.matchCount = 0;
        const term = (findState.term || '').trim().toLowerCase();
        entries.forEach(entry => {
          if (!entry || entry.visible === false) {
            if (entry && entry.element) entry.element.classList.remove('match');
            if (entry && entry.flags) entry.flags.findMatch = false;
            return;
          }
          const isMatch = term ? matchesFind(entry) : false;
          if (entry.flags) {
            entry.flags.findMatch = isMatch;
          }
          if (entry.element) {
            entry.element.classList.toggle('match', isMatch);
          }
          if (isMatch) {
            findState.matchCount += 1;
          }
        });
		      }

	      function renderSessionStats() {
	        if (!sessionStats || !statLines || !statPods || !statNamespaces || !statErrors || !statWarnings || !statRestarts) {
	          return;
	        }
	        const total = entries.length;
	        const visible = visibleCount;
	        const namespaces = new Set();
	        const pods = new Set();
	        let errors = 0;
	        let warnings = 0;
	        let restarts = 0;
	        entries.forEach(e => {
	          if (!e || e.visible === false) return;
	          if (e.keys && e.keys.namespace) namespaces.add(String(e.keys.namespace));
	          if (e.keys && e.keys.podValue) pods.add(String(e.keys.podValue));
	          if (isError(e)) errors += 1;
	          if (isWarning(e)) warnings += 1;
	          if (e.flags && e.flags.restartBump) restarts += 1;
	        });
	        statLines.textContent = visible + '/' + total;
	        statPods.textContent = String(pods.size);
	        statNamespaces.textContent = String(namespaces.size);
	        statErrors.textContent = String(errors);
	        statWarnings.textContent = String(warnings);
	        statRestarts.textContent = String(restarts);
	        if (jumpFirstErrorBtn) jumpFirstErrorBtn.disabled = errors === 0;
	        if (jumpFirstWarningBtn) jumpFirstWarningBtn.disabled = warnings === 0;
	        if (jumpFirstRestartBtn) jumpFirstRestartBtn.disabled = restarts === 0;
	      }

      function jumpFind(direction) {
        const dir = direction === -1 ? -1 : 1;
        if (!findState.term) {
          return;
        }
        const startFrom = findState.current || timelineState.highlightedEntry || selectedEntry || null;
        let startIdx = 0;
        if (startFrom) {
          const idx = entries.indexOf(startFrom);
          if (idx >= 0) {
            startIdx = idx;
          }
        }
        const n = entries.length;
        for (let step = 1; step <= n; step++) {
          const i = (startIdx + dir * step + n) % n;
          const entry = entries[i];
          if (!entry || entry.visible === false) continue;
          if (entry.flags && entry.flags.findMatch) {
            findState.current = entry;
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
            entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            highlightTimelineEntry(entry);
            selectEntry(entry);
            return;
          }
        }
      }

		      function trimEntries() {
		        while (entries.length > MAX_ENTRIES) {
		          const entry = entries.shift();
		          if (!entry) continue;
		          if (entry.seq) {
		            entryBySeq.delete(entry.seq);
		            if (selectedEntrySeqs.has(entry.seq)) {
		              selectedEntrySeqs.delete(entry.seq);
		            }
		          }
		          if (entry.element && entry.element.parentNode) {
		            entry.element.parentNode.removeChild(entry.element);
		          }
	          const gk = entry.keys ? entry.keys.groupKey : '';
	          if (gk && logGroupState.has(gk)) {
	            const group = logGroupState.get(gk);
	            group.total = Math.max(0, group.total - 1);
	            if (entry.visible) {
	              group.visible = Math.max(0, group.visible - 1);
	            }
	            if (group.total === 0) {
	              if (group.details && group.details.parentNode) {
	                group.details.parentNode.removeChild(group.details);
	              }
	              logGroupState.delete(gk);
	            } else {
	              updateLogGroupUI(group);
	            }
	          }
	          if (entry.visible) {
	            visibleCount = Math.max(0, visibleCount - 1);
	          }
		          if (timelineState.highlightedEntry === entry) {
		            if (entry.element) {
		              entry.element.classList.remove('focused');
		            }
		            timelineState.highlightedEntry = null;
		          }
		        }
		        updateCopySelectedButton();
		      }

	      function jumpToFirst(predicate) {
	        if (!predicate || entries.length === 0) {
	          return;
	        }
	        for (let i = 0; i < entries.length; i++) {
	          const entry = entries[i];
	          if (!entry || entry.visible === false) continue;
	          if (predicate(entry)) {
	            autoScrollEnabled = false;
	            autoScrollPaused = true;
	            pauseAnchorLabel = '';
	            updateAutoScrollUI();
	            entry.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
	            highlightTimelineEntry(entry);
	            selectEntry(entry);
	            return;
	          }
	        }
	      }

	      function matchesFilters(entry, matchersOverride) {
	        if (!entry) return false;
        if (timeRange.start && entry.timestamp && entry.timestamp < timeRange.start) {
          return false;
        }
        if (timeRange.end && entry.timestamp && entry.timestamp > timeRange.end) {
          return false;
        }
        if (entry.keys && entry.keys.dataset) {
          if (selectedDatasets.size && !selectedDatasets.has(entry.keys.dataset)) {
            return false;
          }
        }
        if (chipFiltersEnabled) {
          if (selectedNamespaces.size && !selectedNamespaces.has(entry.keys.namespace)) {
            return false;
          }
          if (selectedPods.size && !selectedPods.has(entry.keys.podValue)) {
            return false;
          }
        }
        if (quickFilters.onlyErrors && !isErrorOrWarn(entry)) {
          return false;
        }
        if (quickFilters.onlyOOMKilled && !isOOMKilled(entry)) {
          return false;
        }
        if (quickFilters.onlyRestarts && !hasRestarts(entry)) {
          return false;
        }
        if (quickFilters.onlyNotReady && !isNotReady(entry)) {
          return false;
        }
        const lane = laneForEntry(entry);
        if (lane && lanes[lane] === false) {
          return false;
        }
	        const matchers = Array.isArray(matchersOverride) ? matchersOverride : getSearchMatchersWithPreview();
	        const base = (!matchers.length) ? true : matchers.every(fn => fn(entry));
	        return uiState.invert ? !base : base;
	      }

      function applyFilters() {
        if (isCaptureMode) {
          const params = buildCaptureQueryParams();
          params.set('limit', '750');
          params.set('direction', 'backward');
          const sig = params.toString();
          // If the server-side query changed, reload capture pages. Otherwise apply client-side
          // filters (quick toggles, lanes, dataset selection, etc.) without refetching.
          if (sig !== captureQuerySig) {
            scheduleCaptureReload();
            renderActiveFiltersBar();
            return;
          }
          const matchers = getSearchMatchersWithPreview();
          logGroupState.forEach(group => {
            group.visible = 0;
          });
          visibleCount = 0;
          entries.forEach(entry => {
            const show = matchesFilters(entry, matchers);
            entry.visible = show;
            if (entry.element) {
              entry.element.classList.toggle('hidden', !show);
            }
            if (show) {
              visibleCount += 1;
              const gk = entry.keys ? entry.keys.groupKey : '';
              if (gk && logGroupState.has(gk)) {
                logGroupState.get(gk).visible += 1;
              }
            }
          });
          logGroupState.forEach(group => updateLogGroupUI(group));
          updateVisibilityStats();
          renderEntities();
          updateFindMatches();
          renderEventsPanel();
          renderActiveFiltersBar();
          renderTopTalkers();
          scheduleTimelineRender();
          scheduleHashUpdate();
          return;
        }
        const matchers = getSearchMatchersWithPreview();
        logGroupState.forEach(group => {
          group.visible = 0;
        });
        visibleCount = 0;
	        entries.forEach(entry => {
	          const show = matchesFilters(entry, matchers);
	          entry.visible = show;
	          entry.element.classList.toggle('hidden', !show);
	          if (show) {
	            visibleCount += 1;
	            const gk = entry.keys ? entry.keys.groupKey : '';
	            if (gk && logGroupState.has(gk)) {
	              logGroupState.get(gk).visible += 1;
	            }
	          }
	        });
	        logGroupState.forEach(group => updateLogGroupUI(group));
		        updateVisibilityStats();
			        renderEntities();
			        updateFindMatches();
			        renderEventsPanel();
			        renderActiveFiltersBar();
			        renderTopTalkers();
			        scheduleTimelineRender();
			        scheduleHashUpdate();
			      }

      function applyFiltersToEntry(entry) {
        if (isCaptureMode) {
          // Capture mode applies filters in bulk after page loads to avoid per-row reflows.
          entry.visible = true;
          if (entry.element) {
            entry.element.classList.remove('hidden');
          }
          return;
		        }
        const show = matchesFilters(entry, getSearchMatchersWithPreview());
        entry.visible = show;
        entry.element.classList.toggle('hidden', !show);
        const gk = entry.keys ? entry.keys.groupKey : '';
        const group = gk && logGroupState.has(gk) ? logGroupState.get(gk) : null;
	        if (show) {
	          visibleCount += 1;
	          if (group) {
	            group.visible += 1;
	          }
	          maybeScrollToBottom(false);
	        }
	        if (group) {
	          updateLogGroupUI(group);
	        }
		        updateVisibilityStats();
		        renderEntities();
			        updateFindMatches();
			        renderEventsPanel();
			        renderActiveFiltersBar();
			        renderTopTalkers();
			        scheduleTimelineRender();
			        scheduleHashUpdate();
		      }

      function updateVisibilityStats() {
        updateFeedEmptyState();
        renderSessionStats();
      }

      function renderActiveFiltersBar() {
        if (!activeFiltersBar || !activeFiltersChips) {
          return;
        }
        const chips = [];
        const add = (label, onClick) => chips.push({ label, onClick });

        if (timeRange.start || timeRange.end) {
          add('window', () => {
            setTimeRangeNoApply(null, null);
            applyFilters();
          });
        }
        if (chipFiltersEnabled && (selectedNamespaces.size || selectedPods.size)) {
          const parts = [];
          if (selectedNamespaces.size) parts.push('ns:' + selectedNamespaces.size);
          if (selectedPods.size) parts.push('pods:' + selectedPods.size);
          add(parts.join(' · '), () => {
            selectedNamespaces.clear();
            selectedPods.clear();
            renderNamespaceChips(true);
            renderPodChips(true);
            updateFilterMeta();
            applyFilters();
          });
        }
        if (searchChipState.size) {
          Array.from(searchChipState.keys()).slice(0, 6).forEach(token => {
            add(token, () => {
              removeSearchChip(String(token || '').toLowerCase());
              applyFilters();
            });
          });
          if (searchChipState.size > 6) {
            add('+' + (searchChipState.size - 6) + ' search', () => {
              clearSearchChips();
              applyFilters();
            });
          }
        }
        const quick = [];
        if (quickFilters.onlyErrors) quick.push('errors');
        if (quickFilters.onlyOOMKilled) quick.push('oom');
        if (quickFilters.onlyRestarts) quick.push('restarts');
        if (quickFilters.onlyNotReady) quick.push('not-ready');
        if (quick.length) {
          add('quick: ' + quick.join(','), () => {
            Object.keys(quickFilters).forEach(k => setQuickFilter(k, false));
            applyFilters();
          });
        }
        const anyLaneOff = Object.keys(lanes).some(k => lanes[k] === false);
        if (anyLaneOff) {
          add('lanes', () => {
            Object.keys(lanes).forEach(k => setLaneEnabled(k, true));
            renderLaneChips();
            applyFilters();
          });
        }
        const hasDatasetFilter = selectedDatasets.size && !(selectedDatasets.has('left') && selectedDatasets.has('right'));
        if (hasDatasetFilter) {
          add('dataset', () => {
            selectedDatasets.clear();
            selectedDatasets.add('left');
            selectedDatasets.add('right');
            renderDatasetChips();
            applyFilters();
          });
        }

        activeFiltersChips.innerHTML = '';
        if (!chips.length) {
          activeFiltersBar.classList.add('hidden');
          activeFiltersBar.setAttribute('aria-hidden', 'true');
          return;
        }
        activeFiltersBar.classList.remove('hidden');
        activeFiltersBar.removeAttribute('aria-hidden');
        chips.forEach(ch => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'active-filter-chip';
          btn.textContent = ch.label;
          btn.title = 'Click to clear';
          btn.addEventListener('click', () => {
            try {
              ch.onClick && ch.onClick();
            } catch (_) {
              // ignore
            }
          });
          activeFiltersChips.appendChild(btn);
        });
      }

      function renderTopTalkers() {
        if (!topTalkersPanel || !topTalkersList) {
          return;
        }
        const counts = new Map(); // key -> {ns,pod,container,lines,errors}
        entries.forEach(entry => {
          if (!entry || entry.visible === false) return;
          if (laneForEntry(entry) !== 'pod') return;
          const ns = String(entry.keys && entry.keys.namespace ? entry.keys.namespace : '');
          const pv = String(entry.keys && entry.keys.podValue ? entry.keys.podValue : '');
          const pod = pv ? decodePodValue(pv).pod : '';
          const container = String(entry.data && entry.data.container ? entry.data.container : '');
          if (!pod) return;
          const key = [ns, pod, container].join('|');
          const cur = counts.get(key) || { ns, pod, container, lines: 0, errors: 0 };
          cur.lines += 1;
          if (isErrorOrWarn(entry)) cur.errors += 1;
          counts.set(key, cur);
        });

        const items = Array.from(counts.values());
        if (!items.length) {
          topTalkersPanel.setAttribute('hidden', 'true');
          return;
        }
        topTalkersPanel.removeAttribute('hidden');
        topTalkersList.innerHTML = '';
        const sorted = items.sort((a, b) => {
          const ka = talkersMode === 'errors' ? a.errors : a.lines;
          const kb = talkersMode === 'errors' ? b.errors : b.lines;
          if (kb !== ka) return kb - ka;
          return (b.lines - a.lines);
        }).slice(0, 12);

        sorted.forEach(item => {
          const row = document.createElement('div');
          row.className = 'talker-row';
          row.tabIndex = 0;
          const left = document.createElement('div');
          left.className = 'left';
          const strong = document.createElement('strong');
          strong.textContent = (item.ns ? item.ns : '(default)') + '/' + item.pod + (item.container ? (' [' + item.container + ']') : '');
          const sub = document.createElement('span');
          sub.textContent = item.lines + ' lines · ' + item.errors + ' err/warn';
          left.appendChild(strong);
          left.appendChild(sub);
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = (talkersMode === 'errors' ? (item.errors + ' ERR') : (item.lines + ' LINES'));
          row.appendChild(left);
          row.appendChild(badge);
          const focus = (evt) => {
            const additive = !!(evt && evt.shiftKey);
            if (chipFiltersEnabled) {
              if (!additive) {
                selectedNamespaces.clear();
                selectedPods.clear();
              }
              if (item.ns) {
                selectedNamespaces.add(item.ns);
              }
              selectedPods.add(makePodValue(item.ns, item.pod));
              renderNamespaceChips(true);
              renderPodChips(true);
              updateFilterMeta();
            }
            if (item.container) {
              if (!additive) {
                clearSearchChips();
              }
              addSearchChip('c:' + item.container);
            }
            applyFilters();
          };
          row.addEventListener('click', focus);
          row.addEventListener('keydown', (evt) => {
            if (evt.key === 'Enter' || evt.key === ' ') {
              evt.preventDefault();
              focus(evt);
            }
          });
          topTalkersList.appendChild(row);
        });
      }

      function renderContextLines() {
        if (!contextLinesPanel || !contextLinesBody || !contextLinesSummary) {
          return;
        }
        if (!selectedEntry) {
          contextLinesPanel.setAttribute('hidden', 'true');
          contextLinesSummary.textContent = 'Select a log line to view context.';
          contextLinesBody.textContent = '';
          return;
        }
        const idx = entries.indexOf(selectedEntry);
        if (idx < 0) {
          contextLinesPanel.setAttribute('hidden', 'true');
          return;
        }
        const gk = selectedEntry.keys ? selectedEntry.keys.groupKey : '';
        if (!gk) {
          contextLinesPanel.setAttribute('hidden', 'true');
          return;
        }
        const ns = String(selectedEntry.keys && selectedEntry.keys.namespace ? selectedEntry.keys.namespace : '');
        const pv = String(selectedEntry.keys && selectedEntry.keys.podValue ? selectedEntry.keys.podValue : '');
        const pod = pv ? decodePodValue(pv).pod : '';
        const container = String(selectedEntry.data && selectedEntry.data.container ? selectedEntry.data.container : '');
        const label = (ns ? ns : '(default)') + '/' + (pod || '(pod)') + (container ? (' [' + container + ']') : '');

        const before = [];
        const after = [];
        for (let i = idx - 1; i >= 0 && before.length < contextRadius; i--) {
          const e = entries[i];
          if (!e || !e.keys || e.keys.groupKey !== gk) continue;
          before.push(e);
        }
        for (let i = idx + 1; i < entries.length && after.length < contextRadius; i++) {
          const e = entries[i];
          if (!e || !e.keys || e.keys.groupKey !== gk) continue;
          after.push(e);
        }
        before.reverse();

        const fmt = (e) => {
          const ts = e.timestamp ? e.timestamp.toISOString() : '';
          const raw = (e.data && (e.data.line || e.data.raw)) ? String(e.data.line || e.data.raw) : '';
          return (ts ? ts + ' ' : '') + raw;
        };
        const lines = before.map(fmt).concat(['—'.repeat(12)]).concat([fmt(selectedEntry)]).concat(['—'.repeat(12)]).concat(after.map(fmt));
        contextLinesSummary.textContent = label + ' · ' + before.length + ' before · ' + after.length + ' after';
        contextLinesBody.textContent = lines.join('\n');
        contextLinesPanel.removeAttribute('hidden');
      }

      function handleFeedScroll() {
        if (!feed) {
          return;
        }
        if (isCaptureMode) {
          if (isNearTop() && captureHasOlder && !captureLoading) {
            loadCaptureLogsPage(false, 'older').catch(() => {});
          }
          return;
        }
        if (!isNearBottom()) {
          if (autoScrollEnabled) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
          }
          return;
        }
        if (!autoScrollEnabled) {
          autoScrollEnabled = true;
          autoScrollPaused = false;
          updateAutoScrollUI();
        }
      }

	      function maybeScrollToBottom(force) {
	        if (!feed) {
	          return;
	        }
	        if (force || autoScrollEnabled) {
	          feed.scrollTop = feed.scrollHeight;
	        }
	      }

	      function latestVisibleTimestamp() {
	        for (let i = entries.length - 1; i >= 0; i--) {
	          const e = entries[i];
	          if (!e || e.visible === false) continue;
	          if (e.timestamp) return e.timestamp;
	        }
	        return null;
	      }

	      function isNearBottom() {
	        if (!feed) {
	          return true;
	        }
	        const threshold = 120;
	        const remaining = feed.scrollHeight - feed.clientHeight - feed.scrollTop;
	        return remaining <= threshold;
	      }

	      function computePauseAnchorTimestamp() {
	        if (timelineState && timelineState.playhead) {
	          return timelineState.playhead;
	        }
	        if (timelineState && timelineState.highlightedEntry && timelineState.highlightedEntry.timestamp) {
	          return timelineState.highlightedEntry.timestamp;
	        }
	        if (selectedEntry && selectedEntry.timestamp) {
	          return selectedEntry.timestamp;
	        }
	        for (let i = entries.length - 1; i >= 0; i--) {
	          const e = entries[i];
	          if (!e || e.visible === false) continue;
	          if (e.timestamp) return e.timestamp;
	        }
	        return null;
	      }

	      function formatPauseAnchor(ts) {
	        if (!ts) {
	          return '—';
	        }
	        try {
	          return ts.toISOString().slice(0, 19) + 'Z';
	        } catch (_) {
	          return String(ts);
	        }
	      }

		      function updateAutoScrollUI() {
		        if (resumeAutoScrollBtn) {
		          resumeAutoScrollBtn.classList.toggle('hidden', !autoScrollPaused);
		        }
		        if (feedLiveBadge) {
		          const latest = latestVisibleTimestamp();
		          if (autoScrollPaused) {
		            if (!pauseAnchorLabel) {
		              pauseAnchorLabel = formatPauseAnchor(computePauseAnchorTimestamp());
		            }
		            if (!pauseAnchorTimestamp) {
		              pauseAnchorTimestamp = computePauseAnchorTimestamp();
		            }
		            if (pauseSeqAtStart === 0) {
		              pauseSeqAtStart = entrySeq;
		            }
		            const behindLines = Math.max(0, entrySeq - pauseSeqAtStart);
		            let behindTime = '';
		            if (latest && pauseAnchorTimestamp) {
		              const diffMs = Math.max(0, latest.getTime() - pauseAnchorTimestamp.getTime());
		              if (diffMs >= 1000) {
		                const s = Math.round(diffMs / 1000);
		                const mins = Math.floor(s / 60);
		                const secs = s % 60;
		                behindTime = mins ? (mins + 'm' + String(secs).padStart(2, '0') + 's') : (secs + 's');
		              }
		            }
		            const parts = ['Paused'];
		            if (behindTime) parts.push(behindTime);
		            if (behindLines) parts.push(behindLines + ' lines');
		            feedLiveBadge.textContent = parts.join(' · ');
		            feedLiveBadge.classList.toggle('paused', true);
		            feedLiveBadge.classList.toggle('hidden', false);
		          } else {
		            feedLiveBadge.textContent = 'Live';
		            feedLiveBadge.classList.toggle('paused', false);
		            feedLiveBadge.classList.toggle('hidden', false);
		            pauseSeqAtStart = 0;
		            pauseAnchorTimestamp = null;
		          }
		        }
		        if (autoScrollPaused) {
		          if (!pauseAnchorLabel) {
		            pauseAnchorLabel = formatPauseAnchor(computePauseAnchorTimestamp());
		          }
	          if (resumeAutoScrollTime) {
	            resumeAutoScrollTime.textContent = pauseAnchorLabel;
	          }
	        } else {
	          pauseAnchorLabel = '';
	          if (resumeAutoScrollTime) {
	            resumeAutoScrollTime.textContent = '—';
	          }
	        }
	      }

	      function updateFeedEmptyState() {
	        if (!feedEmpty || !feedEmptyTitle || !feedEmptySub) {
	          return;
	        }
	        const status = statusChip ? String(statusChip.textContent || '') : '';
	        const isLive = status === 'Live';
	        const captureMode = !!(isCaptureMode || (document.body && document.body.dataset && document.body.dataset.captureId));
	        const hasAny = entries.length > 0;
	        const hasMatches = visibleCount > 0;

	        if (!hasAny) {
	          feedEmpty.classList.remove('hidden');
	          if (captureMode) {
	            feedEmptyTitle.textContent = 'Loading capture…';
	            feedEmptySub.textContent = 'Fetching logs and events from the capture SQLite database.';
	          } else {
	            feedEmptyTitle.textContent = isLive ? 'Waiting for logs…' : (status || 'Connecting…');
	            feedEmptySub.textContent = isLive ? 'The stream is live; logs will appear as they arrive.' : 'Connecting to the log stream.';
	          }
	          if (feedEmptyActions) {
	            feedEmptyActions.classList.remove('hidden');
	          }
	          if (captureUploadChooseBtn) {
	            captureUploadChooseBtn.classList.toggle('hidden', captureMode);
	          }
	          return;
	        }

	        if (hasMatches) {
	          feedEmpty.classList.add('hidden');
	          return;
	        }

	        feedEmpty.classList.remove('hidden');
	        feedEmptyTitle.textContent = 'No lines match your filters';
	        const active = [];
	        if (timeRange.start || timeRange.end) active.push('window');
	        if (chipFiltersEnabled && (selectedNamespaces.size || selectedPods.size)) active.push('ns/pod');
	        if (searchChipState.size || (previewSearchText && previewSearchText.trim())) active.push('search');
	        if (quickFilters.onlyErrors || quickFilters.onlyOOMKilled || quickFilters.onlyRestarts || quickFilters.onlyNotReady) active.push('quick');
	        feedEmptySub.textContent = active.length
	          ? ('Active: ' + active.join(' · ') + '. Try clearing filters.')
	          : 'Try clearing filters.';
	        if (feedEmptyActions) {
	          feedEmptyActions.classList.remove('hidden');
	        }
	      }

      function buildSearchToken(raw) {
        if (!raw) return null;
        let text = raw.trim();
        if (!text) return null;
        let negate = false;
        if (text.startsWith('!')) {
          negate = true;
          text = text.slice(1);
        }
        let prefix = '';
        let value = text;
        const colonIndex = text.indexOf(':');
        if (colonIndex > 0) {
          const potential = text.slice(0, colonIndex).toLowerCase();
          if (SEARCH_PREFIXES.has(potential)) {
            prefix = potential;
            value = text.slice(colonIndex + 1);
          }
        }
        if (value.startsWith('"') && value.endsWith('"') && value.length > 1) {
          value = value.slice(1, -1);
        }
        value = value.toLowerCase();
        if (!value) return null;
        let matcher;
        switch (prefix) {
          case 'ns':
          case 'namespace':
            matcher = entry => entry.normalized.namespace.includes(value);
            break;
          case 'pod':
            matcher = entry => entry.normalized.pod.includes(value);
            break;
          case 'c':
          case 'container':
            matcher = entry => entry.normalized.container.includes(value);
            break;
          case 'src':
          case 'source':
          case 'glyph':
            matcher = entry => entry.normalized.source.includes(value) || entry.normalized.glyph.includes(value);
            break;
          default:
            matcher = entry => entry.normalized.line.includes(value);
            break;
        }
        if (negate) {
          const baseMatcher = matcher;
          return entry => !baseMatcher(entry);
        }
        return matcher;
      }

	      function handleSearchKey(event) {
	        if (event.key === 'Enter') {
	          event.preventDefault();
	          queueSearchChips(filterSearch.value);
	          previewSearchText = '';
	          renderSearchPreviewChips();
	          return;
	        }
	        if (event.key === 'Escape') {
	          event.preventDefault();
	          previewSearchText = '';
	          filterSearch.value = '';
	          scheduleApplyFilters();
	        }
	      }

	      function queueSearchChips(input) {
	        const tokens = tokenizeInput(input);
	        if (!tokens.length) {
	          return;
	        }
	        let added = false;
	        tokens.forEach(token => {
	          if (addSearchChip(token)) {
	            added = true;
	          }
	        });
	        filterSearch.value = '';
	        previewSearchText = '';
	        renderSearchPreviewChips();
	        if (added) {
	          applyFilters();
	        }
	      }

      function tokenizeInput(input) {
        if (!input) return [];
        return (input.match(/(?:".*?"|\S+)/g) || [])
          .map(part => part.replace(/^"(.*)"$/, '$1').trim())
          .filter(Boolean);
      }

      function addSearchChip(raw) {
        const matcher = buildSearchToken(raw);
        if (!matcher || !searchChipTray) {
          return false;
        }
        const key = raw.toLowerCase();
        if (searchChipState.has(key)) {
          return false;
        }
        const chip = document.createElement('button');
        chip.type = 'button';
        chip.className = 'chip-button';
        chip.dataset.searchValue = key;
        chip.textContent = raw;
        chip.setAttribute('aria-label', 'Remove filter ' + raw);
        searchChipTray.appendChild(chip);
        searchChipState.set(key, { matcher, element: chip });
        return true;
      }

      function handleSearchChipClick(event) {
        const target = event.target.closest('[data-search-value]');
        if (!target) {
          return;
        }
        removeSearchChip(target.dataset.searchValue);
      }

      function removeSearchChip(key) {
        if (!key || !searchChipState.has(key)) {
          return;
        }
        const entry = searchChipState.get(key);
        if (entry && entry.element && entry.element.parentNode) {
          entry.element.parentNode.removeChild(entry.element);
        }
        searchChipState.delete(key);
        applyFilters();
      }

      function clearSearchChips() {
        if (!searchChipTray) {
          return;
        }
        searchChipTray.innerHTML = '';
        searchChipState.clear();
      }

	      function getSearchMatchers() {
	        if (!searchChipState.size) {
	          return [];
	        }
	        return Array.from(searchChipState.values()).map(item => item.matcher);
	      }

	      function getSearchMatchersWithPreview() {
	        const base = getSearchMatchers();
	        const preview = String(previewSearchText || '').trim();
	        if (!preview) {
	          return base;
	        }
	        const tokens = tokenizeInput(preview);
	        const matchers = tokens.map(t => buildSearchToken(t)).filter(Boolean);
	        if (!matchers.length) {
	          return base;
	        }
	        return base.concat(matchers);
	      }

	      function renderSearchPreviewChips() {
	        if (!searchPreviewTray) {
	          return;
	        }
	        const preview = String(previewSearchText || '').trim();
	        if (!preview) {
	          searchPreviewTray.innerHTML = '';
	          searchPreviewTray.classList.add('hidden');
	          return;
	        }
	        const tokens = tokenizeInput(preview);
	        if (!tokens.length) {
	          searchPreviewTray.innerHTML = '';
	          searchPreviewTray.classList.add('hidden');
	          return;
	        }
	        searchPreviewTray.innerHTML = '';
	        tokens.slice(0, 10).forEach(token => {
	          const el = document.createElement('span');
	          el.className = 'chip-button preview-chip';
	          el.textContent = token;
	          el.setAttribute('aria-hidden', 'true');
	          searchPreviewTray.appendChild(el);
	        });
	        if (tokens.length > 10) {
	          const more = document.createElement('span');
	          more.className = 'chip-button preview-chip';
	          more.textContent = '+' + (tokens.length - 10) + ' more';
	          more.setAttribute('aria-hidden', 'true');
	          searchPreviewTray.appendChild(more);
	        }
	        searchPreviewTray.classList.remove('hidden');
	      }

	      function scheduleApplyFilters() {
	        if (applyFiltersTimer) {
	          clearTimeout(applyFiltersTimer);
	        }
	        renderSearchPreviewChips();
	        applyFiltersTimer = setTimeout(() => {
	          applyFiltersTimer = null;
	          applyFilters();
	        }, 140);
	      }

      function updateFilterMeta() {
        if (!chipFiltersEnabled || !namespaceMeta || !podMeta) {
          return;
        }
        const nsTotal = isCaptureMode ? ((captureFacets && Array.isArray(captureFacets.namespaces)) ? captureFacets.namespaces.length : 0) : stats.namespaces.size;
        const podTotal = isCaptureMode ? ((captureFacets && Array.isArray(captureFacets.pods)) ? captureFacets.pods.length : 0) : stats.pods.size;
        const nsBase = nsTotal.toLocaleString() + ' ACTIVE';
        namespaceMeta.textContent = selectedNamespaces.size ? (selectedNamespaces.size + ' SELECTED') : nsBase;
        const podBase = podTotal.toLocaleString() + ' ACTIVE';
        podMeta.textContent = selectedPods.size ? (selectedPods.size + ' SELECTED') : podBase;
      }

      function renderEntities() {
        if (!entitiesPanel || !entitiesGrid || !entitiesSummary) {
          return;
        }
        if (isCaptureMode) {
          entitiesPanel.setAttribute('hidden', 'true');
          return;
        }
        if (!entries.length) {
          entitiesPanel.setAttribute('hidden', 'true');
          return;
        }
        const podCounts = new Map();
        const containerCounts = new Map();
        const nodeCounts = new Map();
        let visible = 0;
        entries.forEach(entry => {
          if (!entry || entry.visible === false) return;
          visible += 1;
          const pv = entry.keys ? String(entry.keys.podValue || '') : '';
          if (pv) {
            podCounts.set(pv, (podCounts.get(pv) || 0) + 1);
          }
          const c = entry.data ? String(entry.data.container || '') : '';
          if (pv && c) {
            const key = pv + '|' + c;
            containerCounts.set(key, (containerCounts.get(key) || 0) + 1);
          }
          const node = entry.data && entry.data.ktl && entry.data.ktl.nodeState && entry.data.ktl.nodeState.name ? String(entry.data.ktl.nodeState.name) : '';
          if (node) {
            nodeCounts.set(node, (nodeCounts.get(node) || 0) + 1);
          }
        });
        if (!visible) {
          entitiesPanel.setAttribute('hidden', 'true');
          return;
        }
        entitiesPanel.removeAttribute('hidden');
        entitiesSummary.textContent = visible.toLocaleString() + ' of ' + stats.lines.toLocaleString();
        entitiesGrid.innerHTML = '';

        const makeBlock = (title, items, renderPill) => {
          const block = document.createElement('div');
          block.className = 'entity-block';
          const h = document.createElement('h3');
          const left = document.createElement('span');
          left.textContent = title;
          const right = document.createElement('span');
          right.textContent = items.length ? (items.length + ' shown') : '—';
          h.appendChild(left);
          h.appendChild(right);
          block.appendChild(h);
          const list = document.createElement('div');
          list.className = 'entity-list';
          items.forEach(item => {
            const pill = renderPill(item);
            if (pill) list.appendChild(pill);
          });
          block.appendChild(list);
          return block;
        };

        const podItems = Array.from(podCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 14).map(([podValue, count]) => {
          const detail = decodePodValue(podValue);
          const cacheKey = (detail && detail.namespace) ? makePodValue(detail.namespace, detail.pod) : podValue;
          const ctx = podContextCache.get((selectedDatasets.size === 1 ? Array.from(selectedDatasets)[0] : '') + '|' + cacheKey) || podContextCache.get('|'+cacheKey) || null;
          return { podValue, namespace: detail.namespace, pod: detail.pod, count, ctx };
        });
        const podBlock = makeBlock('Pods', podItems, item => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'entity-pill';
          const label = formatPodDisplay(item.namespace, item.pod) + ' (' + item.count + ')';
          pill.textContent = label;
          if (item.ctx) {
            if (item.ctx.notReady) pill.classList.add('badge-warn');
            if (typeof item.ctx.restarts === 'number' && item.ctx.restarts > 0) pill.classList.add('badge-fail');
          }
          pill.addEventListener('click', (evt) => {
            const ns = String(item.namespace || '');
            const pod = String(item.pod || '');
            if (chipFiltersEnabled) {
              if (!evt.shiftKey) {
                selectedNamespaces.clear();
                selectedPods.clear();
              }
              if (evt.altKey) {
                // Exclude with a search token to keep chip UX simple.
                if (pod) {
                  if (addSearchChip('!pod:' + pod)) {
                    applyFilters();
                  }
                }
                return;
              }
              if (ns) selectedNamespaces.add(ns);
              if (ns && pod) selectedPods.add(makePodValue(ns, pod));
              renderNamespaceChips(true);
              renderPodChips(true);
              updateFilterMeta();
              applyFilters();
              return;
            }
            const token = (evt.altKey ? '!pod:' : 'pod:') + pod;
            if (pod && addSearchChip(token)) {
              applyFilters();
            }
          });
          return pill;
        });

        const containerItems = Array.from(containerCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 14).map(([key, count]) => {
          const parts = key.split('|');
          const detail = decodePodValue(parts[0] || '');
          return { namespace: detail.namespace, pod: detail.pod, container: parts[1] || '', count };
        });
        const contBlock = makeBlock('Containers', containerItems, item => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'entity-pill';
          pill.textContent = (item.container || '-') + ' (' + item.count + ')';
          pill.addEventListener('click', (evt) => {
            const c = String(item.container || '').trim();
            if (!c) return;
            const token = (evt.altKey ? '!c:' : 'c:') + c;
            if (addSearchChip(token)) {
              applyFilters();
            }
          });
          return pill;
        });

        const nodeItems = Array.from(nodeCounts.entries()).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([name, count]) => ({ name, count }));
        const nodeBlock = makeBlock('Nodes', nodeItems, item => {
          const pill = document.createElement('button');
          pill.type = 'button';
          pill.className = 'entity-pill';
          pill.textContent = item.name + ' (' + item.count + ')';
          pill.addEventListener('click', (evt) => {
            const n = String(item.name || '').trim();
            if (!n) return;
            // No dedicated node filter token yet; best effort search.
            const token = (evt.altKey ? '!' : '') + '"' + n + '"';
            if (addSearchChip(token)) {
              applyFilters();
            }
          });
          return pill;
        });

        entitiesGrid.appendChild(podBlock);
        entitiesGrid.appendChild(contBlock);
        if (nodeItems.length) {
          entitiesGrid.appendChild(nodeBlock);
        }
      }

      function maybeRenderNamespaceChips() {
        if (!chipFiltersEnabled) {
          return;
        }
        renderNamespaceChips(false);
      }

      function maybeRenderPodChips() {
        if (!chipFiltersEnabled) {
          return;
        }
        renderPodChips(false);
      }

      function renderNamespaceChips(force) {
        if (!chipFiltersEnabled || !namespaceFilters) {
          return;
        }
        if (isCaptureMode) {
          namespaceFilters.innerHTML = '';
          const list = (captureFacets && Array.isArray(captureFacets.namespaces)) ? captureFacets.namespaces : [];
          if (!list.length) {
            const p = document.createElement('p');
            p.className = 'placeholder';
            p.textContent = 'No namespaces';
            namespaceFilters.appendChild(p);
            return;
          }
          const frag = document.createDocumentFragment();
          list.slice(0, 30).forEach(row => {
            const ns = row && row.value ? String(row.value) : '';
            const count = row && typeof row.count === 'number' ? row.count : 0;
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'chip-button' + (selectedNamespaces.has(ns) ? ' active' : '');
            button.dataset.value = ns;
            button.setAttribute('aria-pressed', selectedNamespaces.has(ns));
            button.textContent = formatNamespaceDisplay(ns) + ' (' + count + ')';
            frag.appendChild(button);
          });
          namespaceFilters.appendChild(frag);
          return;
        }

        if (!force && !namespaceDirty && stats.lines > FILTER_REFRESH_INTERVAL && stats.lines % FILTER_REFRESH_INTERVAL !== 0) {
          return;
        }
        namespaceDirty = false;
        namespaceFilters.innerHTML = '';
        if (!stats.namespaces.size) {
          const p = document.createElement('p');
          p.className = 'placeholder';
          p.textContent = 'No namespaces yet';
          namespaceFilters.appendChild(p);
          return;
        }
        const frag = document.createDocumentFragment();
        const items = Array.from(stats.namespaces.entries()).sort((a, b) => {
          if (b[1] === a[1]) {
            return formatNamespaceDisplay(a[0]).localeCompare(formatNamespaceDisplay(b[0]));
          }
          return b[1] - a[1];
        });
        items.slice(0, 20).forEach(([ns, count]) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'chip-button' + (selectedNamespaces.has(ns) ? ' active' : '');
          button.dataset.value = ns;
          button.setAttribute('aria-pressed', selectedNamespaces.has(ns));
          button.textContent = formatNamespaceDisplay(ns) + ' (' + count + ')';
          frag.appendChild(button);
        });
        namespaceFilters.appendChild(frag);
      }

      function renderPodChips(force) {
        if (!chipFiltersEnabled || !podFilters) {
          return;
        }
        if (isCaptureMode) {
          podFilters.innerHTML = '';
          const list = (captureFacets && Array.isArray(captureFacets.pods)) ? captureFacets.pods : [];
          if (!list.length) {
            const p = document.createElement('p');
            p.className = 'placeholder';
            p.textContent = 'No pods';
            podFilters.appendChild(p);
            return;
          }
          const frag = document.createDocumentFragment();
          list.slice(0, 40).forEach(row => {
            const ns = row && row.namespace ? String(row.namespace) : '';
            const pod = row && row.pod ? String(row.pod) : '';
            const count = row && typeof row.count === 'number' ? row.count : 0;
            const value = makePodValue(ns, pod);
            const active = selectedPods.has(value);
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'chip-button' + (active ? ' active' : '');
            button.dataset.value = value;
            button.setAttribute('aria-pressed', active);
            button.textContent = formatPodDisplay(ns, pod) + ' (' + count + ')';
            frag.appendChild(button);
          });
          podFilters.appendChild(frag);
          return;
        }

        if (!force && !podDirty && stats.lines > FILTER_REFRESH_INTERVAL && stats.lines % FILTER_REFRESH_INTERVAL !== 0) {
          return;
        }
        podDirty = false;
        podFilters.innerHTML = '';
        if (!stats.pods.size) {
          const p = document.createElement('p');
          p.className = 'placeholder';
          p.textContent = 'No pods yet';
          podFilters.appendChild(p);
          return;
        }
        const frag = document.createDocumentFragment();
        const items = Array.from(stats.pods.entries()).sort((a, b) => {
          if (b[1] === a[1]) {
            return a[0].localeCompare(b[0]);
          }
          return b[1] - a[1];
        }).slice(0, 20);
        items.forEach(([value, count]) => {
          const detail = decodePodValue(value);
          const button = document.createElement('button');
          const active = selectedPods.has(value);
          button.type = 'button';
          button.className = 'chip-button' + (active ? ' active' : '');
          button.dataset.value = value;
          button.setAttribute('aria-pressed', active);
          button.textContent = formatPodDisplay(detail.namespace, detail.pod) + ' (' + count + ')';
          frag.appendChild(button);
        });
        podFilters.appendChild(frag);
      }

      function handleChipClick(event, selectedSet) {
        if (!chipFiltersEnabled) {
          return;
        }
        const target = event.target.closest('.chip-button');
        if (!target || !target.dataset) {
          return;
        }
        const value = target.dataset.value || '';
        if (selectedSet.has(value)) {
          selectedSet.delete(value);
        } else {
          selectedSet.add(value);
        }
        applyFilters();
        updateFilterMeta();
        target.classList.toggle('active');
        target.setAttribute('aria-pressed', target.classList.contains('active'));
      }

	      function clearFilters() {
	        if (filterSearch) {
	          filterSearch.value = '';
	        }
	        previewSearchText = '';
	        renderSearchPreviewChips();
	        clearSearchChips();
	        setQuickFilter('onlyErrors', false);
	        setQuickFilter('onlyOOMKilled', false);
	        setQuickFilter('onlyRestarts', false);
        setQuickFilter('onlyNotReady', false);
        if (!chipFiltersEnabled) {
          applyFilters();
          return;
        }
        selectedNamespaces.clear();
        selectedPods.clear();
        updateFilterMeta();
        renderNamespaceChips(true);
        renderPodChips(true);
        applyFilters();
      }

      function resolveWebSocketURL() {
        try {
          const url = new URL('ws', window.location.href);
          url.protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          url.search = '';
          url.hash = '';
          return url.href;
        } catch (err) {
          const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
          return proto + '//' + window.location.host + '/ws';
        }
      }

      function connect() {
        const ws = new WebSocket(resolveWebSocketURL());
        ws.onopen = function() { statusChip.textContent = 'Live'; updateFeedEmptyState(); };
        ws.onclose = function() { statusChip.textContent = 'Reconnecting…'; updateFeedEmptyState(); setTimeout(connect, 1500); };
        ws.onerror = function() { statusChip.textContent = 'Error'; updateFeedEmptyState(); };
        ws.onmessage = function(evt) {
          try {
            const data = JSON.parse(evt.data);
            updateStats(data);
            appendEntry(data);
          } catch (err) {
            console.error('render error', err);
          }
        };
      }

      function resetFeedForCaptureQuery() {
        if (feed) {
          feed.innerHTML = '';
        }
        entries.length = 0;
        visibleCount = 0;
        logGroupState.clear();
        entryBySeq.clear();
        selectedEntrySeqs.clear();
        updateCopySelectedButton();
        podContextCache.clear();
        timelineState.highlightedEntry = null;
        selectedEntry = null;
        captureEventIngested = new Set();
		        renderEntities();
		        updateFindMatches();
		        renderActiveFiltersBar();
		        renderTopTalkers();
		        updateVisibilityStats();
		        scheduleTimelineRender();
		      }

      function captureAPIBase() {
        const id = String(captureID || '').trim();
        if (!id) return '';
        return '/api/capture/' + encodeURIComponent(id);
      }

      function gatherCaptureSearch() {
        const tokens = [];
        const preview = String(previewSearchText || '').trim();
        if (preview) tokens.push(preview);
        if (searchChipState && searchChipState.size) {
          Array.from(searchChipState.keys()).forEach(k => {
            const raw = String(k || '').trim();
            if (!raw) return;
            tokens.push(raw);
          });
        }
        return tokens;
      }

      function buildCaptureQueryParams() {
        const params = new URLSearchParams();
        if (timeRange && timeRange.start) {
          params.set('start', timeRange.start.toISOString());
        }
        if (timeRange && timeRange.end) {
          params.set('end', timeRange.end.toISOString());
        }
        if (chipFiltersEnabled) {
          Array.from(selectedNamespaces.values()).sort().forEach(ns => params.append('ns', String(ns)));
          Array.from(selectedPods.values()).sort().forEach(pv => params.append('podValue', String(pv)));
        }
        const containers = [];
        const qTokens = [];
        gatherCaptureSearch().forEach(token => {
          const t = String(token || '').trim();
          if (!t) return;
          if (t.startsWith('!') || t.startsWith('-')) {
            return;
          }
          const idx = t.indexOf(':');
          if (idx > 0) {
            const prefix = t.slice(0, idx).toLowerCase();
            const value = t.slice(idx + 1).trim();
            if (!value) return;
            if (prefix === 'ns' || prefix === 'namespace') {
              params.append('ns', value);
              return;
            }
            if (prefix === 'c' || prefix === 'container') {
              containers.push(value);
              return;
            }
          }
          qTokens.push(t);
        });
        containers.sort().forEach(v => params.append('container', v));
        const q = qTokens.join(' ').trim();
        if (q) {
          params.set('q', q);
        }
        return params;
      }

      async function fetchCaptureJSON(path, params) {
        const base = captureAPIBase();
        if (!base) return null;
        let url = base + path;
        if (params) {
          const qs = params.toString();
          if (qs) url += '?' + qs;
        }
        const res = await fetch(url, { headers: { 'accept': 'application/json' } });
        if (!res.ok) {
          throw new Error('capture api failed: ' + res.status);
        }
        return await res.json();
      }

      async function loadCaptureMetaAndTimeline() {
        const metaResp = await fetchCaptureJSON('/meta');
        if (metaResp && metaResp.meta) {
          const m = metaResp.meta;
          const session = {
            sessionName: m.sessionName || 'Capture session',
            title: m.sessionName || 'Capture session',
            context: m.context || '',
            window: {
              start: m.startedAt || '',
              end: m.endedAt || '',
              duration: m.duration || '',
            },
            podCount: typeof m.podCount === 'number' ? m.podCount : 0,
            namespaces: Array.isArray(m.namespaces) ? m.namespaces : [],
            podQuery: m.podQuery || '',
            commands: {},
          };
          renderSessionPanel(session);
        }
        const facetsParams = buildCaptureQueryParams();
        const facets = await fetchCaptureJSON('/facets', facetsParams);
        if (facets) {
          captureFacets = {
            namespaces: Array.isArray(facets.namespaces) ? facets.namespaces : [],
            pods: Array.isArray(facets.pods) ? facets.pods : [],
            containers: Array.isArray(facets.containers) ? facets.containers : [],
          };
          if (chipFiltersEnabled) {
            renderNamespaceChips(true);
            renderPodChips(true);
          }
        }
        const tlParams = buildCaptureQueryParams();
        tlParams.set('bucketMs', '60000');
        const tl = await fetchCaptureJSON('/timeline', tlParams);
        if (tl && Array.isArray(tl.buckets) && typeof tl.startMs === 'number' && typeof tl.endMs === 'number') {
          timelineState.start = new Date(tl.startMs);
          timelineState.end = new Date(tl.endMs);
          timelineState.viewStart = timelineState.start;
          timelineState.viewEnd = timelineState.end;
          timelineState.histogram = tl;
          updateTimelineVisibility();
          scheduleTimelineRender();
        }
      }

      async function loadCaptureEvents() {
        const params = new URLSearchParams();
        if (timeRange && timeRange.start) {
          params.set('start', timeRange.start.toISOString());
        }
        if (timeRange && timeRange.end) {
          params.set('end', timeRange.end.toISOString());
        }
        const ev = await fetchCaptureJSON('/events', params);
        if (!Array.isArray(ev)) return;
        eventsState.items = ev.slice();
        captureEventsSorted = [];
        captureEventIngested = new Set();
        ev.forEach(ev => {
          if (!ev) return;
          const ts = parseTimestamp(ev.ts || ev.lastTimestamp || ev.time);
          captureEventsSorted.push({
            ev,
            ms: ts ? ts.getTime() : 0,
            id: JSON.stringify([ev.ts || ev.lastTimestamp || '', ev.namespace || '', ev.type || '', ev.reason || '', ev.involvedKind || '', ev.involvedName || '', ev.message || '']),
          });
          if (ev.involvedKind && String(ev.involvedKind).toLowerCase() === 'pod' && ev.involvedName) {
            const ns = ev.namespace || ev.involvedNamespace || '';
            const podValue = makePodValue(ns, ev.involvedName);
            const ds = ev.dataset || '';
            const list = k8sEventsByPod.get(eventPodKey(ds, podValue)) || [];
            list.push(ev);
            k8sEventsByPod.set(eventPodKey(ds, podValue), list);
          }
          const parts = [];
          if (ev.dataset) parts.push(String(ev.dataset).toUpperCase());
          if (ev.type) parts.push(ev.type);
          if (ev.reason) parts.push(ev.reason);
          const obj = (ev.involvedKind && ev.involvedName) ? (ev.involvedKind + '/' + ev.involvedName) : '';
          if (obj) parts.push(obj);
          if (ev.message) parts.push(ev.message);
          const label = formatTimelineLabel(parts.join(' · '));
          const sev = (String(ev.type || '').toLowerCase() === 'warning') ? 'fail' : 'info';
          const meta = {
            type: ev.type || '',
            reason: ev.reason || '',
            message: ev.message || '',
            dataset: ev.dataset || '',
            namespace: ev.namespace || ev.involvedNamespace || '',
            involvedKind: ev.involvedKind || '',
            involvedName: ev.involvedName || '',
            involvedNamespace: ev.involvedNamespace || '',
            pod: (String(ev.involvedKind || '').toLowerCase() === 'pod') ? (ev.involvedName || '') : '',
          };
          addTimelineMarker(ts || new Date(), TIMELINE_EVENT_TYPES.K8S_EVENT, label, sev, meta);
        });
        captureEventsSorted.sort((a, b) => {
          const diff = (a.ms || 0) - (b.ms || 0);
          if (diff !== 0) return diff;
          const aid = a.id || '';
          const bid = b.id || '';
          if (aid === bid) return 0;
          return aid < bid ? -1 : 1;
        });
      }

      function captureEventsForRange(startMs, endMs) {
        if (!Array.isArray(captureEventsSorted) || captureEventsSorted.length === 0) {
          return [];
        }
        const s = Number.isFinite(startMs) ? startMs : 0;
        const e = Number.isFinite(endMs) ? endMs : Number.MAX_SAFE_INTEGER;
        const out = [];
        for (let i = 0; i < captureEventsSorted.length; i++) {
          const it = captureEventsSorted[i];
          if (!it) continue;
          const ms = it.ms || 0;
          if (ms < s) continue;
          if (ms > e) break;
          if (it.id && captureEventIngested.has(it.id)) continue;
          if (it.id) captureEventIngested.add(it.id);
          const rec = eventToLogRecord(it.ev);
          if (rec) out.push(rec);
        }
        return out;
      }

      async function loadCaptureManifests() {
        const mf = await fetchCaptureJSON('/manifests');
        if (!mf || !Array.isArray(mf.resources)) return;
        manifestState.resources = mf.resources.slice();
        buildManifestIndex();
        renderManifestPanel();
      }

      function isNearTop() {
        if (!feed) {
          return true;
        }
        return feed.scrollTop <= 160;
      }

      function trimEntriesTail() {
        while (entries.length > MAX_ENTRIES) {
          const entry = entries.pop();
          if (!entry) continue;
          if (entry.seq) {
            entryBySeq.delete(entry.seq);
            if (selectedEntrySeqs.has(entry.seq)) {
              selectedEntrySeqs.delete(entry.seq);
            }
          }
          if (entry.element && entry.element.parentNode) {
            entry.element.parentNode.removeChild(entry.element);
          }
          const gk = entry.keys ? entry.keys.groupKey : '';
          if (gk && logGroupState.has(gk)) {
            const group = logGroupState.get(gk);
            group.total = Math.max(0, group.total - 1);
            if (entry.visible) {
              group.visible = Math.max(0, group.visible - 1);
            }
            if (group.total === 0) {
              if (group.details && group.details.parentNode) {
                group.details.parentNode.removeChild(group.details);
              }
              logGroupState.delete(gk);
            } else {
              updateLogGroupUI(group);
            }
          }
          if (entry.visible) {
            visibleCount = Math.max(0, visibleCount - 1);
          }
          if (timelineState.highlightedEntry === entry) {
            if (entry.element) {
              entry.element.classList.remove('focused');
            }
            timelineState.highlightedEntry = null;
          }
          if (selectedEntry === entry) {
            selectedEntry = null;
          }
        }
        updateCopySelectedButton();
      }

      function ingestCaptureLog(data, prepend) {
        if (!data) return;
        if (inlineMetricsEnabled) {
          updateBuildMetrics(data);
        }
        const entry = document.createElement('article');
        entry.className = 'log-entry';
        const meta = document.createElement('div');
        meta.className = 'meta';
        const badge = document.createElement('span');
        badge.className = 'chip-inline';
        badge.textContent = (data.glyph || '●') + ' ' + (data.source || 'pod');
        meta.appendChild(badge);
        if (data.dataset) {
          const ds = document.createElement('span');
          ds.className = 'chip-inline';
          ds.textContent = String(data.dataset).toUpperCase();
          meta.appendChild(ds);
        }
        const tsBtn = document.createElement('button');
        tsBtn.type = 'button';
        tsBtn.className = 'meta-pill';
        tsBtn.textContent = String(data.displayTs || data.ts || '');
        tsBtn.title = 'Jump to this timestamp';
        tsBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const ts = parseTimestamp(data.ts || data.timestamp || data.displayTs);
          if (ts) {
            autoScrollEnabled = false;
            autoScrollPaused = true;
            updateAutoScrollUI();
            scrollFeedToTimestamp(ts, true);
          }
        });
        meta.appendChild(tsBtn);

        const sep = document.createElement('span');
        sep.textContent = ' · ';
        meta.appendChild(sep);

        const podBtn = document.createElement('button');
        podBtn.type = 'button';
        podBtn.className = 'meta-pill';
        const nsText = String(data.namespace || '-');
        const podText = String(data.pod || '-');
        podBtn.textContent = nsText + '/' + podText;
        podBtn.title = 'Filter to this pod (Shift-click to add)';
        podBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          if (!chipFiltersEnabled) {
            return;
          }
          const ns = String(data.namespace || '');
          const pod = String(data.pod || '');
          if (!evt.shiftKey) {
            selectedNamespaces.clear();
            selectedPods.clear();
          }
          if (ns) {
            selectedNamespaces.add(ns);
          }
          if (ns && pod) {
            selectedPods.add(makePodValue(ns, pod));
          }
          renderNamespaceChips(true);
          renderPodChips(true);
          updateFilterMeta();
          applyFilters();
        });
        meta.appendChild(podBtn);

        const contSep = document.createElement('span');
        contSep.textContent = ' [';
        meta.appendChild(contSep);

        const contBtn = document.createElement('button');
        contBtn.type = 'button';
        contBtn.className = 'meta-pill';
        contBtn.textContent = String(data.container || '-');
        contBtn.title = 'Add container filter';
        contBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const c = String(data.container || '').trim();
          if (!c) {
            return;
          }
          if (addSearchChip('c:' + c)) {
            applyFilters();
          }
        });
        meta.appendChild(contBtn);

        const contClose = document.createElement('span');
        contClose.textContent = ']';
        meta.appendChild(contClose);

        const actions = document.createElement('div');
        actions.className = 'meta-actions';
        const copyLineBtn = document.createElement('button');
        copyLineBtn.type = 'button';
        copyLineBtn.className = 'mini-btn';
        copyLineBtn.textContent = 'Copy';
        copyLineBtn.title = 'Copy raw line';
        copyLineBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const text = String(data.raw || data.line || '');
          copyText(text);
        });
        actions.appendChild(copyLineBtn);

        const copyJSONBtn = document.createElement('button');
        copyJSONBtn.type = 'button';
        copyJSONBtn.className = 'mini-btn';
        copyJSONBtn.textContent = 'JSON';
        copyJSONBtn.title = 'Copy JSON record';
        copyJSONBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          try {
            copyText(JSON.stringify(data, null, 2));
          } catch (_) {
            copyText(String(data));
          }
        });
        actions.appendChild(copyJSONBtn);

        const copyKubectlBtn = document.createElement('button');
        copyKubectlBtn.type = 'button';
        copyKubectlBtn.className = 'mini-btn';
        copyKubectlBtn.textContent = 'kubectl';
        copyKubectlBtn.title = 'Copy kubectl logs command';
        copyKubectlBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          const ns = String(data.namespace || '');
          const pod = String(data.pod || '');
          const c = String(data.container || '');
          const base = ['kubectl', 'logs'];
          if (ns) base.push('-n', ns);
          if (pod) base.push(pod);
          if (c) base.push('-c', c);
          base.push('--since=10m');
          copyText(base.join(' '));
        });
        actions.appendChild(copyKubectlBtn);

        const bookmarkBtn = document.createElement('button');
        bookmarkBtn.type = 'button';
        bookmarkBtn.className = 'mini-btn primary';
        bookmarkBtn.textContent = '☆';
        bookmarkBtn.title = 'Bookmark this line';
        bookmarkBtn.addEventListener('click', (evt) => {
          evt.stopPropagation();
          addBookmarkFromData(data);
        });
        actions.appendChild(bookmarkBtn);

        meta.appendChild(actions);

        const line = document.createElement('div');
        line.className = 'log-line';
        const ansiSource = data.lineAnsi || data.raw || '';
        const fallbackText = data.line || data.raw || '';
        renderANSIInto(line, ansiSource, fallbackText);
        entry.appendChild(meta);
        entry.appendChild(line);
        const normalized = {
          source: String(data.source || '').toLowerCase(),
          glyph: String(data.glyph || '').toLowerCase(),
          dataset: (data.dataset || '').toLowerCase(),
          line: (fallbackText || '').toLowerCase(),
        };
        const podValue = makePodValue(data.namespace || '', data.pod || '');
        const groupKey = logGroupKeyForData(data);
        const groupTitle = logGroupTitleForData(data);
	        const entryRecord = {
	          seq: ++entrySeq,
	          element: entry,
	          data,
	          timestamp: parseTimestamp(data.ts || data.timestamp) || new Date(),
	          normalized,
          keys: {
            namespace: data.namespace || '',
            podValue,
            dataset: data.dataset || '',
            groupKey,
          },
	          visible: true,
	          flags: {},
	        };
	        entry.dataset.entrySeq = String(entryRecord.seq);
	        entryBySeq.set(entryRecord.seq, entryRecord);
        const sevClass = severityClassForEntry(entryRecord);
        if (sevClass) {
          entry.classList.add(sevClass);
        }
        const group = getOrCreateLogGroup(groupKey, groupTitle);
        if (group && group.body) {
          group.total += 1;
          if (prepend) {
            group.body.insertBefore(entry, group.body.firstChild);
          } else {
            group.body.appendChild(entry);
          }
          updateLogGroupUI(group);
        } else if (feed) {
          if (prepend) {
            feed.insertBefore(entry, feed.firstChild);
          } else {
            feed.appendChild(entry);
          }
        }

	        if (prepend) {
	          entries.unshift(entryRecord);
	        } else {
	          entries.push(entryRecord);
	        }
	        entry.tabIndex = 0;
	        entry.addEventListener('click', (evt) => {
	          if (handleEntryPointerSelection(evt, entryRecord)) {
	            return;
	          }
	          selectEntry(entryRecord);
	        });
	        entry.addEventListener('mousedown', (evt) => {
	          if (!evt || evt.button !== 0 || !evt.shiftKey) {
	            return;
	          }
	          const idx = entries.indexOf(entryRecord);
	          if (idx < 0) {
	            return;
	          }
	          draggingSelection = true;
	          const additive = !!(evt.metaKey || evt.ctrlKey);
	          selectionAnchorIndex = selectionAnchorIndex == null ? idx : selectionAnchorIndex;
	          setSelectedRangeByIndex(selectionAnchorIndex, idx, additive);
	          evt.preventDefault();
	        });
	        entry.addEventListener('mouseenter', (evt) => {
	          if (!draggingSelection) {
	            return;
	          }
	          const idx = entries.indexOf(entryRecord);
	          if (idx < 0 || selectionAnchorIndex == null) {
	            return;
	          }
	          setSelectedRangeByIndex(selectionAnchorIndex, idx, true);
	          evt.preventDefault();
	        });
	        entry.addEventListener('keydown', (evt) => {
	          if (evt.key === 'Enter' || evt.key === ' ') {
	            evt.preventDefault();
	            selectEntry(entryRecord);
	          }
	        });
        if (prepend) {
          if (entries.length > MAX_ENTRIES) {
            trimEntriesTail();
          }
        } else {
          if (entries.length > MAX_ENTRIES) {
            trimEntries();
          }
        }
        applyFiltersToEntry(entryRecord);
      }

      async function loadCaptureLogsPage(reset, mode) {
        if (captureLoading) return;
        if (!captureHasOlder && !reset && mode !== 'tail') return;
        captureLoading = true;
        try {
          const params = buildCaptureQueryParams();
          params.set('limit', '750');
          params.set('direction', 'backward');
          if (!reset && captureOlderCursor && mode !== 'tail') {
            params.set('cursor', captureOlderCursor);
          }
          const sig = params.toString().replace(/(?:^|&)cursor=[^&]*/g, '');
          if (reset || sig !== captureQuerySig) {
            captureQuerySig = sig;
            captureOlderCursor = '';
            captureHasOlder = true;
            resetFeedForCaptureQuery();
          }
          const resp = await fetchCaptureJSON('/logs', params);
          const items = resp && Array.isArray(resp.items) ? resp.items : [];
          let rangeStartMs = 0;
          let rangeEndMs = 0;
          if (items.length) {
            const firstTs = parseTimestamp(items[0].ts || items[0].timestamp || '');
            const lastTs = parseTimestamp(items[items.length - 1].ts || items[items.length - 1].timestamp || '');
            rangeStartMs = firstTs ? firstTs.getTime() : 0;
            rangeEndMs = lastTs ? lastTs.getTime() : 0;
          } else if (timeRange && timeRange.start && timeRange.end) {
            rangeStartMs = timeRange.start.getTime();
            rangeEndMs = timeRange.end.getTime();
          } else if (timelineState && timelineState.start && timelineState.end) {
            rangeStartMs = timelineState.start.getTime();
            rangeEndMs = timelineState.end.getTime();
          }

          const eventRecords = (rangeEndMs >= rangeStartMs) ? captureEventsForRange(rangeStartMs, rangeEndMs) : [];
          const combined = [];
          items.forEach(it => {
            const ts = parseTimestamp(it.ts || it.timestamp || '') || new Date(0);
            combined.push({ kind: 'log', ms: ts.getTime(), data: it });
          });
          eventRecords.forEach(it => {
            const ts = parseTimestamp(it.ts || it.timestamp || '') || new Date(0);
            combined.push({ kind: 'event', ms: ts.getTime(), data: it });
          });
          combined.sort((a, b) => {
            const diff = (a.ms || 0) - (b.ms || 0);
            if (diff !== 0) return diff;
            const ak = a.kind === 'event' ? 0 : 1;
            const bk = b.kind === 'event' ? 0 : 1;
            return ak - bk;
          });
	          if (mode === 'older') {
	            const prevHeight = feed ? feed.scrollHeight : 0;
	            for (let i = combined.length - 1; i >= 0; i--) {
	              ingestCaptureLog(combined[i].data, true);
	            }
	            if (feed) {
	              const nextHeight = feed.scrollHeight;
	              feed.scrollTop += Math.max(0, nextHeight - prevHeight);
	            }
	          } else {
	            combined.forEach(row => ingestCaptureLog(row.data, false));
	            if (feed) {
	              feed.scrollTop = feed.scrollHeight;
	            }
	          }
	          captureHasOlder = !!(resp && resp.hasMore);
	          captureOlderCursor = resp && resp.nextCursor ? String(resp.nextCursor) : '';
	          applyFilters();
	        } finally {
	          captureLoading = false;
	        }
	      }

      function scheduleCaptureReload() {
        if (captureReloadTimer) {
          clearTimeout(captureReloadTimer);
        }
        captureReloadTimer = setTimeout(() => {
          loadCaptureMetaAndTimeline().catch(() => {});
          loadCaptureEvents().catch(() => {});
          loadCaptureLogsPage(true, 'tail').catch(() => {});
        }, 140);
      }

	      function decodeHTMLEntities(text) {
	        if (!text || text.indexOf('&') === -1) {
	          return text || '';
	        }
        const tmp = document.createElement('textarea');
        tmp.innerHTML = text;
        return tmp.value;
      }

      function readEmbeddedPayload(id) {
        const el = document.getElementById(id);
        if (!el) {
          return '';
        }
        let text = '';
        if (typeof el.value === 'string') {
          text = el.value;
        } else {
          text = el.textContent || '';
        }
        el.remove();
        text = String(text || '').trim();
        if (!text) {
          return '';
        }
        return text.replaceAll('\n', '').replaceAll('\r', '').replaceAll('\t', '').replaceAll(' ', '');
      }

      function decodeBase64ToText(b64) {
        if (!b64) {
          return '';
        }
        const normalized = decodeHTMLEntities(String(b64)).replaceAll('\n', '').replaceAll('\r', '').replaceAll('\t', '').replaceAll(' ', '');
        const binary = atob(normalized);
        const bytes = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return new TextDecoder('utf-8').decode(bytes);
      }

      function decodeBase64ToJSON(b64) {
        const text = decodeBase64ToText(b64);
        if (!text) {
          return null;
        }
        try {
          return JSON.parse(text);
        } catch (err) {
          console.error('base64 json decode error', err);
          return null;
        }
      }

      var isStaticMode = false;
      var isCaptureMode = false;
      var captureID = '';
      var captureOlderCursor = '';
      var captureHasOlder = true;
      var captureLoading = false;
      var captureReloadTimer = null;
      var captureQuerySig = '';
      var captureFacets = { namespaces: [], pods: [], containers: [] };
      var captureEventsSorted = [];
      var captureEventIngested = new Set();
      const pendingStaticRecords = [];
      const pendingStaticEvents = [];
      function copyText(text) {
        if (!text) {
          return;
        }
        const fallback = () => window.prompt('Copy command:', text);
        const done = () => {
          statusChip.textContent = 'Copied';
          setTimeout(() => {
            if (statusChip.textContent === 'Copied') {
              statusChip.textContent = isStaticMode ? 'Static' : 'Live';
            }
          }, 1200);
        };
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(done).catch(fallback);
          return;
        }
        fallback();
      }

      function loadBookmarks() {
        const raw = readStorage(STORAGE_KEYS.shareBookmarks);
        if (!raw) {
          return [];
        }
        try {
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        } catch (_) {
          return [];
        }
      }

      function persistBookmarks() {
        try {
          writeStorage(STORAGE_KEYS.shareBookmarks, JSON.stringify(bookmarksState.items.slice(-200)));
        } catch (_) {
          // ignore
        }
      }

      function loadSavedQueries() {
        const raw = readStorage(STORAGE_KEYS.savedQueries);
        if (!raw) return [];
        try {
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        } catch (_) {
          return [];
        }
      }

      function persistSavedQueries() {
        try {
          writeStorage(STORAGE_KEYS.savedQueries, JSON.stringify(savedQueriesState.items.slice(-40)));
        } catch (_) {
          // ignore
        }
      }

      function renderSavedQueries() {
        if (!savedQueryTray) {
          return;
        }
        savedQueryTray.innerHTML = '';
        const items = savedQueriesState.items.slice().reverse();
        if (!items.length) {
          return;
        }
        items.slice(0, 10).forEach(item => {
          if (!item) return;
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'chip-button';
          chip.textContent = 'Saved: ' + (item.name || 'Query');
          chip.title = 'Apply saved query (Shift-click adds)';
          chip.addEventListener('click', (evt) => {
            applySavedQuery(item, !!evt.shiftKey);
          });
          const del = document.createElement('button');
          del.type = 'button';
          del.className = 'chip-button';
          del.textContent = '✕';
          del.title = 'Delete saved query';
          del.addEventListener('click', (evt) => {
            evt.stopPropagation();
            savedQueriesState.items = savedQueriesState.items.filter(q => q && q.id !== item.id);
            persistSavedQueries();
            renderSavedQueries();
          });
          const wrap = document.createElement('div');
          wrap.style.display = 'flex';
          wrap.style.gap = '0.35rem';
          wrap.appendChild(chip);
          wrap.appendChild(del);
          savedQueryTray.appendChild(wrap);
        });
      }

      function saveCurrentQuery() {
        const name = window.prompt('Save query name:', 'Saved query');
        if (name == null) {
          return;
        }
        const trimmed = String(name).trim() || 'Query';
        const id = String(Date.now()) + '|' + trimmed;
        const item = {
          id,
          name: trimmed,
          state: {
            search: Array.from(searchChipState.keys()),
            quick: { ...quickFilters },
            lanes: { ...lanes },
            time: {
              start: timeRange.start ? timeRange.start.toISOString() : '',
              end: timeRange.end ? timeRange.end.toISOString() : '',
            },
          },
        };
        savedQueriesState.items.push(item);
        persistSavedQueries();
        renderSavedQueries();
      }

      function applySavedQuery(item, additive) {
        if (!item || !item.state) {
          return;
        }
        const s = item.state;
        if (!additive) {
          clearSearchChips();
          Object.keys(quickFilters).forEach(k => setQuickFilter(k, false));
        }
        if (Array.isArray(s.search)) {
          s.search.forEach(token => addSearchChip(String(token)));
        }
        if (s.quick) {
          Object.keys(quickFilters).forEach(k => {
            if (k in s.quick) {
              setQuickFilter(k, !!s.quick[k]);
            }
          });
        }
        if (s.lanes) {
          Object.keys(lanes).forEach(k => {
            if (k in s.lanes) {
              setLaneEnabled(k, !!s.lanes[k]);
            }
          });
          renderLaneChips();
        }
        if (s.time) {
          const start = parseTimeInput(s.time.start);
          const end = parseTimeInput(s.time.end);
          setTimeRange(start, end);
        } else {
          applyFilters();
        }
      }

      function bookmarkLabelForData(data) {
        const src = String(data && data.source ? data.source : '');
        const ns = String(data && data.namespace ? data.namespace : '');
        const pod = String(data && data.pod ? data.pod : '');
        const c = String(data && data.container ? data.container : '');
        const raw = String(data && (data.raw || data.line) ? (data.raw || data.line) : '');
        const trimmed = raw.replace(/\s+/g, ' ').trim();
        const head = (ns && pod) ? (ns + '/' + pod) : (pod || ns || src || 'log');
        const tail = c ? ('[' + c + ']') : '';
        const msg = trimmed ? (' · ' + formatTimelineLabel(trimmed)) : '';
        return head + tail + msg;
      }

      function addBookmarkFromData(data) {
        if (!data) {
          return;
        }
        const ts = parseTimestamp(data.ts || data.timestamp || data.displayTs) || new Date();
        const id = String(ts.getTime()) + '|' + String(data.namespace || '') + '|' + String(data.pod || '') + '|' + String(data.container || '') + '|' + String(data.source || '');
        if (bookmarksState.items.some(b => b && b.id === id)) {
          return;
        }
        const snapshot = getShareState();
        const item = {
          id,
          ts: ts.toISOString(),
          label: bookmarkLabelForData(data),
          ns: String(data.namespace || ''),
          pod: String(data.pod || ''),
          container: String(data.container || ''),
          source: String(data.source || ''),
          state: snapshot,
        };
        bookmarksState.items.push(item);
        persistBookmarks();
	        renderBookmarks();
	      }

      function clearBookmarks() {
        bookmarksState.items = [];
        persistBookmarks();
	        renderBookmarks();
	      }

      function exportBookmarks() {
        const payload = {
          exportedAt: new Date().toISOString(),
          url: window.location.href,
          bookmarks: bookmarksState.items,
        };
        copyText(JSON.stringify(payload, null, 2));
      }

      function renderBookmarks() {
        if (!bookmarksPanel || !bookmarkList) {
          return;
        }
        bookmarkList.innerHTML = '';
        const items = bookmarksState.items.slice().reverse();
        if (!items.length) {
          bookmarksPanel.setAttribute('hidden', 'true');
          return;
        }
        bookmarksPanel.removeAttribute('hidden');
        const frag = document.createDocumentFragment();
        items.forEach(item => {
          if (!item) return;
          const row = document.createElement('div');
          row.className = 'bookmark-row';
          const label = document.createElement('div');
          label.className = 'label';
          const strong = document.createElement('strong');
          strong.textContent = (item.label || '').split(' · ')[0] || 'Bookmark';
          const sub = document.createElement('span');
          const ts = parseTimestamp(item.ts);
          sub.textContent = (ts ? ts.toLocaleString() : String(item.ts || '')) + (item.label && item.label.includes(' · ') ? (' · ' + item.label.split(' · ').slice(1).join(' · ')) : '');
          label.appendChild(strong);
          label.appendChild(sub);
          row.appendChild(label);

          const actions = document.createElement('div');
          actions.className = 'actions';
          const jump = document.createElement('button');
          jump.type = 'button';
          jump.className = 'mini-btn primary';
          jump.textContent = 'Jump';
          jump.addEventListener('click', () => {
            const t = parseTimestamp(item.ts);
            if (t) {
              autoScrollEnabled = false;
              autoScrollPaused = true;
              updateAutoScrollUI();
              scrollFeedToTimestamp(t, true);
              timelineState.playhead = t;
              setScrubberRatio(timeToRatio(t));
              scheduleTimelineRender();
            }
          });
          actions.appendChild(jump);

          const restore = document.createElement('button');
          restore.type = 'button';
          restore.className = 'mini-btn';
          restore.textContent = 'Restore';
          restore.title = 'Restore saved filters for this bookmark';
          restore.addEventListener('click', () => {
            if (item.state) {
              applyShareState(item.state);
              applyFilters();
            }
          });
          actions.appendChild(restore);

          const del = document.createElement('button');
          del.type = 'button';
          del.className = 'mini-btn';
          del.textContent = 'Del';
          del.addEventListener('click', () => {
            bookmarksState.items = bookmarksState.items.filter(b => b && b.id !== item.id);
            persistBookmarks();
            renderBookmarks();
          });
          actions.appendChild(del);

          row.appendChild(actions);
          frag.appendChild(row);
        });
        bookmarkList.appendChild(frag);
      }

      bookmarksState.items = loadBookmarks();
      renderBookmarks();
      if (exportBookmarksBtn) {
        exportBookmarksBtn.addEventListener('click', exportBookmarks);
      }
      if (clearBookmarksBtn) {
        clearBookmarksBtn.addEventListener('click', clearBookmarks);
      }

      savedQueriesState.items = loadSavedQueries();
      renderSavedQueries();
      if (saveQueryBtn) {
        saveQueryBtn.addEventListener('click', saveCurrentQuery);
      }

      function manifestKeyString(key, dataset) {
        const group = key && key.group ? String(key.group) : 'core';
        const kind = key && key.kind ? String(key.kind) : '';
        const ns = key && key.namespace ? String(key.namespace) : '';
        const name = key && key.name ? String(key.name) : '';
        const ds = dataset ? String(dataset) : '';
        const head = (ns ? ns : 'cluster') + '/' + name;
        const tail = kind + ' (' + group + ')';
        if (ds) {
          return ds.toUpperCase() + ' · ' + head + ' ' + tail;
        }
        return head + ' ' + tail;
      }

      function manifestKeyId(key, dataset) {
        const kind = key && key.kind ? String(key.kind) : '';
        const ns = key && key.namespace ? String(key.namespace) : '';
        const name = key && key.name ? String(key.name) : '';
        const ds = dataset ? String(dataset) : '';
        return [ds, kind, ns, name].join('|');
      }

      function buildManifestIndex() {
        manifestState.byKey = new Map();
        manifestState.childrenByKey = new Map();
        manifestState.roots = [];
        manifestState.resources.forEach(r => {
          const id = manifestKeyId(r.key, r.dataset);
          manifestState.byKey.set(id, r);
        });
        manifestState.resources.forEach(r => {
          const childId = manifestKeyId(r.key, r.dataset);
          const owners = Array.isArray(r.owners) ? r.owners : [];
          owners.forEach(ownerKey => {
            const ownerId = manifestKeyId(ownerKey, r.dataset);
            const list = manifestState.childrenByKey.get(ownerId) || [];
            list.push(childId);
            manifestState.childrenByKey.set(ownerId, list);
          });
          const links = Array.isArray(r.links) ? r.links : [];
          links.forEach(targetKey => {
            const targetId = manifestKeyId(targetKey, r.dataset);
            const list = manifestState.childrenByKey.get(childId) || [];
            list.push(targetId);
            manifestState.childrenByKey.set(childId, list);
          });
        });

        const childIds = new Set();
        manifestState.childrenByKey.forEach(list => {
          (list || []).forEach(id => childIds.add(id));
        });
        manifestState.roots = manifestState.resources.filter(r => {
          const id = manifestKeyId(r.key, r.dataset);
          return !childIds.has(id);
        }).sort((a, b) => {
          const ak = a && a.key ? a.key : {};
          const bk = b && b.key ? b.key : {};
          const ans = String(ak.namespace || '');
          const bns = String(bk.namespace || '');
          if (ans !== bns) return ans.localeCompare(bns);
          const akind = String(ak.kind || '');
          const bkind = String(bk.kind || '');
          if (akind !== bkind) return akind.localeCompare(bkind);
          const an = String(ak.name || '');
          const bn = String(bk.name || '');
          return an.localeCompare(bn);
        });
      }

      function loadPinnedManifests() {
        const raw = readStorage(STORAGE_KEYS.pinnedManifests);
        if (!raw) {
          manifestState.pinnedIds = new Set();
          return;
        }
        try {
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            manifestState.pinnedIds = new Set(parsed.map(String));
            return;
          }
        } catch (_) {}
        manifestState.pinnedIds = new Set();
      }

      function persistPinnedManifests() {
        writeStorage(STORAGE_KEYS.pinnedManifests, JSON.stringify(Array.from(manifestState.pinnedIds.values()).slice(-80)));
      }

      function counterpartDataset(ds) {
        const d = String(ds || '').toLowerCase();
        if (d === 'left') return 'right';
        if (d === 'right') return 'left';
        return '';
      }

      function findManifestCounterpart(resource) {
        if (!resource || !resource.key || !resource.dataset) {
          return null;
        }
        const other = counterpartDataset(resource.dataset);
        if (!other) {
          return null;
        }
        const id = manifestKeyId(resource.key, other);
        return manifestState.byKey.get(id) || null;
      }

      function renderManifestBreadcrumbs(resource) {
        if (!manifestBreadcrumbs) {
          return;
        }
        manifestBreadcrumbs.innerHTML = '';
        if (!resource) {
          return;
        }
        const owners = Array.isArray(resource.owners) ? resource.owners : [];
        if (!owners.length) {
          manifestBreadcrumbs.textContent = 'Owner chain: —';
          return;
        }
        const prefix = document.createElement('span');
        prefix.textContent = 'Owner chain: ';
        manifestBreadcrumbs.appendChild(prefix);
        owners.slice(0, 8).forEach((ownerKey, idx) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = (ownerKey.kind || '') + '/' + (ownerKey.name || '');
          btn.addEventListener('click', () => {
            const id = manifestKeyId(ownerKey, resource.dataset);
            const target = manifestState.byKey.get(id) || null;
            if (target) {
              selectManifestResource(target);
            }
          });
          manifestBreadcrumbs.appendChild(btn);
          if (idx < owners.length - 1) {
            const sep = document.createElement('span');
            sep.textContent = ' → ';
            manifestBreadcrumbs.appendChild(sep);
          }
        });
        if (owners.length > 8) {
          const more = document.createElement('span');
          more.textContent = ' …';
          manifestBreadcrumbs.appendChild(more);
        }
      }

      function simpleYamlDiff(a, b) {
        const left = String(a || '').split('\n');
        const right = String(b || '').split('\n');
        const rightSet = new Set(right);
        const leftSet = new Set(left);
        const removed = left.filter(line => !rightSet.has(line));
        const added = right.filter(line => !leftSet.has(line));
        const limit = 220;
        const out = [];
        out.push('--- LEFT');
        out.push('+++ RIGHT');
        out.push('');
        removed.slice(0, limit).forEach(line => out.push('- ' + line));
        if (removed.length > limit) out.push('- … (+' + (removed.length - limit) + ' more)');
        out.push('');
        added.slice(0, limit).forEach(line => out.push('+ ' + line));
        if (added.length > limit) out.push('+ … (+' + (added.length - limit) + ' more)');
        return out.join('\n');
      }

      function matchesManifestSearch(resource, rawQuery) {
        const query = (rawQuery || '').trim().toLowerCase();
        if (!query) return true;
        const key = resource && resource.key ? resource.key : null;
        const ds = (resource && resource.dataset) ? String(resource.dataset) : '';
        const ns = key && key.namespace ? String(key.namespace) : '';
        const name = key && key.name ? String(key.name) : '';
        const kind = key && key.kind ? String(key.kind) : '';
        const group = key && key.group ? String(key.group) : '';
        const terms = query.split(/\s+/).filter(Boolean);
        return terms.every(term => {
          if (term.startsWith('ns:')) return ns.toLowerCase().includes(term.slice(3));
          if (term.startsWith('name:')) return name.toLowerCase().includes(term.slice(5));
          if (term.startsWith('kind:')) return kind.toLowerCase().includes(term.slice(5));
          if (term.startsWith('group:')) return group.toLowerCase().includes(term.slice(6));
          if (term.startsWith('ds:')) return ds.toLowerCase().includes(term.slice(3));
          if (term.includes('/')) {
            return (ns + '/' + name).toLowerCase().includes(term);
          }
          const hay = (ds + ' ' + ns + ' ' + name + ' ' + kind + ' ' + group).toLowerCase();
          return hay.includes(term);
        });
      }

      function updateManifestSummary() {
        if (!manifestSummaryChip) {
          return;
        }
        const total = manifestState.resources.length;
        if (!total) {
          manifestSummaryChip.textContent = 'No manifests';
          return;
        }
        const filtered = manifestState.filtered.length;
        if (filtered === total) {
          manifestSummaryChip.textContent = total + ' resources';
          return;
        }
        manifestSummaryChip.textContent = filtered + ' of ' + total;
      }

      function selectManifestResource(resource) {
        manifestState.selected = resource || null;
        manifestState.selectedCompare = null;
        if (manifestDetailTitle) {
          manifestDetailTitle.textContent = resource ? manifestKeyString(resource.key, resource.dataset) : 'Select a resource';
        }
        renderManifestBreadcrumbs(resource);
        if (manifestLinks) {
          manifestLinks.innerHTML = '';
          if (resource) {
            const key = resource.key || {};
            const kind = String(key.kind || '');
            const name = String(key.name || '');
            const ds = String(resource.dataset || '');
            const related = (kind && name) ? gatherRelatedPods(kind, name, ds) : new Set();
            if (related && related.size) {
              const focus = document.createElement('button');
              focus.type = 'button';
              focus.className = 'cta-button';
              focus.textContent = 'Focus logs';
              focus.addEventListener('click', () => {
                if (!chipFiltersEnabled) {
                  return;
                }
                selectedPods.clear();
                Array.from(related).slice(0, 20).forEach(v => selectedPods.add(v));
                renderPodChips(true);
                updateFilterMeta();
                applyFilters();
              });
              manifestLinks.appendChild(focus);
            }
            const owners = Array.isArray(resource.owners) ? resource.owners : [];
            if (owners.length) {
              const label = document.createElement('span');
              label.className = 'link-label';
              label.textContent = 'Owners';
              manifestLinks.appendChild(label);
              owners.forEach(ownerKey => {
                const id = manifestKeyId(ownerKey, resource.dataset);
                const target = manifestState.byKey.get(id);
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'graph-node-pill';
                btn.textContent = manifestKeyString(ownerKey, resource.dataset);
                if (target) {
                  btn.addEventListener('click', () => selectManifestResource(target));
                } else {
                  btn.disabled = true;
                }
                manifestLinks.appendChild(btn);
              });
            }
            const selfId = manifestKeyId(resource.key, resource.dataset);
            const children = manifestState.childrenByKey.get(selfId) || [];
            if (children.length) {
              const label = document.createElement('span');
              label.className = 'link-label';
              label.textContent = 'Children';
              manifestLinks.appendChild(label);
              children.slice(0, 18).forEach(childId => {
                const target = manifestState.byKey.get(childId);
                if (!target) return;
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'graph-node-pill';
                btn.textContent = manifestKeyString(target.key, target.dataset);
                btn.addEventListener('click', () => selectManifestResource(target));
                manifestLinks.appendChild(btn);
              });
              if (children.length > 18) {
                const more = document.createElement('span');
                more.className = 'chip-inline';
                more.textContent = '+' + (children.length - 18) + ' more';
                manifestLinks.appendChild(more);
              }
            }
          }
        }
        if (manifestYaml) {
          const yaml = (resource && resource.yaml) ? String(resource.yaml) : '';
          if (manifestState.compareMode) {
            const other = findManifestCounterpart(resource);
            manifestState.selectedCompare = other;
            if (other && other.yaml) {
              manifestYaml.textContent = simpleYamlDiff(yaml, String(other.yaml));
            } else {
              manifestYaml.textContent = yaml;
            }
          } else {
            manifestYaml.textContent = yaml;
          }
        }

        if (pinManifestBtn) {
          const id = resource ? manifestKeyId(resource.key, resource.dataset) : '';
          const pinned = id && manifestState.pinnedIds.has(id);
          pinManifestBtn.textContent = pinned ? 'Unpin' : 'Pin';
          pinManifestBtn.disabled = !id;
        }
        if (manifestCompareBtn) {
          const other = resource ? findManifestCounterpart(resource) : null;
          manifestCompareBtn.disabled = !other;
          manifestCompareBtn.textContent = manifestState.compareMode ? 'Compare ✓' : 'Compare';
        }
      }

      function renderManifestList() {
        if (!manifestNodeList) {
          return;
        }
        manifestNodeList.innerHTML = '';
        const items = manifestState.resources.slice();
        if (!items.length) {
          const p = document.createElement('p');
          p.className = 'placeholder';
          p.textContent = 'No manifests';
          manifestNodeList.appendChild(p);
          return;
        }

        const container = document.createElement('div');
        container.className = 'manifest-tree';
        manifestNodeList.appendChild(container);

        const visibleIds = manifestState.visibleIds;
        const isFiltered = !!(manifestState.search || '').trim();

        function nodeVisible(id) {
          if (!isFiltered) {
            return true;
          }
          return visibleIds.has(id);
        }

        function renderNode(resource, depth, visited) {
          if (!resource || !resource.key) {
            return null;
          }
          const id = manifestKeyId(resource.key, resource.dataset);
          if (visited.has(id)) {
            return null;
          }
          visited.add(id);
          const children = manifestState.childrenByKey.get(id) || [];
          const childNodes = [];
          children.forEach(childId => {
            const child = manifestState.byKey.get(childId);
            const rendered = renderNode(child, depth + 1, visited);
            if (rendered) {
              childNodes.push(rendered);
            }
          });

          const keep = nodeVisible(id) || childNodes.length > 0;
          if (!keep) {
            return null;
          }

          const details = document.createElement('details');
          details.open = depth < 1;
          const summary = document.createElement('summary');
          const row = document.createElement('div');
          row.className = 'manifest-row';

          const selectBtn = document.createElement('button');
          selectBtn.type = 'button';
          selectBtn.className = 'meta-pill manifest-name';
          const key = resource.key || {};
          const ns = String(key.namespace || '');
          const name = String(key.name || '');
          selectBtn.textContent = (ns ? ns + '/' : '') + name;
          selectBtn.addEventListener('click', (evt) => {
            evt.preventDefault();
            evt.stopPropagation();
            selectManifestResource(resource);
          });
          row.appendChild(selectBtn);

          const kind = document.createElement('span');
          kind.className = 'manifest-kind';
          kind.textContent = String(key.kind || '');
          row.appendChild(kind);

          if (resource.dataset) {
            const ds = document.createElement('span');
            ds.className = 'chip-inline';
            ds.textContent = String(resource.dataset).toUpperCase();
            row.appendChild(ds);
          }

          summary.appendChild(row);
          details.appendChild(summary);

          if (childNodes.length) {
            const childrenWrap = document.createElement('div');
            childrenWrap.className = 'manifest-children';
            childNodes.forEach(node => childrenWrap.appendChild(node));
            details.appendChild(childrenWrap);
          }
          return details;
        }

        const roots = manifestState.roots.length ? manifestState.roots : manifestState.resources;
        // Pinned nodes at the top.
        const pinned = Array.from(manifestState.pinnedIds.values())
          .map(id => manifestState.byKey.get(id))
          .filter(Boolean);
        if (pinned.length) {
          pinned.forEach(resource => {
            const node = renderNode(resource, 0, new Set());
            if (node) {
              node.open = true;
              container.appendChild(node);
            }
          });
        }
        roots.forEach(resource => {
          const node = renderNode(resource, 0, new Set());
          if (node) {
            container.appendChild(node);
          }
        });
      }

      function applyManifestFilters() {
        manifestState.filtered = manifestState.resources.filter(r => matchesManifestSearch(r, manifestState.search));
        manifestState.visibleIds = new Set();
        const queue = [];
        manifestState.filtered.forEach(r => {
          const id = manifestKeyId(r.key, r.dataset);
          manifestState.visibleIds.add(id);
          queue.push(r);
        });
        // Add ancestors so the tree keeps context while filtering.
        while (queue.length) {
          const r = queue.pop();
          if (!r) continue;
          const owners = Array.isArray(r.owners) ? r.owners : [];
          owners.forEach(ownerKey => {
            const ownerId = manifestKeyId(ownerKey, r.dataset);
            if (!manifestState.visibleIds.has(ownerId)) {
              manifestState.visibleIds.add(ownerId);
              const owner = manifestState.byKey.get(ownerId);
              if (owner) {
                queue.push(owner);
              }
            }
          });
        }
        updateManifestSummary();
        renderManifestList();
      }

	      function renderSessionPanel(meta) {
	        if (!sessionPanel || !meta) {
	          return;
	        }
        if (sessionTitle) {
          sessionTitle.textContent = meta.sessionName || meta.title || 'Capture session';
        }
	        if (sessionSummary) {
	          const parts = [];
	          if (meta.window) {
	            if (meta.window.start && meta.window.end) {
	              parts.push(meta.window.start + ' → ' + meta.window.end);
	            }
	            if (meta.window.duration) {
	              parts.push(meta.window.duration);
	            }
	          }
	          if (meta.context) {
	            parts.push('ctx ' + meta.context);
	          }
	          if (typeof meta.podCount === 'number') {
	            parts.push(meta.podCount + ' pods');
	          }
	          if (meta.podQuery) {
	            parts.push('query ' + meta.podQuery);
	          }
          if (Array.isArray(meta.namespaces) && meta.namespaces.length) {
            parts.push('ns ' + meta.namespaces.join(', '));
          }
          sessionSummary.textContent = parts.join(' · ');
        }
        if (copyReplayCmdBtn) {
          const cmd = meta.commands && meta.commands.replay ? meta.commands.replay : '';
          if (cmd) {
            copyReplayCmdBtn.addEventListener('click', () => copyText(cmd));
          } else {
            copyReplayCmdBtn.setAttribute('hidden', 'true');
          }
        }
	        if (copyShareLinkBtn) {
	          copyShareLinkBtn.addEventListener('click', copyShareLinkNow);
	        }
	        sessionPanel.removeAttribute('hidden');
	        renderSessionStats();
	      }

	      function eventToLogRecord(ev) {
	        if (!ev) {
	          return null;
	        }
        const ts = ev.ts || ev.lastTimestamp || ev.time || '';
        const ns = ev.namespace || ev.involvedNamespace || '';
        const kind = ev.involvedKind || '';
        const name = ev.involvedName || '';
        const typ = ev.type || 'Event';
        const reason = ev.reason || '';
        const msg = ev.message || '';
        const obj = (kind && name) ? (kind + '/' + name) : '';
        const parts = [];
        parts.push(String(typ));
        if (reason) parts.push(String(reason));
        if (obj) parts.push(String(obj));
        if (msg) parts.push(String(msg));
        const line = parts.join(' · ');
        const involved = {
          kind: String(kind || ''),
          name: String(name || ''),
          namespace: String(ns || ''),
          type: String(typ || ''),
          reason: String(reason || ''),
        };
        const podName = (String(kind || '').toLowerCase() === 'pod') ? String(name) : '';
        return {
          ts: String(ts),
          displayTs: String(ts),
          namespace: String(ns),
          pod: podName,
          container: String(kind),
          source: 'event',
          glyph: '◆',
          dataset: ev.dataset || '',
          line: line,
          raw: msg,
          ktl: {
            event: involved,
          },
	        };
	      }

	      function bootstrap() {
	        if (popoutMode) {
	          document.body.classList.add('popout-mode');
	        }

	        initSidebarPersistence();
	        wireEventInspectorButtons();

	        if (captureToggle) {
	          fetchCaptureStatus().then(state => updateCaptureButton(state));
	          captureToggle.addEventListener('click', async () => {
	            try {
	              captureToggle.disabled = true;
	              if (captureState && captureState.running) {
	                await stopCapture();
	              } else {
	                await startCapture();
	              }
	            } catch (err) {
	              console.error('capture error', err);
	            } finally {
	              captureToggle.disabled = false;
	            }
	          });
	        }

	        if (inlineMetricsEnabled && buildMetrics.container) {
	          buildMetrics.container.classList.remove('hidden');
	          setBuildStatus('building');
	        }

	        if (filterToggle) {
	          if (popoutMode) {
	            setFiltersCollapsed(true);
	            filterToggle.setAttribute('hidden', 'true');
	            filterToggle.setAttribute('aria-hidden', 'true');
	          } else if (chipFiltersEnabled) {
	            setFiltersCollapsed(true);
	            filterToggle.removeAttribute('hidden');
	            filterToggle.removeAttribute('aria-hidden');
	            filterToggle.addEventListener('click', () => {
	              setFiltersCollapsed(!filtersCollapsed);
	            });
	          } else {
	            setFiltersCollapsed(false);
	            filterToggle.setAttribute('hidden', 'true');
	            filterToggle.setAttribute('aria-hidden', 'true');
	          }
	        } else {
	          document.body.classList.remove('filters-collapsed');
	        }

	        if (feed) {
	          feed.addEventListener('scroll', handleFeedScroll, { passive: true });
	        }
	        if (resumeAutoScrollBtn) {
	          resumeAutoScrollBtn.addEventListener('click', () => {
	            autoScrollPaused = false;
	            autoScrollEnabled = true;
	            updateAutoScrollUI();
	            maybeScrollToBottom(true);
	          });
	        }
	        if (popoutTrigger) {
	          if (popoutMode) {
	            popoutTrigger.setAttribute('hidden', 'true');
	          } else {
	            popoutTrigger.addEventListener('click', openPopoutWindow);
	          }
	        }

		        initStreamView();

	        if (chipFiltersEnabled) {
	          renderNamespaceChips(true);
	          renderPodChips(true);
	          updateFilterMeta();
	        }
	        updateAutoScrollUI();
	        updateVisibilityStats();
	        updateFeedEmptyState();
	        if (timelineTrack && timelineScrubber) {
	          initTimeline();
	        }

	        if (chipFiltersEnabled && namespaceFilters) {
	          namespaceFilters.addEventListener('click', function(event) {
	            handleChipClick(event, selectedNamespaces);
	          });
	        }
	        if (chipFiltersEnabled && podFilters) {
	          podFilters.addEventListener('click', function(event) {
	            handleChipClick(event, selectedPods);
	          });
	        }
	        if (filterSearch) {
	          filterSearch.addEventListener('keydown', handleSearchKey);
	          filterSearch.addEventListener('input', () => {
	            previewSearchText = String(filterSearch.value || '');
	            scheduleApplyFilters();
	          });
	        }
		        if (findSearch) {
		          findSearch.addEventListener('input', () => {
		            findState.term = String(findSearch.value || '').trim();
		            findState.current = null;
		            updateFindMatches();
		          });
	          findSearch.addEventListener('keydown', (event) => {
	            if (event.key === 'Enter') {
	              event.preventDefault();
	              jumpFind(1);
	            } else if (event.key === 'Escape') {
	              findSearch.value = '';
	              findState.term = '';
	              findState.current = null;
	              updateFindMatches();
	            }
	          });
	        }
	        if (searchChipTray) {
	          searchChipTray.addEventListener('click', handleSearchChipClick);
	        }
	        if (clearFiltersBtn) {
	          clearFiltersBtn.addEventListener('click', clearFilters);
	        }
	        if (resetDefaultsBtn) {
	          resetDefaultsBtn.addEventListener('click', resetToDefaults);
	        }
		        if (copyShareLinkHeaderBtn) {
		          copyShareLinkHeaderBtn.addEventListener('click', copyShareLinkNow);
		        }
		        if (feedEmptyClearBtn) {
		          feedEmptyClearBtn.addEventListener('click', clearAllFocus);
		        }
		        if (feedEmptyCopyBtn) {
		          feedEmptyCopyBtn.addEventListener('click', copyShareLinkNow);
		        }
		        if (captureUploadChooseBtn && captureUploadInput) {
		          captureUploadChooseBtn.addEventListener('click', () => captureUploadInput.click());
		          captureUploadInput.addEventListener('change', () => {
		            const file = captureUploadInput.files && captureUploadInput.files[0] ? captureUploadInput.files[0] : null;
		            if (file) {
		              uploadCaptureArtifact(file);
		            }
		          });
		        }
		        if (findPrevBtn) {
		          findPrevBtn.addEventListener('click', () => jumpFind(-1));
		        }
		        if (findNextBtn) {
		          findNextBtn.addEventListener('click', () => jumpFind(1));
		        }
		        if (errPrevBtn) {
		          errPrevBtn.addEventListener('click', () => jumpToPrev(entry => isErrorOrWarn(entry)));
		        }
		        if (errNextBtn) {
		          errNextBtn.addEventListener('click', () => jumpToNext(entry => isErrorOrWarn(entry)));
		        }
		        if (copySelectedBtn) {
		          copySelectedBtn.addEventListener('click', copySelectedLines);
		        }
		        if (activeFiltersClearBtn) {
		          activeFiltersClearBtn.addEventListener('click', clearAllFocus);
		        }
		        if (activeFiltersCopyBtn) {
		          activeFiltersCopyBtn.addEventListener('click', copyShareLinkNow);
		        }
		        if (contextRadius20Btn) {
		          contextRadius20Btn.addEventListener('click', () => {
		            contextRadius = 20;
		            renderContextLines();
		          });
		        }
		        if (contextRadius50Btn) {
		          contextRadius50Btn.addEventListener('click', () => {
		            contextRadius = 50;
		            renderContextLines();
		          });
		        }
		        if (copyContextLinesBtn) {
		          copyContextLinesBtn.addEventListener('click', () => {
		            if (contextLinesBody) {
		              copyText(String(contextLinesBody.textContent || ''));
		            }
		          });
		        }
		        if (talkersByLinesBtn) {
		          talkersByLinesBtn.addEventListener('click', () => {
		            talkersMode = 'lines';
		            talkersByLinesBtn.classList.add('active');
		            talkersByLinesBtn.setAttribute('aria-pressed', 'true');
		            if (talkersByErrorsBtn) {
		              talkersByErrorsBtn.classList.remove('active');
		              talkersByErrorsBtn.setAttribute('aria-pressed', 'false');
		            }
		            renderTopTalkers();
		          });
		        }
		        if (talkersByErrorsBtn) {
		          talkersByErrorsBtn.addEventListener('click', () => {
		            talkersMode = 'errors';
		            talkersByErrorsBtn.classList.add('active');
		            talkersByErrorsBtn.setAttribute('aria-pressed', 'true');
		            if (talkersByLinesBtn) {
		              talkersByLinesBtn.classList.remove('active');
		              talkersByLinesBtn.setAttribute('aria-pressed', 'false');
		            }
		            renderTopTalkers();
		          });
		        }
		        document.addEventListener('mouseup', () => {
		          draggingSelection = false;
		        }, { passive: true });
		        if (feedEmpty) {
		          feedEmpty.addEventListener('dragover', (event) => {
		            event.preventDefault();
		            feedEmpty.classList.add('dragging');
		          });
		          feedEmpty.addEventListener('dragleave', () => {
		            feedEmpty.classList.remove('dragging');
		          });
		          feedEmpty.addEventListener('drop', (event) => {
		            event.preventDefault();
		            feedEmpty.classList.remove('dragging');
		            const dt = event.dataTransfer;
		            const file = dt && dt.files && dt.files[0] ? dt.files[0] : null;
		            if (file) {
		              uploadCaptureArtifact(file);
		            }
		          });
		        }

	        document.addEventListener('keydown', (event) => {
	          if (event.defaultPrevented) {
	            return;
	          }
	          const tag = (event.target && event.target.tagName) ? String(event.target.tagName).toLowerCase() : '';
	          const inInput = tag === 'input' || tag === 'textarea' || (event.target && event.target.isContentEditable);
	          if (!inInput && event.key === '/') {
	            if (findSearch) {
	              event.preventDefault();
	              findSearch.focus();
	            }
	            return;
	          }
	          if (!inInput && (event.key === 'n' || event.key === 'p')) {
	            if (!findState.term) {
	              return;
	            }
	            event.preventDefault();
	            jumpFind(event.key === 'n' ? 1 : -1);
	            return;
	          }
	          if (event.key === 'Escape') {
	            if (document.activeElement === findSearch) {
	              findSearch.blur();
	            }
	          }
	        });

	        const quickTray = document.querySelector('[aria-label="Quick filters"]');
	        if (quickTray) {
	          quickTray.addEventListener('click', function(event) {
	            const target = event.target.closest('.chip-button');
	            if (!target || !target.dataset) {
	              return;
	            }
	            if (target.disabled) {
	              return;
	            }
	            const name = target.dataset.quickFilter || '';
	            if (!name) {
	              return;
	            }
	            toggleQuickFilter(name);
	          });
	        }

	        const laneTray = document.querySelector('[aria-label="Lane filters"]');
	        if (laneTray) {
	          renderLaneChips();
	          laneTray.addEventListener('click', function(event) {
	            const target = event.target.closest('.chip-button');
	            if (!target || !target.dataset) {
	              return;
	            }
	            const lane = target.dataset.lane || '';
	            if (!lane) {
	              return;
	            }
	            setLaneEnabled(lane, !(lanes[lane] !== false));
	            renderLaneChips();
	            applyFilters();
	          });
	        }

	        if (eventsSearch) {
	          eventsSearch.addEventListener('input', () => {
	            eventsState.search = String(eventsSearch.value || '');
	            renderEventsPanel();
	          });
	        }

	        if (applyTimeRangeBtn) {
	          applyTimeRangeBtn.addEventListener('click', () => {
	            const start = parseTimeInput(timeStartInput ? timeStartInput.value : '');
	            const end = parseTimeInput(timeEndInput ? timeEndInput.value : '');
	            setTimeRange(start, end);
	          });
	        }
	        if (clearTimeRangeBtn) {
	          clearTimeRangeBtn.addEventListener('click', () => setTimeRange(null, null));
	        }
	        if (jumpToTimeBtn) {
	          jumpToTimeBtn.addEventListener('click', () => {
	            const ts = parseTimeInput(jumpToTimeInput ? jumpToTimeInput.value : '');
	            if (!ts) {
	              return;
	            }
	            timelineState.playhead = ts;
	            updateTimelineReadout();
	            scheduleTimelineRender();
	            pauseAnchorLabel = '';
	            scrollFeedToTimestamp(ts, true);
	          });
	        }
	        if (jumpNextErrorBtn) {
	          jumpNextErrorBtn.addEventListener('click', () => jumpToNext(entry => isErrorOrWarn(entry)));
	        }
	        if (jumpNextEventBtn) {
	          jumpNextEventBtn.addEventListener('click', () => jumpToNext(entry => (entry && entry.normalized && entry.normalized.source) === 'event'));
	        }
	        if (jumpNextRestartBtn) {
	          jumpNextRestartBtn.addEventListener('click', () => jumpToNext(entry => entry && entry.flags && entry.flags.restartBump));
	        }
	        if (jumpFirstErrorBtn) {
	          jumpFirstErrorBtn.addEventListener('click', () => jumpToFirst(entry => isError(entry)));
	        }
	        if (jumpFirstWarningBtn) {
	          jumpFirstWarningBtn.addEventListener('click', () => jumpToFirst(entry => isWarning(entry)));
	        }
	        if (jumpFirstRestartBtn) {
	          jumpFirstRestartBtn.addEventListener('click', () => jumpToFirst(entry => entry && entry.flags && entry.flags.restartBump));
	        }

	        if (window.location.hash && window.location.hash.startsWith('#ktl=')) {
	          const encoded = window.location.hash.slice('#ktl='.length);
	          const raw = decodeBase64ToTextUrlSafe(encoded);
	          if (raw) {
	            try {
	              applyShareState(JSON.parse(raw));
	              applyFilters();
	            } catch (err) {
	              console.warn('unable to restore state from hash', err);
	            }
	          }
	        } else {
	          applyFilters();
	        }

	        const sessionB64 = readEmbeddedPayload('ktlSessionMetaB64');
	        if (sessionB64) {
	          const meta = decodeBase64ToJSON(sessionB64);
	          renderSessionPanel(meta);
	        }

	        const eventsB64 = readEmbeddedPayload('ktlK8sEventsB64');
	        if (eventsB64) {
	          const evPayload = decodeBase64ToJSON(eventsB64);
	          if (Array.isArray(evPayload)) {
	            eventsState.items = evPayload.slice();
	            evPayload.forEach(ev => {
	              if (!ev) {
	                return;
	              }
	              const ts = parseTimestamp(ev.ts || ev.lastTimestamp || ev.time);
	              if (ev.involvedKind && String(ev.involvedKind).toLowerCase() === 'pod' && ev.involvedName) {
	                const ns = ev.namespace || ev.involvedNamespace || '';
	                const podValue = makePodValue(ns, ev.involvedName);
	                const ds = ev.dataset || '';
	                const list = k8sEventsByPod.get(eventPodKey(ds, podValue)) || [];
	                list.push(ev);
	                k8sEventsByPod.set(eventPodKey(ds, podValue), list);
	              }
	              const parts = [];
	              if (ev.dataset) parts.push(String(ev.dataset).toUpperCase());
	              if (ev.type) parts.push(ev.type);
	              if (ev.reason) parts.push(ev.reason);
	              const obj = (ev.involvedKind && ev.involvedName) ? (ev.involvedKind + '/' + ev.involvedName) : '';
	              if (obj) parts.push(obj);
	              if (ev.message) parts.push(ev.message);
	              const label = formatTimelineLabel(parts.join(' · '));
	              const sev = (String(ev.type || '').toLowerCase() === 'warning') ? 'fail' : 'info';
	              const meta = {
	                type: ev.type || '',
	                reason: ev.reason || '',
	                message: ev.message || '',
	                dataset: ev.dataset || '',
	                namespace: ev.namespace || ev.involvedNamespace || '',
	                involvedKind: ev.involvedKind || '',
	                involvedName: ev.involvedName || '',
	                involvedNamespace: ev.involvedNamespace || '',
	                pod: (String(ev.involvedKind || '').toLowerCase() === 'pod') ? (ev.involvedName || '') : '',
	              };
	              addTimelineMarker(ts || new Date(), TIMELINE_EVENT_TYPES.K8S_EVENT, label, sev, meta);

	              const record = eventToLogRecord(ev);
	              if (record) {
	                pendingStaticEvents.push(record);
	              }
	            });
	          }
	        }

	        const manifestsB64 = readEmbeddedPayload('ktlK8sManifestsB64');
	        if (manifestsB64) {
	          const payload = decodeBase64ToJSON(manifestsB64);
	          if (payload && Array.isArray(payload.resources)) {
	            manifestState.resources = payload.resources.filter(r => r && r.key && r.yaml);
	          } else if (Array.isArray(payload)) {
	            manifestState.resources = payload.filter(r => r && r.key && r.yaml);
	          }
	          if (manifestState.resources.length && manifestPanel) {
	            manifestPanel.classList.remove('hidden');
	            manifestPanel.removeAttribute('aria-hidden');
	            loadPinnedManifests();
	            buildManifestIndex();
	            manifestState.search = '';
	            applyManifestFilters();
	            if (manifestSearch) {
	              manifestSearch.addEventListener('input', () => {
	                manifestState.search = manifestSearch.value || '';
	                applyManifestFilters();
	              });
	            }
	            if (pinManifestBtn) {
	              pinManifestBtn.addEventListener('click', () => {
	                const r = manifestState.selected;
	                if (!r || !r.key) {
	                  return;
	                }
	                const id = manifestKeyId(r.key, r.dataset);
	                if (manifestState.pinnedIds.has(id)) {
	                  manifestState.pinnedIds.delete(id);
	                } else {
	                  manifestState.pinnedIds.add(id);
	                }
	                persistPinnedManifests();
	                renderManifestList();
	                selectManifestResource(r);
	              });
	            }
	            if (manifestShowPodsBtn) {
	              manifestShowPodsBtn.addEventListener('click', () => {
	                const r = manifestState.selected;
	                if (!r || !r.key) return;
	                const kind = String(r.key.kind || '');
	                const name = String(r.key.name || '');
	                const ds = String(r.dataset || '');
	                const related = (kind && name) ? gatherRelatedPods(kind, name, ds) : new Set();
	                if (!related.size) {
	                  return;
	                }
	                if (chipFiltersEnabled) {
	                  selectedPods.clear();
	                  Array.from(related).slice(0, 20).forEach(v => selectedPods.add(v));
	                  renderPodChips(true);
	                  updateFilterMeta();
	                  applyFilters();
	                }
	              });
	            }
	            if (manifestShowEventsBtn) {
	              manifestShowEventsBtn.addEventListener('click', () => {
	                const r = manifestState.selected;
	                if (!r || !r.key) return;
	                const kind = String(r.key.kind || '');
	                const name = String(r.key.name || '');
	                const ds = String(r.dataset || '');
	                const related = (kind && name) ? gatherRelatedPods(kind, name, ds) : new Set();
	                if (chipFiltersEnabled) {
	                  selectedPods.clear();
	                  Array.from(related).slice(0, 200).forEach(v => selectedPods.add(v));
	                  renderPodChips(true);
	                  updateFilterMeta();
	                } else {
	                  clearSearchChips();
	                  Array.from(related).slice(0, 20).forEach(v => {
	                    const decoded = decodePodValue(v);
	                    if (decoded && decoded.namespace && decoded.pod) {
	                      addSearchChip('ns:' + decoded.namespace);
	                      addSearchChip('pod:' + decoded.pod);
	                    }
	                  });
	                }
	                applyFilters();
	                if (eventsPanel) {
	                  eventsPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
	                }
	              });
	            }
	            if (manifestCompareBtn) {
	              manifestCompareBtn.addEventListener('click', () => {
	                if (!manifestState.selected) return;
	                const other = findManifestCounterpart(manifestState.selected);
	                if (!other) return;
	                manifestState.compareMode = !manifestState.compareMode;
	                selectManifestResource(manifestState.selected);
	              });
	            }
	            if (copyManifestYamlBtn) {
	              copyManifestYamlBtn.addEventListener('click', () => {
	                if (manifestYaml) {
	                  copyText(manifestYaml.textContent || '');
	                }
	              });
	            }
	            selectManifestResource(manifestState.resources[0] || null);
	          }
	        }

		        captureID = document.body && document.body.dataset ? (document.body.dataset.captureId || '') : '';
			        if (captureID) {
			          isCaptureMode = true;
			          MAX_ENTRIES = 8000;
			          statusChip.textContent = 'Capture';
			          loadCaptureMetaAndTimeline()
			            .then(() => Promise.all([loadCaptureEvents().catch(() => {}), loadCaptureManifests().catch(() => {})]))
			            .then(() => loadCaptureLogsPage(true, 'tail'))
			            .catch(err => {
			              console.error('capture load failed', err);
			              statusChip.textContent = 'Error';
			            });
			          return;
			        }

		        const forcedStatic = document.body && document.body.dataset && document.body.dataset.ktlStatic === 'true';
		        const hasStaticEl = !!document.getElementById('ktlStaticLogsB64');
		        const staticB64 = readEmbeddedPayload('ktlStaticLogsB64');
		        if (forcedStatic || hasStaticEl) {
		          isStaticMode = true;
		          MAX_ENTRIES = 40000;
		          statusChip.textContent = 'Static';
	          const text = decodeBase64ToText(staticB64);
	          const lines = text.split('\n');
	          for (let i = 0; i < lines.length; i++) {
	            const line = lines[i].trim();
	            if (!line) {
	              continue;
	            }
	            try {
	              const data = JSON.parse(line);
	              pendingStaticRecords.push(data);
	            } catch (err) {
	              console.error('static render error', err);
	            }
	          }
	          const combined = pendingStaticRecords.concat(pendingStaticEvents);
	          combined.sort((a, b) => {
	            const at = parseTimestamp((a && (a.ts || a.timestamp)) || '') || new Date(0);
	            const bt = parseTimestamp((b && (b.ts || b.timestamp)) || '') || new Date(0);
	            const diff = at.getTime() - bt.getTime();
	            if (diff !== 0) {
	              return diff;
	            }
	            const as = (a && a.source) ? String(a.source) : '';
	            const bs = (b && b.source) ? String(b.source) : '';
	            if (as === bs) {
	              return 0;
	            }
	            // Prefer events after logs at identical timestamps.
	            if (as === 'event') return 1;
	            if (bs === 'event') return -1;
	            return as.localeCompare(bs);
	          });
	          for (let i = 0; i < combined.length; i++) {
	            const data = combined[i];
	            updateStats(data);
	            appendEntry(data);
	          }
	          finalizeDiffPanel();
		        } else {
		          connect();
		        }
		      }

	      bootstrap();
    })();
  </script>
</body>
</html>
