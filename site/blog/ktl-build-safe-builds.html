<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Safe Docker Builds with ktl build</title>
    <style>
      :root {
        --ink: #f2ede3;
        --text: #d8d2c7;
        --muted: #a49c90;
        --paper: #070709;
        --panel: #0f1013;
        --line: rgba(200, 179, 138, 0.2);
        --line-strong: rgba(200, 179, 138, 0.38);
        --accent: #c8b38a;
        --code-bg: #0d0e11;
        --code-text: #f3efe6;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background:
          radial-gradient(circle at 0% 0%, rgba(200, 179, 138, 0.12), transparent 34%),
          radial-gradient(circle at 100% 100%, rgba(200, 179, 138, 0.06), transparent 42%),
          linear-gradient(180deg, #050507 0%, var(--paper) 48%, #050507 100%);
        color: var(--text);
      }

      body {
        font-family: "Avenir Next", "Avenir", "Helvetica Neue", Helvetica, Arial, sans-serif;
        line-height: 1.72;
        letter-spacing: 0.005em;
      }

      .frame {
        max-width: 1040px;
        margin: 0 auto;
        padding: 46px 24px 90px;
      }

      .article {
        background: linear-gradient(180deg, rgba(20, 21, 24, 0.96), rgba(13, 14, 17, 0.96));
        border: 1px solid var(--line);
        border-radius: 26px;
        box-shadow:
          0 30px 70px rgba(0, 0, 0, 0.48),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      .hero {
        position: relative;
        padding: 42px 48px 34px;
        border-bottom: 1px solid var(--line);
        background:
          radial-gradient(circle at 18% 0%, rgba(200, 179, 138, 0.14), transparent 46%),
          linear-gradient(165deg, rgba(29, 30, 34, 0.96) 0%, rgba(20, 21, 25, 0.92) 62%, rgba(13, 14, 17, 0.92) 100%);
      }

      .hero::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(200, 179, 138, 0.6), transparent);
      }

      .back {
        display: inline-block;
        margin-bottom: 18px;
        text-decoration: none;
        color: var(--muted);
        font-size: 0.86rem;
        letter-spacing: 0.11em;
        text-transform: uppercase;
      }

      .back:hover {
        color: var(--accent);
      }

      h1 {
        margin: 0;
        color: var(--ink);
        font-family: "Iowan Old Style", "Baskerville", "Times New Roman", serif;
        font-weight: 500;
        font-size: clamp(2rem, 5.5vw, 3.15rem);
        line-height: 1.14;
        letter-spacing: 0.01em;
        max-width: 18ch;
        text-wrap: balance;
      }

      h1 code {
        color: var(--accent);
        background: rgba(200, 179, 138, 0.1);
        border-color: rgba(200, 179, 138, 0.2);
      }

      .deck {
        margin: 14px 0 0;
        max-width: 60ch;
        color: #c6bfb2;
        font-size: 1rem;
      }

      .hero-links {
        margin-top: 18px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .hero-link {
        text-decoration: none;
        color: var(--accent);
        border: 1px solid rgba(200, 179, 138, 0.34);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.82rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hero-link:hover {
        border-color: rgba(200, 179, 138, 0.65);
        color: #f0e6d4;
      }

      .meta {
        margin-top: 16px;
        font-size: 0.84rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .content {
        padding: 38px 48px 52px;
      }

      h2 {
        margin: 56px 0 12px;
        padding-top: 14px;
        border-top: 1px solid var(--line);
        font-family: "Iowan Old Style", "Baskerville", "Times New Roman", serif;
        font-weight: 500;
        font-size: 1.62rem;
        line-height: 1.25;
        color: var(--ink);
        letter-spacing: 0.008em;
      }

      p {
        margin: 0 0 16px;
        font-size: 1.02rem;
        max-width: 68ch;
      }

      ul {
        margin: 10px 0 18px;
        padding-left: 24px;
        max-width: 68ch;
      }

      li {
        margin-bottom: 8px;
      }

      code {
        font-family: "SF Mono", "Menlo", "Consolas", monospace;
        font-size: 0.93em;
        background: rgba(200, 179, 138, 0.1);
        color: #f0e8da;
        border: 1px solid rgba(200, 179, 138, 0.2);
        border-radius: 6px;
        padding: 2px 6px;
      }

      a {
        color: var(--accent);
        text-underline-offset: 3px;
      }

      a:hover {
        color: #f1e6d2;
      }

      .code-title {
        margin: 16px 0 8px;
        font-size: 0.78rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .compare {
        margin: 20px 0 26px;
        border: 1px solid var(--line-strong);
        border-radius: 14px;
        overflow: hidden;
        max-width: 80ch;
      }

      .compare table {
        width: 100%;
        border-collapse: collapse;
        font-size: 0.97rem;
      }

      .compare th,
      .compare td {
        padding: 12px 14px;
        border-bottom: 1px solid var(--line);
        text-align: left;
        vertical-align: top;
      }

      .compare th {
        color: var(--ink);
        background: rgba(200, 179, 138, 0.08);
      }

      .compare tr:last-child td {
        border-bottom: 0;
      }

      .when {
        color: #bfb6a8;
        font-size: 0.92rem;
      }

      pre {
        margin: 16px 0 20px;
        border-radius: 14px;
        border: 1px solid rgba(200, 179, 138, 0.22);
        background: linear-gradient(180deg, #15161a, var(--code-bg));
        color: var(--code-text);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.34);
        overflow-x: auto;
        padding: 14px 16px;
        max-width: 68ch;
      }

      pre code {
        background: transparent;
        border: 0;
        padding: 0;
        color: inherit;
      }

      .demo {
        margin: 16px 0 28px;
        border: 1px solid var(--line-strong);
        border-radius: 16px;
        overflow: hidden;
        background: #090a0c;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.38);
        max-width: 80ch;
      }

      .demo img {
        display: block;
        width: 100%;
        aspect-ratio: 16 / 9;
        object-fit: contain;
        background: #060709;
      }

      .demo figcaption {
        margin: 0;
        padding: 10px 12px 12px;
        font-size: 0.9rem;
        color: #b9b2a5;
        border-top: 1px solid rgba(200, 179, 138, 0.2);
      }

      .note {
        margin-top: 24px;
        padding: 14px 16px;
        border: 1px solid var(--line-strong);
        border-radius: 12px;
        background: rgba(200, 179, 138, 0.08);
        color: #e8e1d3;
        max-width: 68ch;
      }

      .article {
        animation: article-in 420ms ease-out both;
      }

      .hero,
      .content h2,
      .content p,
      .content ul,
      .content .code-title,
      .content pre,
      .content .demo,
      .content .note {
        animation: rise-in 260ms ease-out both;
      }

      @keyframes article-in {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @keyframes rise-in {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @media (max-width: 860px) {
        .frame {
          padding: 18px 16px 42px;
        }

        .article {
          border-radius: 18px;
        }

        .hero {
          padding: 26px 20px 22px;
        }

        .content {
          padding: 24px 20px 34px;
        }

        h2 {
          font-size: 1.38rem;
          margin-top: 42px;
        }

        p,
        li {
          font-size: 0.98rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="frame">
      <article class="article">
        <header class="hero">
          <a class="back" href="./index.html">Back to blog index</a>
          <h1>Build Docker Images Safely with <code>ktl build</code></h1>
          <p class="deck">
            A direct guide to safer image builds, with sandboxed execution, stronger policy controls, and
            traceable build outputs.
          </p>
          <p class="meta">Published February 13, 2026 Â· kubekattle engineering</p>
          <div class="hero-links">
            <a class="hero-link" href="https://kubekattle.github.io/ktl/">ktl docs</a>
            <a class="hero-link" href="https://kubekattle.github.io/ktl/">command reference</a>
          </div>
        </header>

        <section class="content">
          <p>
            Image builds run code. That means every Docker build is both a packaging step and a security step.
            If the builder is too open, a bad dependency or a wrong script can reach places it should not.
          </p>

          <p>
            <code>ktl build</code> keeps the workflow familiar but adds controls: sandboxing, policy checks,
            secret leak checks, attestation output, and cache diagnostics.
          </p>

          <p>
            This guide shows how these controls work in practice, with direct commands and demos you can run.
          </p>
          <p>
            Full docs: <a href="https://kubekattle.github.io/ktl/">https://kubekattle.github.io/ktl/</a>.
          </p>

          <h2>Quick comparison</h2>
          <div class="compare">
            <table>
              <thead>
                <tr>
                  <th>Capability</th>
                  <th>default docker build</th>
                  <th>ktl build</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Sandboxing</td>
                  <td>Not built in as a first-class build flag.</td>
                  <td>Built-in sandbox flow on Linux with runtime policy and diagnostics.</td>
                </tr>
                <tr>
                  <td>Policy gates</td>
                  <td>Manual integration required.</td>
                  <td><code>--policy</code> and <code>--policy-mode enforce</code> in the build command.</td>
                </tr>
                <tr>
                  <td>Secret checks</td>
                  <td>Usually external tooling.</td>
                  <td><code>--secrets warn|block|off</code> built in.</td>
                </tr>
                <tr>
                  <td>Attestations</td>
                  <td>Extra setup and tooling.</td>
                  <td><code>--sbom</code>, <code>--provenance</code>, <code>--attest-dir</code> integrated.</td>
                </tr>
                <tr>
                  <td>Cache report</td>
                  <td>No opinionated summary by default.</td>
                  <td><code>--cache-intel</code> shows misses, slow steps, and hit ratio.</td>
                </tr>
              </tbody>
            </table>
          </div>

          <h2>Why safe builds are now mandatory</h2>
          <p>
            A lot of CI systems still treat image build stages as harmless plumbing. In reality, build jobs are one
            of the highest-risk points in a pipeline because they execute untrusted or semi-trusted code on your
            infrastructure. Typical pitfalls include broad host mounts, permissive environment variables, accidental
            credential exposure, unrestricted egress, and weak traceability for what got shipped.
          </p>

          <p>
            When an incident happens, the painful questions usually look the same: Which dependency was pulled?
            Which script ran? Could it access host-only files? Did we produce a bill of materials? Can we prove the
            provenance of this artifact? <code>ktl build</code> answers those questions with explicit controls and outputs
            instead of ad hoc scripts.
          </p>

          <h2>How sandboxing works with nsjail</h2>
          <p>
            On Linux, <code>ktl build</code> can run inside a sandbox runtime (nsjail) with a policy file. Think of this as
            giving the build process a controlled room to work in. It gets only the mounts and runtime capabilities
            it needs, rather than broad host access. That means filesystem visibility is explicit, and high-risk
            assumptions become visible quickly.
          </p>

          <p>
            A practical detail that teams appreciate: <code>ktl build sandbox doctor</code> exists to verify the environment
            before running a real build. It checks mount/bind/network probes so you can confirm the sandbox is
            healthy. Then, when you run the build with <code>--sandbox-logs</code>, you see the sandbox lifecycle in
            prefixed logs. This is important because strict policies without diagnostics are hard to operate.
          </p>

          <p>
            In our lab environment we used an nsjail wrapper for mount API compatibility and then executed sandboxed
            builds with explicit flags such as <code>--sandbox</code>, <code>--sandbox-config</code>, and <code>--sandbox-bind-home</code>
            (when builder bootstrap needed home directory access). The key point is not one exact flag combo; the key
            point is that access is intentional, reviewable, and debuggable.
          </p>

          <h2>Other useful ktl build features</h2>
          <p>
            Sandbox is only one part of <code>ktl build</code>. These features are useful in real projects and are worth
            using together.
          </p>

          <ul>
            <li><code>--hermetic</code> (or <code>--locked</code>) to reduce network access and enforce pinned bases.<br /><span class="when">When to use: reproducible CI builds and dependency-sensitive repos.</span></li>
            <li><code>--secure</code> as a shortcut preset for stricter builds.<br /><span class="when">When to use: release pipelines where you want safer defaults in one flag.</span></li>
            <li><code>--policy</code> and <code>--policy-mode enforce</code> to block builds that fail your rules.<br /><span class="when">When to use: team-wide guardrails that must fail fast.</span></li>
            <li><code>--secrets block</code> to fail on detected secret-leak risks.<br /><span class="when">When to use: repos with many env-based credentials or generated config files.</span></li>
            <li><code>--capture ./ktl-capture.sqlite</code> to keep a build event timeline for later debugging.<br /><span class="when">When to use: flaky CI builds or intermittent buildkit issues.</span></li>
            <li><code>--ws-listen :9085</code> to stream raw build events to external viewers.<br /><span class="when">When to use: remote observers or custom dashboards.</span></li>
            <li><code>--cache-intel</code> for a fast summary of cache misses and slow steps.<br /><span class="when">When to use: ongoing Dockerfile optimization work.</span></li>
          </ul>

          <p class="code-title">Command</p>
<pre><code>ktl build . \
  -t ghcr.io/acme/app:dev \
  --secure \
  --policy ./policy \
  --secrets block \
  --capture ./ktl-capture.sqlite \
  --cache-intel</code></pre>

          <p>
            You do not need to turn on everything at once. Start with one or two controls, run it in CI for a few days,
            then tighten the defaults.
          </p>

          <h2>Real failure example</h2>
          <p>
            Example: a build fails because secret checks are in blocking mode and a risky pattern is detected.
          </p>
          <p class="code-title">Failure output</p>
<pre><code>Error: secrets scan failed (mode=block)
- rule: possible-secret-in-build-arg
- location: Dockerfile:12
- value: ARG AWS_SECRET_ACCESS_KEY=...</code></pre>
          <p class="code-title">Fix</p>
<pre><code># move secret usage to BuildKit secret mounts and keep scans in blocking mode
ktl build . \
  -t ghcr.io/acme/app:dev \
  --secret AWS_SECRET_ACCESS_KEY \
  --secrets block</code></pre>

          <h2>Copy/paste starters</h2>
          <p class="code-title">Dev build (fast feedback)</p>
<pre><code>ktl build . -t ghcr.io/acme/app:dev --cache-intel --output logs</code></pre>
          <p class="code-title">Strict CI build</p>
<pre><code>ktl build . -t ghcr.io/acme/app:ci --secure --policy ./policy --secrets block --cache-intel</code></pre>
          <p class="code-title">Attested release build</p>
<pre><code>ktl build . \
  -t ghcr.io/acme/app:release \
  --oci \
  --sbom \
  --provenance \
  --attest-dir ./out-attest \
  --push</code></pre>

          <h2>Demo Showcase 1: Sandbox doctor + sandboxed build</h2>
          <p>
            The first demo establishes trust in the runtime itself. We start by running doctor probes against the
            selected sandbox policy and runtime binary. Then we run a real Dockerfile build in sandbox mode and stream
            sandbox logs to show exactly what is mounted and executed.
          </p>

          <p class="code-title">Command</p>
<pre><code>ktl build sandbox doctor \
  --sandbox-bin /usr/local/bin/nsjail-oldmnt \
  --sandbox-config sandbox/linux-ci.cfg

ktl build testdata/build/dockerfiles/basic \
  -t local/ktl-sandbox-demo:latest \
  --sandbox \
  --sandbox-bin /usr/local/bin/nsjail-oldmnt \
  --sandbox-config sandbox/linux-ci.cfg \
  --sandbox-bind-home \
  --sandbox-logs \
  --output logs</code></pre>

          <p>
            This demo shows both parts clearly: security controls and a successful build. You can see sandbox lifecycle
            events and still end up with a usable image.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-sandbox.gif" alt="Sandbox doctor and sandboxed ktl build output" loading="lazy" />
            <figcaption>Sandbox doctor checks the runtime, then build logs show the sandbox lifecycle and final image output.</figcaption>
          </figure>

          <h2>Demo Showcase 2: Cache intelligence (cold vs warm)</h2>
          <p>
            Security alone is not enough; teams still need speed. The second demo highlights cache intelligence by
            running the same build twice and comparing results. The first run shows more misses and slow export steps.
            The second run surfaces improved hit ratios and faster path reuse.
          </p>

          <p class="code-title">Command</p>
<pre><code>KTL_SANDBOX_DISABLE=1 ktl build testdata/build/dockerfiles/metadata \
  -t local/ktl-cache-demo:latest \
  --output logs \
  --cache-intel \
  --cache-intel-top 5

# run again with the same command to highlight warm-cache behavior</code></pre>

          <p>
            The cache report is especially useful in reviews because it calls out miss reasons and slow steps instead of
            leaving people to guess why a build got slower. This is the bridge between platform engineering and app teams:
            you can discuss concrete numbers and concrete Dockerfile improvements.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-cache-intel.gif" alt="ktl build cache intelligence output" loading="lazy" />
            <figcaption>Cache intelligence calls out misses, slow steps, and hit ratio so Dockerfile changes are easier to prioritize.</figcaption>
          </figure>

          <h2>Demo Showcase 3: SBOM + provenance attestations</h2>
          <p>
            The third demo focuses on artifact trust. We build with OCI output and write attestations to a dedicated
            directory while enabling SBOM and provenance generation. After the build, we list the produced JSON files
            and inspect the provenance document.
          </p>

          <p class="code-title">Command</p>
<pre><code>KTL_SANDBOX_DISABLE=1 ktl build testdata/build/dockerfiles/basic \
  -t local/ktl-attest-demo:latest \
  --output logs \
  --oci \
  --attest-dir ./out-attest \
  --sbom \
  --provenance

ls -lh ./out-attest</code></pre>

          <p>
            This moves the build from \"we produced an image\" to \"we can explain what is inside it and how it was built.\"
            SBOM gives a component inventory, and provenance records build details in machine-readable form.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-attestations.gif" alt="ktl build SBOM and provenance attestation output" loading="lazy" />
            <figcaption>Build output writes SBOM and provenance files, making the image contents and build history traceable.</figcaption>
          </figure>

          <h2>Pragmatic rollout strategy</h2>
          <p>
            If you are adopting this in an existing org, do it in layers. Start with one representative service and one
            sandbox profile. Validate with sandbox doctor. Turn on sandbox logs while tuning. Introduce cache intel reports
            for visibility. Then add SBOM/provenance outputs to release gates. Finally, codify policy and artifacts in PR
            templates so the process becomes routine.
          </p>

          <p>
            This approach avoids trying to enforce everything at once. Add controls in layers, keep the output visible,
            and tune the process as you go.
          </p>

          <h2>Final take</h2>
          <p>
            <code>ktl build</code> is not just a way to build container images. It gives you safer execution,
            better diagnostics, cache visibility, and artifact evidence in one flow.
          </p>

          <p class="note">
            Fast builds matter. Fast builds with clear security controls and traceable output matter more.
          </p>
          <p>
            For flags, examples, and updates, check <a href="https://kubekattle.github.io/ktl/">the ktl docs</a>.
          </p>
          <p>
            Specific references:
            <a href="https://github.com/kubekattle/ktl/blob/main/README.md">build flags</a>,
            <a href="https://github.com/kubekattle/ktl/blob/main/docs/config-atlas.md">sandbox config</a>,
            <a href="https://github.com/kubekattle/ktl/blob/main/docs/troubleshooting.md">policy and troubleshooting</a>,
            <a href="https://github.com/kubekattle/ktl/blob/main/AGENTS.md">attestation and release flow</a>.
          </p>
        </section>
      </article>
    </main>
  </body>
</html>
