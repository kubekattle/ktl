<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Safe Docker Builds with ktl build</title>
    <style>
      :root {
        --ink: #f2ede3;
        --text: #d8d2c7;
        --muted: #a49c90;
        --paper: #070709;
        --panel: #0f1013;
        --line: rgba(200, 179, 138, 0.2);
        --line-strong: rgba(200, 179, 138, 0.38);
        --accent: #c8b38a;
        --code-bg: #0d0e11;
        --code-text: #f3efe6;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background:
          radial-gradient(circle at 0% 0%, rgba(200, 179, 138, 0.12), transparent 34%),
          radial-gradient(circle at 100% 100%, rgba(200, 179, 138, 0.06), transparent 42%),
          linear-gradient(180deg, #050507 0%, var(--paper) 48%, #050507 100%);
        color: var(--text);
      }

      body {
        font-family: "Avenir Next", "Avenir", "Helvetica Neue", Helvetica, Arial, sans-serif;
        line-height: 1.72;
        letter-spacing: 0.005em;
      }

      .frame {
        max-width: 1040px;
        margin: 0 auto;
        padding: 46px 24px 90px;
      }

      .article {
        background: linear-gradient(180deg, rgba(20, 21, 24, 0.96), rgba(13, 14, 17, 0.96));
        border: 1px solid var(--line);
        border-radius: 26px;
        box-shadow:
          0 30px 70px rgba(0, 0, 0, 0.48),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        overflow: hidden;
      }

      .hero {
        position: relative;
        padding: 42px 48px 34px;
        border-bottom: 1px solid var(--line);
        background:
          radial-gradient(circle at 18% 0%, rgba(200, 179, 138, 0.14), transparent 46%),
          linear-gradient(165deg, rgba(29, 30, 34, 0.96) 0%, rgba(20, 21, 25, 0.92) 62%, rgba(13, 14, 17, 0.92) 100%);
      }

      .hero::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, rgba(200, 179, 138, 0.6), transparent);
      }

      .back {
        display: inline-block;
        margin-bottom: 18px;
        text-decoration: none;
        color: var(--muted);
        font-size: 0.86rem;
        letter-spacing: 0.11em;
        text-transform: uppercase;
      }

      .back:hover {
        color: var(--accent);
      }

      h1 {
        margin: 0;
        color: var(--ink);
        font-family: "Iowan Old Style", "Baskerville", "Times New Roman", serif;
        font-weight: 500;
        font-size: clamp(2rem, 5.5vw, 3.15rem);
        line-height: 1.14;
        letter-spacing: 0.01em;
        max-width: 18ch;
        text-wrap: balance;
      }

      h1 code {
        color: var(--accent);
        background: rgba(200, 179, 138, 0.1);
        border-color: rgba(200, 179, 138, 0.2);
      }

      .deck {
        margin: 14px 0 0;
        max-width: 60ch;
        color: #c6bfb2;
        font-size: 1rem;
      }

      .hero-links {
        margin-top: 18px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      .hero-link {
        text-decoration: none;
        color: var(--accent);
        border: 1px solid rgba(200, 179, 138, 0.34);
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.82rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .hero-link:hover {
        border-color: rgba(200, 179, 138, 0.65);
        color: #f0e6d4;
      }

      .meta {
        margin-top: 16px;
        font-size: 0.84rem;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--muted);
      }

      .content {
        padding: 38px 48px 52px;
      }

      h2 {
        margin: 56px 0 12px;
        padding-top: 14px;
        border-top: 1px solid var(--line);
        font-family: "Iowan Old Style", "Baskerville", "Times New Roman", serif;
        font-weight: 500;
        font-size: 1.62rem;
        line-height: 1.25;
        color: var(--ink);
        letter-spacing: 0.008em;
      }

      p {
        margin: 0 0 16px;
        font-size: 1.02rem;
        max-width: 68ch;
      }

      ul {
        margin: 10px 0 18px;
        padding-left: 24px;
        max-width: 68ch;
      }

      li {
        margin-bottom: 8px;
      }

      code {
        font-family: "SF Mono", "Menlo", "Consolas", monospace;
        font-size: 0.93em;
        background: rgba(200, 179, 138, 0.1);
        color: #f0e8da;
        border: 1px solid rgba(200, 179, 138, 0.2);
        border-radius: 6px;
        padding: 2px 6px;
      }

      a {
        color: var(--accent);
        text-underline-offset: 3px;
      }

      a:hover {
        color: #f1e6d2;
      }

      .code-title {
        margin: 16px 0 8px;
        font-size: 0.78rem;
        letter-spacing: 0.16em;
        text-transform: uppercase;
        color: var(--muted);
      }

      pre {
        margin: 16px 0 20px;
        border-radius: 14px;
        border: 1px solid rgba(200, 179, 138, 0.22);
        background: linear-gradient(180deg, #15161a, var(--code-bg));
        color: var(--code-text);
        box-shadow: 0 16px 34px rgba(0, 0, 0, 0.34);
        overflow-x: auto;
        padding: 14px 16px;
        max-width: 68ch;
      }

      pre code {
        background: transparent;
        border: 0;
        padding: 0;
        color: inherit;
      }

      .demo {
        margin: 16px 0 28px;
        border: 1px solid var(--line-strong);
        border-radius: 16px;
        overflow: hidden;
        background: #090a0c;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.38);
        max-width: 80ch;
      }

      .demo img {
        display: block;
        width: 100%;
        aspect-ratio: 16 / 9;
        object-fit: contain;
        background: #060709;
      }

      .demo figcaption {
        margin: 0;
        padding: 10px 12px 12px;
        font-size: 0.9rem;
        color: #b9b2a5;
        border-top: 1px solid rgba(200, 179, 138, 0.2);
      }

      .note {
        margin-top: 24px;
        padding: 14px 16px;
        border: 1px solid var(--line-strong);
        border-radius: 12px;
        background: rgba(200, 179, 138, 0.08);
        color: #e8e1d3;
        max-width: 68ch;
      }

      .article {
        animation: article-in 420ms ease-out both;
      }

      .hero,
      .content h2,
      .content p,
      .content ul,
      .content .code-title,
      .content pre,
      .content .demo,
      .content .note {
        animation: rise-in 260ms ease-out both;
      }

      @keyframes article-in {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @keyframes rise-in {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
      }

      @media (max-width: 860px) {
        .frame {
          padding: 18px 16px 42px;
        }

        .article {
          border-radius: 18px;
        }

        .hero {
          padding: 26px 20px 22px;
        }

        .content {
          padding: 24px 20px 34px;
        }

        h2 {
          font-size: 1.38rem;
          margin-top: 42px;
        }

        p,
        li {
          font-size: 0.98rem;
        }
      }
    </style>
  </head>
  <body>
    <main class="frame">
      <article class="article">
        <header class="hero">
          <a class="back" href="./index.html">Back to blog index</a>
          <h1>Build Docker Images Safely with <code>ktl build</code></h1>
          <p class="deck">
            A direct guide to safer image builds, with sandboxed execution, stronger policy controls, and
            traceable build outputs.
          </p>
          <p class="meta">Published February 13, 2026 Â· kubekattle engineering</p>
          <div class="hero-links">
            <a class="hero-link" href="https://kubekattle.github.io/ktl/">ktl docs</a>
            <a class="hero-link" href="https://kubekattle.github.io/ktl/">command reference</a>
          </div>
        </header>

        <section class="content">
          <p>
            Fast image builds are easy to love. They make release cycles shorter, reduce local waiting,
            and keep teams moving. But speed alone is not enough anymore. In modern delivery pipelines,
            every build step is also a security event. A Dockerfile does not only define an artifact; it
            executes code, downloads dependencies, runs shell commands, and potentially touches secrets,
            network paths, and host resources. If that process is too permissive, one compromised dependency
            or one accidental script can become a supply-chain problem.
          </p>

          <p>
            <code>ktl build</code> helps here. You keep a normal build flow, but add isolation, policy checks,
            debugging output, and metadata about what was produced.
          </p>

          <p>
            This post explains how sandboxed builds work with nsjail, then shows three demos:
            sandboxed build flow, cache intelligence, and SBOM/provenance attestations.
          </p>
          <p>
            Full docs: <a href="https://kubekattle.github.io/ktl/">https://kubekattle.github.io/ktl/</a>.
          </p>

          <h2>Why safe builds are now mandatory</h2>
          <p>
            A lot of CI systems still treat image build stages as harmless plumbing. In reality, build jobs are one
            of the highest-risk points in a pipeline because they execute untrusted or semi-trusted code on your
            infrastructure. Typical pitfalls include broad host mounts, permissive environment variables, accidental
            credential exposure, unrestricted egress, and weak traceability for what got shipped.
          </p>

          <p>
            When an incident happens, the painful questions usually look the same: Which dependency was pulled?
            Which script ran? Could it access host-only files? Did we produce a bill of materials? Can we prove the
            provenance of this artifact? <code>ktl build</code> answers those questions with explicit controls and outputs
            instead of ad hoc scripts.
          </p>

          <h2>How sandboxing works with nsjail</h2>
          <p>
            On Linux, <code>ktl build</code> can run inside a sandbox runtime (nsjail) with a policy file. Think of this as
            giving the build process a controlled room to work in. It gets only the mounts and runtime capabilities
            it needs, rather than broad host access. That means filesystem visibility is explicit, and high-risk
            assumptions become visible quickly.
          </p>

          <p>
            A practical detail that teams appreciate: <code>ktl build sandbox doctor</code> exists to verify the environment
            before running a real build. It checks mount/bind/network probes so you can confirm the sandbox is
            healthy. Then, when you run the build with <code>--sandbox-logs</code>, you see the sandbox lifecycle in
            prefixed logs. This is important because strict policies without diagnostics are hard to operate.
          </p>

          <p>
            In our lab environment we used an nsjail wrapper for mount API compatibility and then executed sandboxed
            builds with explicit flags such as <code>--sandbox</code>, <code>--sandbox-config</code>, and <code>--sandbox-bind-home</code>
            (when builder bootstrap needed home directory access). The key point is not one exact flag combo; the key
            point is that access is intentional, reviewable, and debuggable.
          </p>

          <h2>Other useful ktl build features</h2>
          <p>
            Sandbox is only one part of <code>ktl build</code>. These features are useful in real projects and are worth
            using together.
          </p>

          <ul>
            <li><code>--hermetic</code> (or <code>--locked</code>) to reduce network access and enforce pinned bases.</li>
            <li><code>--secure</code> as a shortcut preset for stricter builds.</li>
            <li><code>--policy</code> and <code>--policy-mode enforce</code> to block builds that fail your rules.</li>
            <li><code>--secrets block</code> to fail on detected secret-leak risks.</li>
            <li><code>--capture ./ktl-capture.sqlite</code> to keep a build event timeline for later debugging.</li>
            <li><code>--ws-listen :9085</code> to stream raw build events to external viewers.</li>
            <li><code>--cache-intel</code> for a fast summary of cache misses and slow steps.</li>
          </ul>

          <p class="code-title">Command</p>
<pre><code>ktl build . \
  -t ghcr.io/acme/app:dev \
  --secure \
  --policy ./policy \
  --secrets block \
  --capture ./ktl-capture.sqlite \
  --cache-intel</code></pre>

          <p>
            You do not need to turn on everything at once. Start with one or two controls, run it in CI for a few days,
            then tighten the defaults.
          </p>

          <h2>Demo Showcase 1: Sandbox doctor + sandboxed build</h2>
          <p>
            The first demo establishes trust in the runtime itself. We start by running doctor probes against the
            selected sandbox policy and runtime binary. Then we run a real Dockerfile build in sandbox mode and stream
            sandbox logs to show exactly what is mounted and executed.
          </p>

          <p class="code-title">Command</p>
<pre><code>ktl build sandbox doctor \
  --sandbox-bin /usr/local/bin/nsjail-oldmnt \
  --sandbox-config sandbox/linux-ci.cfg

ktl build testdata/build/dockerfiles/basic \
  -t local/ktl-sandbox-demo:latest \
  --sandbox \
  --sandbox-bin /usr/local/bin/nsjail-oldmnt \
  --sandbox-config sandbox/linux-ci.cfg \
  --sandbox-bind-home \
  --sandbox-logs \
  --output logs</code></pre>

          <p>
            This demo shows both parts clearly: security controls and a successful build. You can see sandbox lifecycle
            events and still end up with a usable image.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-sandbox.gif" alt="Sandbox doctor and sandboxed ktl build output" loading="lazy" />
            <figcaption>Sandbox doctor checks the runtime, then build logs show the sandbox lifecycle and final image output.</figcaption>
          </figure>

          <h2>Demo Showcase 2: Cache intelligence (cold vs warm)</h2>
          <p>
            Security alone is not enough; teams still need speed. The second demo highlights cache intelligence by
            running the same build twice and comparing results. The first run shows more misses and slow export steps.
            The second run surfaces improved hit ratios and faster path reuse.
          </p>

          <p class="code-title">Command</p>
<pre><code>KTL_SANDBOX_DISABLE=1 ktl build testdata/build/dockerfiles/metadata \
  -t local/ktl-cache-demo:latest \
  --output logs \
  --cache-intel \
  --cache-intel-top 5

# run again with the same command to highlight warm-cache behavior</code></pre>

          <p>
            The cache report is especially useful in reviews because it calls out miss reasons and slow steps instead of
            leaving people to guess why a build got slower. This is the bridge between platform engineering and app teams:
            you can discuss concrete numbers and concrete Dockerfile improvements.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-cache-intel.gif" alt="ktl build cache intelligence output" loading="lazy" />
            <figcaption>Cache intelligence calls out misses, slow steps, and hit ratio so Dockerfile changes are easier to prioritize.</figcaption>
          </figure>

          <h2>Demo Showcase 3: SBOM + provenance attestations</h2>
          <p>
            The third demo focuses on artifact trust. We build with OCI output and write attestations to a dedicated
            directory while enabling SBOM and provenance generation. After the build, we list the produced JSON files
            and inspect the provenance document.
          </p>

          <p class="code-title">Command</p>
<pre><code>KTL_SANDBOX_DISABLE=1 ktl build testdata/build/dockerfiles/basic \
  -t local/ktl-attest-demo:latest \
  --output logs \
  --oci \
  --attest-dir ./out-attest \
  --sbom \
  --provenance

ls -lh ./out-attest</code></pre>

          <p>
            This moves the build from \"we produced an image\" to \"we can explain what is inside it and how it was built.\"
            SBOM gives a component inventory, and provenance records build details in machine-readable form.
          </p>

          <figure class="demo">
            <img src="../assets/ktl-build-attestations.gif" alt="ktl build SBOM and provenance attestation output" loading="lazy" />
            <figcaption>Build output writes SBOM and provenance files, making the image contents and build history traceable.</figcaption>
          </figure>

          <h2>Pragmatic rollout strategy</h2>
          <p>
            If you are adopting this in an existing org, do it in layers. Start with one representative service and one
            sandbox profile. Validate with sandbox doctor. Turn on sandbox logs while tuning. Introduce cache intel reports
            for visibility. Then add SBOM/provenance outputs to release gates. Finally, codify policy and artifacts in PR
            templates so the process becomes routine.
          </p>

          <p>
            This approach avoids trying to enforce everything at once. Add controls in layers, keep the output visible,
            and tune the process as you go.
          </p>

          <h2>Final take</h2>
          <p>
            <code>ktl build</code> is not just a way to build container images. It gives you safer execution,
            better diagnostics, cache visibility, and artifact evidence in one flow.
          </p>

          <p class="note">
            Fast builds matter. Fast builds with clear security controls and traceable output matter more.
          </p>
          <p>
            For flags, examples, and updates, check <a href="https://kubekattle.github.io/ktl/">the ktl docs</a>.
          </p>
        </section>
      </article>
    </main>
  </body>
</html>
