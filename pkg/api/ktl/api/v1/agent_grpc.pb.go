// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ktl/api/v1/agent.proto

package apiv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LogService_StreamLogs_FullMethodName = "/ktl.api.v1.LogService/StreamLogs"
)

// LogServiceClient is the client API for LogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogServiceClient interface {
	StreamLogs(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error)
}

type logServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLogServiceClient(cc grpc.ClientConnInterface) LogServiceClient {
	return &logServiceClient{cc}
}

func (c *logServiceClient) StreamLogs(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LogService_ServiceDesc.Streams[0], LogService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogRequest, LogLine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogService_StreamLogsClient = grpc.ServerStreamingClient[LogLine]

// LogServiceServer is the server API for LogService service.
// All implementations must embed UnimplementedLogServiceServer
// for forward compatibility.
type LogServiceServer interface {
	StreamLogs(*LogRequest, grpc.ServerStreamingServer[LogLine]) error
	mustEmbedUnimplementedLogServiceServer()
}

// UnimplementedLogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLogServiceServer struct{}

func (UnimplementedLogServiceServer) StreamLogs(*LogRequest, grpc.ServerStreamingServer[LogLine]) error {
	return status.Error(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedLogServiceServer) mustEmbedUnimplementedLogServiceServer() {}
func (UnimplementedLogServiceServer) testEmbeddedByValue()                    {}

// UnsafeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServiceServer will
// result in compilation errors.
type UnsafeLogServiceServer interface {
	mustEmbedUnimplementedLogServiceServer()
}

func RegisterLogServiceServer(s grpc.ServiceRegistrar, srv LogServiceServer) {
	// If the following call panics, it indicates UnimplementedLogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LogService_ServiceDesc, srv)
}

func _LogService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServiceServer).StreamLogs(m, &grpc.GenericServerStream[LogRequest, LogLine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogService_StreamLogsServer = grpc.ServerStreamingServer[LogLine]

// LogService_ServiceDesc is the grpc.ServiceDesc for LogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _LogService_StreamLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	BuildService_RunBuild_FullMethodName = "/ktl.api.v1.BuildService/RunBuild"
)

// BuildServiceClient is the client API for BuildService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuildServiceClient interface {
	RunBuild(ctx context.Context, in *RunBuildRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildEvent], error)
}

type buildServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBuildServiceClient(cc grpc.ClientConnInterface) BuildServiceClient {
	return &buildServiceClient{cc}
}

func (c *buildServiceClient) RunBuild(ctx context.Context, in *RunBuildRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BuildService_ServiceDesc.Streams[0], BuildService_RunBuild_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunBuildRequest, BuildEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuildService_RunBuildClient = grpc.ServerStreamingClient[BuildEvent]

// BuildServiceServer is the server API for BuildService service.
// All implementations must embed UnimplementedBuildServiceServer
// for forward compatibility.
type BuildServiceServer interface {
	RunBuild(*RunBuildRequest, grpc.ServerStreamingServer[BuildEvent]) error
	mustEmbedUnimplementedBuildServiceServer()
}

// UnimplementedBuildServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuildServiceServer struct{}

func (UnimplementedBuildServiceServer) RunBuild(*RunBuildRequest, grpc.ServerStreamingServer[BuildEvent]) error {
	return status.Error(codes.Unimplemented, "method RunBuild not implemented")
}
func (UnimplementedBuildServiceServer) mustEmbedUnimplementedBuildServiceServer() {}
func (UnimplementedBuildServiceServer) testEmbeddedByValue()                      {}

// UnsafeBuildServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuildServiceServer will
// result in compilation errors.
type UnsafeBuildServiceServer interface {
	mustEmbedUnimplementedBuildServiceServer()
}

func RegisterBuildServiceServer(s grpc.ServiceRegistrar, srv BuildServiceServer) {
	// If the following call panics, it indicates UnimplementedBuildServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BuildService_ServiceDesc, srv)
}

func _BuildService_RunBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunBuildRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildServiceServer).RunBuild(m, &grpc.GenericServerStream[RunBuildRequest, BuildEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuildService_RunBuildServer = grpc.ServerStreamingServer[BuildEvent]

// BuildService_ServiceDesc is the grpc.ServiceDesc for BuildService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuildService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.BuildService",
	HandlerType: (*BuildServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunBuild",
			Handler:       _BuildService_RunBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	DeployService_Apply_FullMethodName   = "/ktl.api.v1.DeployService/Apply"
	DeployService_Destroy_FullMethodName = "/ktl.api.v1.DeployService/Destroy"
)

// DeployServiceClient is the client API for DeployService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeployServiceClient interface {
	Apply(ctx context.Context, in *DeployApplyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error)
	Destroy(ctx context.Context, in *DeployDestroyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error)
}

type deployServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeployServiceClient(cc grpc.ClientConnInterface) DeployServiceClient {
	return &deployServiceClient{cc}
}

func (c *deployServiceClient) Apply(ctx context.Context, in *DeployApplyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeployService_ServiceDesc.Streams[0], DeployService_Apply_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeployApplyRequest, DeployEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_ApplyClient = grpc.ServerStreamingClient[DeployEvent]

func (c *deployServiceClient) Destroy(ctx context.Context, in *DeployDestroyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeployService_ServiceDesc.Streams[1], DeployService_Destroy_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeployDestroyRequest, DeployEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_DestroyClient = grpc.ServerStreamingClient[DeployEvent]

// DeployServiceServer is the server API for DeployService service.
// All implementations must embed UnimplementedDeployServiceServer
// for forward compatibility.
type DeployServiceServer interface {
	Apply(*DeployApplyRequest, grpc.ServerStreamingServer[DeployEvent]) error
	Destroy(*DeployDestroyRequest, grpc.ServerStreamingServer[DeployEvent]) error
	mustEmbedUnimplementedDeployServiceServer()
}

// UnimplementedDeployServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeployServiceServer struct{}

func (UnimplementedDeployServiceServer) Apply(*DeployApplyRequest, grpc.ServerStreamingServer[DeployEvent]) error {
	return status.Error(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedDeployServiceServer) Destroy(*DeployDestroyRequest, grpc.ServerStreamingServer[DeployEvent]) error {
	return status.Error(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedDeployServiceServer) mustEmbedUnimplementedDeployServiceServer() {}
func (UnimplementedDeployServiceServer) testEmbeddedByValue()                       {}

// UnsafeDeployServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeployServiceServer will
// result in compilation errors.
type UnsafeDeployServiceServer interface {
	mustEmbedUnimplementedDeployServiceServer()
}

func RegisterDeployServiceServer(s grpc.ServiceRegistrar, srv DeployServiceServer) {
	// If the following call panics, it indicates UnimplementedDeployServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeployService_ServiceDesc, srv)
}

func _DeployService_Apply_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeployApplyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeployServiceServer).Apply(m, &grpc.GenericServerStream[DeployApplyRequest, DeployEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_ApplyServer = grpc.ServerStreamingServer[DeployEvent]

func _DeployService_Destroy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeployDestroyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeployServiceServer).Destroy(m, &grpc.GenericServerStream[DeployDestroyRequest, DeployEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_DestroyServer = grpc.ServerStreamingServer[DeployEvent]

// DeployService_ServiceDesc is the grpc.ServiceDesc for DeployService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeployService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.DeployService",
	HandlerType: (*DeployServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Apply",
			Handler:       _DeployService_Apply_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Destroy",
			Handler:       _DeployService_Destroy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	MirrorService_Publish_FullMethodName          = "/ktl.api.v1.MirrorService/Publish"
	MirrorService_Subscribe_FullMethodName        = "/ktl.api.v1.MirrorService/Subscribe"
	MirrorService_ListSessions_FullMethodName     = "/ktl.api.v1.MirrorService/ListSessions"
	MirrorService_GetSession_FullMethodName       = "/ktl.api.v1.MirrorService/GetSession"
	MirrorService_SetSessionMeta_FullMethodName   = "/ktl.api.v1.MirrorService/SetSessionMeta"
	MirrorService_SetSessionStatus_FullMethodName = "/ktl.api.v1.MirrorService/SetSessionStatus"
	MirrorService_DeleteSession_FullMethodName    = "/ktl.api.v1.MirrorService/DeleteSession"
	MirrorService_Export_FullMethodName           = "/ktl.api.v1.MirrorService/Export"
)

// MirrorServiceClient is the client API for MirrorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MirrorServiceClient interface {
	Publish(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MirrorFrame, MirrorAck], error)
	Subscribe(ctx context.Context, in *MirrorSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorFrame], error)
	ListSessions(ctx context.Context, in *MirrorListSessionsRequest, opts ...grpc.CallOption) (*MirrorListSessionsResponse, error)
	GetSession(ctx context.Context, in *MirrorGetSessionRequest, opts ...grpc.CallOption) (*MirrorSession, error)
	SetSessionMeta(ctx context.Context, in *MirrorSetSessionMetaRequest, opts ...grpc.CallOption) (*MirrorSession, error)
	SetSessionStatus(ctx context.Context, in *MirrorSetSessionStatusRequest, opts ...grpc.CallOption) (*MirrorSession, error)
	DeleteSession(ctx context.Context, in *MirrorDeleteSessionRequest, opts ...grpc.CallOption) (*MirrorDeleteSessionResponse, error)
	Export(ctx context.Context, in *MirrorExportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorExportChunk], error)
}

type mirrorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMirrorServiceClient(cc grpc.ClientConnInterface) MirrorServiceClient {
	return &mirrorServiceClient{cc}
}

func (c *mirrorServiceClient) Publish(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MirrorFrame, MirrorAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MirrorService_ServiceDesc.Streams[0], MirrorService_Publish_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MirrorFrame, MirrorAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_PublishClient = grpc.BidiStreamingClient[MirrorFrame, MirrorAck]

func (c *mirrorServiceClient) Subscribe(ctx context.Context, in *MirrorSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorFrame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MirrorService_ServiceDesc.Streams[1], MirrorService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MirrorSubscribeRequest, MirrorFrame]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_SubscribeClient = grpc.ServerStreamingClient[MirrorFrame]

func (c *mirrorServiceClient) ListSessions(ctx context.Context, in *MirrorListSessionsRequest, opts ...grpc.CallOption) (*MirrorListSessionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MirrorListSessionsResponse)
	err := c.cc.Invoke(ctx, MirrorService_ListSessions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorServiceClient) GetSession(ctx context.Context, in *MirrorGetSessionRequest, opts ...grpc.CallOption) (*MirrorSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MirrorSession)
	err := c.cc.Invoke(ctx, MirrorService_GetSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorServiceClient) SetSessionMeta(ctx context.Context, in *MirrorSetSessionMetaRequest, opts ...grpc.CallOption) (*MirrorSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MirrorSession)
	err := c.cc.Invoke(ctx, MirrorService_SetSessionMeta_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorServiceClient) SetSessionStatus(ctx context.Context, in *MirrorSetSessionStatusRequest, opts ...grpc.CallOption) (*MirrorSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MirrorSession)
	err := c.cc.Invoke(ctx, MirrorService_SetSessionStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorServiceClient) DeleteSession(ctx context.Context, in *MirrorDeleteSessionRequest, opts ...grpc.CallOption) (*MirrorDeleteSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MirrorDeleteSessionResponse)
	err := c.cc.Invoke(ctx, MirrorService_DeleteSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirrorServiceClient) Export(ctx context.Context, in *MirrorExportRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorExportChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MirrorService_ServiceDesc.Streams[2], MirrorService_Export_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MirrorExportRequest, MirrorExportChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_ExportClient = grpc.ServerStreamingClient[MirrorExportChunk]

// MirrorServiceServer is the server API for MirrorService service.
// All implementations must embed UnimplementedMirrorServiceServer
// for forward compatibility.
type MirrorServiceServer interface {
	Publish(grpc.BidiStreamingServer[MirrorFrame, MirrorAck]) error
	Subscribe(*MirrorSubscribeRequest, grpc.ServerStreamingServer[MirrorFrame]) error
	ListSessions(context.Context, *MirrorListSessionsRequest) (*MirrorListSessionsResponse, error)
	GetSession(context.Context, *MirrorGetSessionRequest) (*MirrorSession, error)
	SetSessionMeta(context.Context, *MirrorSetSessionMetaRequest) (*MirrorSession, error)
	SetSessionStatus(context.Context, *MirrorSetSessionStatusRequest) (*MirrorSession, error)
	DeleteSession(context.Context, *MirrorDeleteSessionRequest) (*MirrorDeleteSessionResponse, error)
	Export(*MirrorExportRequest, grpc.ServerStreamingServer[MirrorExportChunk]) error
	mustEmbedUnimplementedMirrorServiceServer()
}

// UnimplementedMirrorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMirrorServiceServer struct{}

func (UnimplementedMirrorServiceServer) Publish(grpc.BidiStreamingServer[MirrorFrame, MirrorAck]) error {
	return status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedMirrorServiceServer) Subscribe(*MirrorSubscribeRequest, grpc.ServerStreamingServer[MirrorFrame]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedMirrorServiceServer) ListSessions(context.Context, *MirrorListSessionsRequest) (*MirrorListSessionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSessions not implemented")
}
func (UnimplementedMirrorServiceServer) GetSession(context.Context, *MirrorGetSessionRequest) (*MirrorSession, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSession not implemented")
}
func (UnimplementedMirrorServiceServer) SetSessionMeta(context.Context, *MirrorSetSessionMetaRequest) (*MirrorSession, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSessionMeta not implemented")
}
func (UnimplementedMirrorServiceServer) SetSessionStatus(context.Context, *MirrorSetSessionStatusRequest) (*MirrorSession, error) {
	return nil, status.Error(codes.Unimplemented, "method SetSessionStatus not implemented")
}
func (UnimplementedMirrorServiceServer) DeleteSession(context.Context, *MirrorDeleteSessionRequest) (*MirrorDeleteSessionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSession not implemented")
}
func (UnimplementedMirrorServiceServer) Export(*MirrorExportRequest, grpc.ServerStreamingServer[MirrorExportChunk]) error {
	return status.Error(codes.Unimplemented, "method Export not implemented")
}
func (UnimplementedMirrorServiceServer) mustEmbedUnimplementedMirrorServiceServer() {}
func (UnimplementedMirrorServiceServer) testEmbeddedByValue()                       {}

// UnsafeMirrorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MirrorServiceServer will
// result in compilation errors.
type UnsafeMirrorServiceServer interface {
	mustEmbedUnimplementedMirrorServiceServer()
}

func RegisterMirrorServiceServer(s grpc.ServiceRegistrar, srv MirrorServiceServer) {
	// If the following call panics, it indicates UnimplementedMirrorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MirrorService_ServiceDesc, srv)
}

func _MirrorService_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MirrorServiceServer).Publish(&grpc.GenericServerStream[MirrorFrame, MirrorAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_PublishServer = grpc.BidiStreamingServer[MirrorFrame, MirrorAck]

func _MirrorService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MirrorSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorServiceServer).Subscribe(m, &grpc.GenericServerStream[MirrorSubscribeRequest, MirrorFrame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_SubscribeServer = grpc.ServerStreamingServer[MirrorFrame]

func _MirrorService_ListSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorListSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorServiceServer).ListSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MirrorService_ListSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorServiceServer).ListSessions(ctx, req.(*MirrorListSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorService_GetSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorGetSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorServiceServer).GetSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MirrorService_GetSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorServiceServer).GetSession(ctx, req.(*MirrorGetSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorService_SetSessionMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSetSessionMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorServiceServer).SetSessionMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MirrorService_SetSessionMeta_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorServiceServer).SetSessionMeta(ctx, req.(*MirrorSetSessionMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorService_SetSessionStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorSetSessionStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorServiceServer).SetSessionStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MirrorService_SetSessionStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorServiceServer).SetSessionStatus(ctx, req.(*MirrorSetSessionStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorService_DeleteSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorDeleteSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MirrorServiceServer).DeleteSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MirrorService_DeleteSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MirrorServiceServer).DeleteSession(ctx, req.(*MirrorDeleteSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MirrorService_Export_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MirrorExportRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorServiceServer).Export(m, &grpc.GenericServerStream[MirrorExportRequest, MirrorExportChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_ExportServer = grpc.ServerStreamingServer[MirrorExportChunk]

// MirrorService_ServiceDesc is the grpc.ServiceDesc for MirrorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MirrorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.MirrorService",
	HandlerType: (*MirrorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListSessions",
			Handler:    _MirrorService_ListSessions_Handler,
		},
		{
			MethodName: "GetSession",
			Handler:    _MirrorService_GetSession_Handler,
		},
		{
			MethodName: "SetSessionMeta",
			Handler:    _MirrorService_SetSessionMeta_Handler,
		},
		{
			MethodName: "SetSessionStatus",
			Handler:    _MirrorService_SetSessionStatus_Handler,
		},
		{
			MethodName: "DeleteSession",
			Handler:    _MirrorService_DeleteSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _MirrorService_Publish_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _MirrorService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Export",
			Handler:       _MirrorService_Export_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	VerifyService_Verify_FullMethodName = "/ktl.api.v1.VerifyService/Verify"
)

// VerifyServiceClient is the client API for VerifyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VerifyServiceClient interface {
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VerifyEvent], error)
}

type verifyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVerifyServiceClient(cc grpc.ClientConnInterface) VerifyServiceClient {
	return &verifyServiceClient{cc}
}

func (c *verifyServiceClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VerifyEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VerifyService_ServiceDesc.Streams[0], VerifyService_Verify_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[VerifyRequest, VerifyEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VerifyService_VerifyClient = grpc.ServerStreamingClient[VerifyEvent]

// VerifyServiceServer is the server API for VerifyService service.
// All implementations must embed UnimplementedVerifyServiceServer
// for forward compatibility.
type VerifyServiceServer interface {
	Verify(*VerifyRequest, grpc.ServerStreamingServer[VerifyEvent]) error
	mustEmbedUnimplementedVerifyServiceServer()
}

// UnimplementedVerifyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVerifyServiceServer struct{}

func (UnimplementedVerifyServiceServer) Verify(*VerifyRequest, grpc.ServerStreamingServer[VerifyEvent]) error {
	return status.Error(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedVerifyServiceServer) mustEmbedUnimplementedVerifyServiceServer() {}
func (UnimplementedVerifyServiceServer) testEmbeddedByValue()                       {}

// UnsafeVerifyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VerifyServiceServer will
// result in compilation errors.
type UnsafeVerifyServiceServer interface {
	mustEmbedUnimplementedVerifyServiceServer()
}

func RegisterVerifyServiceServer(s grpc.ServiceRegistrar, srv VerifyServiceServer) {
	// If the following call panics, it indicates UnimplementedVerifyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VerifyService_ServiceDesc, srv)
}

func _VerifyService_Verify_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VerifyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VerifyServiceServer).Verify(m, &grpc.GenericServerStream[VerifyRequest, VerifyEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VerifyService_VerifyServer = grpc.ServerStreamingServer[VerifyEvent]

// VerifyService_ServiceDesc is the grpc.ServiceDesc for VerifyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VerifyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.VerifyService",
	HandlerType: (*VerifyServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Verify",
			Handler:       _VerifyService_Verify_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	AgentInfoService_GetInfo_FullMethodName = "/ktl.api.v1.AgentInfoService/GetInfo"
)

// AgentInfoServiceClient is the client API for AgentInfoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentInfoServiceClient interface {
	GetInfo(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error)
}

type agentInfoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentInfoServiceClient(cc grpc.ClientConnInterface) AgentInfoServiceClient {
	return &agentInfoServiceClient{cc}
}

func (c *agentInfoServiceClient) GetInfo(ctx context.Context, in *AgentInfoRequest, opts ...grpc.CallOption) (*AgentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentInfo)
	err := c.cc.Invoke(ctx, AgentInfoService_GetInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentInfoServiceServer is the server API for AgentInfoService service.
// All implementations must embed UnimplementedAgentInfoServiceServer
// for forward compatibility.
type AgentInfoServiceServer interface {
	GetInfo(context.Context, *AgentInfoRequest) (*AgentInfo, error)
	mustEmbedUnimplementedAgentInfoServiceServer()
}

// UnimplementedAgentInfoServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAgentInfoServiceServer struct{}

func (UnimplementedAgentInfoServiceServer) GetInfo(context.Context, *AgentInfoRequest) (*AgentInfo, error) {
	return nil, status.Error(codes.Unimplemented, "method GetInfo not implemented")
}
func (UnimplementedAgentInfoServiceServer) mustEmbedUnimplementedAgentInfoServiceServer() {}
func (UnimplementedAgentInfoServiceServer) testEmbeddedByValue()                          {}

// UnsafeAgentInfoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentInfoServiceServer will
// result in compilation errors.
type UnsafeAgentInfoServiceServer interface {
	mustEmbedUnimplementedAgentInfoServiceServer()
}

func RegisterAgentInfoServiceServer(s grpc.ServiceRegistrar, srv AgentInfoServiceServer) {
	// If the following call panics, it indicates UnimplementedAgentInfoServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AgentInfoService_ServiceDesc, srv)
}

func _AgentInfoService_GetInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentInfoServiceServer).GetInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentInfoService_GetInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentInfoServiceServer).GetInfo(ctx, req.(*AgentInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentInfoService_ServiceDesc is the grpc.ServiceDesc for AgentInfoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentInfoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.AgentInfoService",
	HandlerType: (*AgentInfoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfo",
			Handler:    _AgentInfoService_GetInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ktl/api/v1/agent.proto",
}
