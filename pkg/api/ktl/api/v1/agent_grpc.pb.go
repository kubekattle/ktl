// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             (unknown)
// source: ktl/api/v1/agent.proto

package apiv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LogService_StreamLogs_FullMethodName = "/ktl.api.v1.LogService/StreamLogs"
)

// LogServiceClient is the client API for LogService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogServiceClient interface {
	StreamLogs(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error)
}

type logServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLogServiceClient(cc grpc.ClientConnInterface) LogServiceClient {
	return &logServiceClient{cc}
}

func (c *logServiceClient) StreamLogs(ctx context.Context, in *LogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LogLine], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LogService_ServiceDesc.Streams[0], LogService_StreamLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LogRequest, LogLine]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogService_StreamLogsClient = grpc.ServerStreamingClient[LogLine]

// LogServiceServer is the server API for LogService service.
// All implementations must embed UnimplementedLogServiceServer
// for forward compatibility.
type LogServiceServer interface {
	StreamLogs(*LogRequest, grpc.ServerStreamingServer[LogLine]) error
	mustEmbedUnimplementedLogServiceServer()
}

// UnimplementedLogServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLogServiceServer struct{}

func (UnimplementedLogServiceServer) StreamLogs(*LogRequest, grpc.ServerStreamingServer[LogLine]) error {
	return status.Error(codes.Unimplemented, "method StreamLogs not implemented")
}
func (UnimplementedLogServiceServer) mustEmbedUnimplementedLogServiceServer() {}
func (UnimplementedLogServiceServer) testEmbeddedByValue()                    {}

// UnsafeLogServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServiceServer will
// result in compilation errors.
type UnsafeLogServiceServer interface {
	mustEmbedUnimplementedLogServiceServer()
}

func RegisterLogServiceServer(s grpc.ServiceRegistrar, srv LogServiceServer) {
	// If the following call panics, it indicates UnimplementedLogServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LogService_ServiceDesc, srv)
}

func _LogService_StreamLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LogServiceServer).StreamLogs(m, &grpc.GenericServerStream[LogRequest, LogLine]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LogService_StreamLogsServer = grpc.ServerStreamingServer[LogLine]

// LogService_ServiceDesc is the grpc.ServiceDesc for LogService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LogService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.LogService",
	HandlerType: (*LogServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLogs",
			Handler:       _LogService_StreamLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	BuildService_RunBuild_FullMethodName = "/ktl.api.v1.BuildService/RunBuild"
)

// BuildServiceClient is the client API for BuildService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BuildServiceClient interface {
	RunBuild(ctx context.Context, in *RunBuildRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildEvent], error)
}

type buildServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBuildServiceClient(cc grpc.ClientConnInterface) BuildServiceClient {
	return &buildServiceClient{cc}
}

func (c *buildServiceClient) RunBuild(ctx context.Context, in *RunBuildRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[BuildEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &BuildService_ServiceDesc.Streams[0], BuildService_RunBuild_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunBuildRequest, BuildEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuildService_RunBuildClient = grpc.ServerStreamingClient[BuildEvent]

// BuildServiceServer is the server API for BuildService service.
// All implementations must embed UnimplementedBuildServiceServer
// for forward compatibility.
type BuildServiceServer interface {
	RunBuild(*RunBuildRequest, grpc.ServerStreamingServer[BuildEvent]) error
	mustEmbedUnimplementedBuildServiceServer()
}

// UnimplementedBuildServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBuildServiceServer struct{}

func (UnimplementedBuildServiceServer) RunBuild(*RunBuildRequest, grpc.ServerStreamingServer[BuildEvent]) error {
	return status.Error(codes.Unimplemented, "method RunBuild not implemented")
}
func (UnimplementedBuildServiceServer) mustEmbedUnimplementedBuildServiceServer() {}
func (UnimplementedBuildServiceServer) testEmbeddedByValue()                      {}

// UnsafeBuildServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BuildServiceServer will
// result in compilation errors.
type UnsafeBuildServiceServer interface {
	mustEmbedUnimplementedBuildServiceServer()
}

func RegisterBuildServiceServer(s grpc.ServiceRegistrar, srv BuildServiceServer) {
	// If the following call panics, it indicates UnimplementedBuildServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BuildService_ServiceDesc, srv)
}

func _BuildService_RunBuild_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunBuildRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildServiceServer).RunBuild(m, &grpc.GenericServerStream[RunBuildRequest, BuildEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type BuildService_RunBuildServer = grpc.ServerStreamingServer[BuildEvent]

// BuildService_ServiceDesc is the grpc.ServiceDesc for BuildService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BuildService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.BuildService",
	HandlerType: (*BuildServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunBuild",
			Handler:       _BuildService_RunBuild_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	DeployService_Apply_FullMethodName   = "/ktl.api.v1.DeployService/Apply"
	DeployService_Destroy_FullMethodName = "/ktl.api.v1.DeployService/Destroy"
)

// DeployServiceClient is the client API for DeployService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DeployServiceClient interface {
	Apply(ctx context.Context, in *DeployApplyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error)
	Destroy(ctx context.Context, in *DeployDestroyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error)
}

type deployServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeployServiceClient(cc grpc.ClientConnInterface) DeployServiceClient {
	return &deployServiceClient{cc}
}

func (c *deployServiceClient) Apply(ctx context.Context, in *DeployApplyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeployService_ServiceDesc.Streams[0], DeployService_Apply_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeployApplyRequest, DeployEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_ApplyClient = grpc.ServerStreamingClient[DeployEvent]

func (c *deployServiceClient) Destroy(ctx context.Context, in *DeployDestroyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DeployEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DeployService_ServiceDesc.Streams[1], DeployService_Destroy_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[DeployDestroyRequest, DeployEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_DestroyClient = grpc.ServerStreamingClient[DeployEvent]

// DeployServiceServer is the server API for DeployService service.
// All implementations must embed UnimplementedDeployServiceServer
// for forward compatibility.
type DeployServiceServer interface {
	Apply(*DeployApplyRequest, grpc.ServerStreamingServer[DeployEvent]) error
	Destroy(*DeployDestroyRequest, grpc.ServerStreamingServer[DeployEvent]) error
	mustEmbedUnimplementedDeployServiceServer()
}

// UnimplementedDeployServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeployServiceServer struct{}

func (UnimplementedDeployServiceServer) Apply(*DeployApplyRequest, grpc.ServerStreamingServer[DeployEvent]) error {
	return status.Error(codes.Unimplemented, "method Apply not implemented")
}
func (UnimplementedDeployServiceServer) Destroy(*DeployDestroyRequest, grpc.ServerStreamingServer[DeployEvent]) error {
	return status.Error(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedDeployServiceServer) mustEmbedUnimplementedDeployServiceServer() {}
func (UnimplementedDeployServiceServer) testEmbeddedByValue()                       {}

// UnsafeDeployServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeployServiceServer will
// result in compilation errors.
type UnsafeDeployServiceServer interface {
	mustEmbedUnimplementedDeployServiceServer()
}

func RegisterDeployServiceServer(s grpc.ServiceRegistrar, srv DeployServiceServer) {
	// If the following call panics, it indicates UnimplementedDeployServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeployService_ServiceDesc, srv)
}

func _DeployService_Apply_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeployApplyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeployServiceServer).Apply(m, &grpc.GenericServerStream[DeployApplyRequest, DeployEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_ApplyServer = grpc.ServerStreamingServer[DeployEvent]

func _DeployService_Destroy_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DeployDestroyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DeployServiceServer).Destroy(m, &grpc.GenericServerStream[DeployDestroyRequest, DeployEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DeployService_DestroyServer = grpc.ServerStreamingServer[DeployEvent]

// DeployService_ServiceDesc is the grpc.ServiceDesc for DeployService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeployService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.DeployService",
	HandlerType: (*DeployServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Apply",
			Handler:       _DeployService_Apply_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Destroy",
			Handler:       _DeployService_Destroy_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}

const (
	MirrorService_Publish_FullMethodName   = "/ktl.api.v1.MirrorService/Publish"
	MirrorService_Subscribe_FullMethodName = "/ktl.api.v1.MirrorService/Subscribe"
)

// MirrorServiceClient is the client API for MirrorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MirrorServiceClient interface {
	Publish(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MirrorFrame, MirrorAck], error)
	Subscribe(ctx context.Context, in *MirrorSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorFrame], error)
}

type mirrorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMirrorServiceClient(cc grpc.ClientConnInterface) MirrorServiceClient {
	return &mirrorServiceClient{cc}
}

func (c *mirrorServiceClient) Publish(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[MirrorFrame, MirrorAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MirrorService_ServiceDesc.Streams[0], MirrorService_Publish_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MirrorFrame, MirrorAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_PublishClient = grpc.BidiStreamingClient[MirrorFrame, MirrorAck]

func (c *mirrorServiceClient) Subscribe(ctx context.Context, in *MirrorSubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MirrorFrame], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MirrorService_ServiceDesc.Streams[1], MirrorService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[MirrorSubscribeRequest, MirrorFrame]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_SubscribeClient = grpc.ServerStreamingClient[MirrorFrame]

// MirrorServiceServer is the server API for MirrorService service.
// All implementations must embed UnimplementedMirrorServiceServer
// for forward compatibility.
type MirrorServiceServer interface {
	Publish(grpc.BidiStreamingServer[MirrorFrame, MirrorAck]) error
	Subscribe(*MirrorSubscribeRequest, grpc.ServerStreamingServer[MirrorFrame]) error
	mustEmbedUnimplementedMirrorServiceServer()
}

// UnimplementedMirrorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMirrorServiceServer struct{}

func (UnimplementedMirrorServiceServer) Publish(grpc.BidiStreamingServer[MirrorFrame, MirrorAck]) error {
	return status.Error(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedMirrorServiceServer) Subscribe(*MirrorSubscribeRequest, grpc.ServerStreamingServer[MirrorFrame]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedMirrorServiceServer) mustEmbedUnimplementedMirrorServiceServer() {}
func (UnimplementedMirrorServiceServer) testEmbeddedByValue()                       {}

// UnsafeMirrorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MirrorServiceServer will
// result in compilation errors.
type UnsafeMirrorServiceServer interface {
	mustEmbedUnimplementedMirrorServiceServer()
}

func RegisterMirrorServiceServer(s grpc.ServiceRegistrar, srv MirrorServiceServer) {
	// If the following call panics, it indicates UnimplementedMirrorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MirrorService_ServiceDesc, srv)
}

func _MirrorService_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MirrorServiceServer).Publish(&grpc.GenericServerStream[MirrorFrame, MirrorAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_PublishServer = grpc.BidiStreamingServer[MirrorFrame, MirrorAck]

func _MirrorService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MirrorSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MirrorServiceServer).Subscribe(m, &grpc.GenericServerStream[MirrorSubscribeRequest, MirrorFrame]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MirrorService_SubscribeServer = grpc.ServerStreamingServer[MirrorFrame]

// MirrorService_ServiceDesc is the grpc.ServiceDesc for MirrorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MirrorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ktl.api.v1.MirrorService",
	HandlerType: (*MirrorServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _MirrorService_Publish_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _MirrorService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ktl/api/v1/agent.proto",
}
