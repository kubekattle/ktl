syntax = "proto3";

package ktl.api.v1;

option go_package = "github.com/kubekattle/ktl/pkg/api/ktl/api/v1;apiv1";

message AgentInfoRequest {}

message AgentInfo {
  // These fields mirror `ktl version` output so callers can sanity-check
  // compatibility before issuing long-running streaming RPCs.
  string version = 1;
  string git_commit = 2;
  string git_tree_state = 3;
  string build_date = 4;
  string go_version = 5;
  string platform = 6;
}

message LogRequest {
  string pod_query = 1;
  repeated string namespaces = 2;
  bool all_namespaces = 3;
  string label_selector = 4;
  string field_selector = 5;
  repeated string containers = 6;
  repeated string exclude_containers = 7;
  repeated string exclude_pods = 8;
  repeated string highlight_terms = 9;
  bool include_events = 10;
  bool events_only = 11;
  int64 tail_lines = 12;
  bool follow = 13;
  bool timestamps = 14;
  string template = 15;
  string kube_context = 16;
  string kubeconfig_path = 17;
  string session_id = 18;
  string requester = 19;
}

message LogLine {
  int64 timestamp_unix_nano = 1;
  string formatted_timestamp = 2;
  string namespace = 3;
  string pod = 4;
  string container = 5;
  string raw = 6;
  string rendered = 7;
  string source = 8;
  string source_glyph = 9;
  bool rendered_equals_raw = 10;
}

message BuildOptions {
  string context_dir = 1;
  string dockerfile = 2;
  repeated string tags = 3;
  repeated string platforms = 4;
  repeated string build_args = 5;
  repeated string secrets = 6;
  repeated string cache_from = 7;
  repeated string cache_to = 8;
  bool push = 9;
  bool load = 10;
  bool no_cache = 11;
  string builder = 12;
  string cache_dir = 13;
  bool interactive = 14;
  string interactive_shell = 15;
  string build_mode = 16;
  repeated string compose_files = 17;
  repeated string compose_profiles = 18;
  repeated string compose_services = 19;
  string compose_project = 20;
  string auth_file = 21;
  string sandbox_config = 22;
  string sandbox_bin = 23;
  repeated string sandbox_binds = 24;
  string sandbox_workdir = 25;
  bool sandbox_logs = 26;
  string log_file = 27;
  bool remove_intermediate = 28;
  bool quiet = 29;
  string docker_context = 30;
}

message RunBuildRequest {
  BuildOptions options = 1;
  string session_id = 2;
  string requester = 3;
}

message BuildResult {
  repeated string tags = 1;
  string digest = 2;
  string oci_output_dir = 3;
  string error = 4;
}

message BuildEvent {
  int64 timestamp_unix_nano = 1;
  oneof body {
    LogLine log = 2;
    BuildResult result = 3;
  }
}

message DeployEvent {
  string json = 1;
}

message DeployApplyOptions {
  string release = 1;
  string chart = 2;
  string namespace = 3;
  string version = 4;
  repeated string values_files = 5;
  repeated string set_values = 6;
  repeated string set_string_values = 7;
  repeated string set_file_values = 8;
  int64 timeout_seconds = 9;
  bool wait = 10;
  bool atomic = 11;
  bool upgrade_only = 12;
  bool create_namespace = 13;
  bool dry_run = 14;
  bool diff = 15;
  string kube_context = 16;
  string kubeconfig_path = 17;
}

message DeployApplyRequest {
  DeployApplyOptions options = 1;
  string session_id = 2;
  string requester = 3;
}

message DeployDestroyOptions {
  string release = 1;
  string namespace = 2;
  int64 timeout_seconds = 3;
  bool wait = 4;
  bool keep_history = 5;
  bool dry_run = 6;
  bool force = 7;
  bool disable_hooks = 8;
  string kube_context = 9;
  string kubeconfig_path = 10;
}

message DeployDestroyRequest {
  DeployDestroyOptions options = 1;
  string session_id = 2;
  string requester = 3;
}

message MirrorFrame {
  string session_id = 1;
  string producer = 2;
  uint64 sequence = 3; // assigned by server
  int64 received_unix_nano = 4; // server receipt timestamp
  oneof payload {
    LogLine log = 10;
    BuildEvent build = 11;
    DeployEvent deploy = 12;
    VerifyEvent verify = 14;
    bytes raw = 13;
  }
}

message MirrorAck {
  string session_id = 1;
  string message = 2;
  uint64 sequence = 3;
}

message MirrorSubscribeRequest {
  string session_id = 1;
  bool replay = 2;
  uint64 from_sequence = 3;
}

message MirrorSessionMeta {
  // `command` and `args` aim to preserve the caller's original intent (CLI or IDE action),
  // while the other fields are optional context for indexing and UI.
  string command = 1;
  repeated string args = 2;
  string requester = 3;
  string cluster = 4;
  string kube_context = 5;
  string namespace = 6;
  string release = 7;
  string chart = 8;
}

message MirrorSession {
  string session_id = 1;
  int64 created_unix_nano = 2;
  int64 last_seen_unix_nano = 3;
  uint64 last_sequence = 4;
  MirrorSessionMeta meta = 5;
  map<string,string> tags = 6;
  MirrorSessionStatus status = 7;
}

enum MirrorSessionState {
  MIRROR_SESSION_STATE_UNSPECIFIED = 0;
  MIRROR_SESSION_STATE_RUNNING = 1;
  MIRROR_SESSION_STATE_DONE = 2;
  MIRROR_SESSION_STATE_ERROR = 3;
}

message MirrorSessionStatus {
  MirrorSessionState state = 1;
  int32 exit_code = 2;
  string error_message = 3;
  int64 completed_unix_nano = 4;
}

message MirrorListSessionsRequest {
  int32 limit = 1;
  // Optional query filters (exact match unless noted).
  // - meta.command: case-insensitive substring match.
  // - other meta fields: case-insensitive exact match.
  // - tags: require all key/value pairs to match.
  MirrorSessionMeta meta = 2;
  map<string,string> tags = 3;
  MirrorSessionState state = 4;
  int64 since_last_seen_unix_nano = 5;
  int64 until_last_seen_unix_nano = 6;
}

message MirrorListSessionsResponse {
  repeated MirrorSession sessions = 1;
}

message MirrorGetSessionRequest {
  string session_id = 1;
}

message MirrorSetSessionMetaRequest {
  string session_id = 1;
  MirrorSessionMeta meta = 2;
  map<string,string> tags = 3;
}

message MirrorSetSessionStatusRequest {
  string session_id = 1;
  MirrorSessionStatus status = 2;
}

message MirrorDeleteSessionRequest {
  string session_id = 1;
}

message MirrorDeleteSessionResponse {
  bool deleted = 1;
}

message MirrorExportRequest {
  string session_id = 1;
  string format = 2; // "jsonl" (default)
  uint64 from_sequence = 3;
}

message MirrorExportChunk {
  bytes data = 1;
}

message VerifyChartOptions {
  string chart = 1;
  string release = 2;
  string namespace = 3;
  string version = 4;
  repeated string values_files = 5;
  repeated string set_values = 6;
  repeated string set_string_values = 7;
  repeated string set_file_values = 8;
  string kube_context = 9;
  string kubeconfig_path = 10;
}

message VerifyNamespaceOptions {
  string namespace = 1;
  string kube_context = 2;
  string kubeconfig_path = 3;
}

message VerifyOptions {
  string mode = 1;        // warn|block|off
  string fail_on = 2;     // info|low|medium|high|critical
  string format = 3;      // table|json|sarif
  string rules_dir = 4;   // optional
  string policy = 5;      // optional policy bundle ref
  string policy_mode = 6; // warn|enforce
  string baseline = 7;    // optional baseline report path
}

message VerifyRequest {
  VerifyOptions options = 1;
  oneof target {
    VerifyChartOptions chart = 2;
    VerifyNamespaceOptions namespace = 3;
  }
  string session_id = 4;
  string requester = 5;
}

message VerifyEvent {
  int64 timestamp_unix_nano = 1;
  oneof body {
    VerifyStarted started = 10;
    VerifyProgress progress = 11;
    VerifyFinding finding = 12;
    VerifySummary summary = 13;
    VerifyDone done = 14;
    string json = 15; // backward-compatible full report (optional)
  }
}

message VerifyStarted {
  string target = 1;       // "chart" or "namespace"
  string ruleset = 2;      // builtin@<sha256>
  string policy_ref = 3;   // optional
  string policy_mode = 4;  // warn|enforce
}

message VerifyProgress {
  string phase = 1; // collect|evaluate|done
  map<string,int32> counts_by_kind = 2;
}

message VerifySubject {
  string kind = 1;
  string namespace = 2;
  string name = 3;
}

message VerifyFinding {
  string rule_id = 1;
  string severity = 2;
  string category = 3;
  string message = 4;
  string location = 5;
  VerifySubject subject = 6;
  string help_url = 7;
}

message VerifySummary {
  int32 total = 1;
  map<string,int32> by_severity = 2;
  bool blocked = 3;
}

message VerifyDone {
  bool passed = 1;
  bool blocked = 2;
}

service LogService {
  rpc StreamLogs(LogRequest) returns (stream LogLine);
}

service BuildService {
  rpc RunBuild(RunBuildRequest) returns (stream BuildEvent);
}

service DeployService {
  rpc Apply(DeployApplyRequest) returns (stream DeployEvent);
  rpc Destroy(DeployDestroyRequest) returns (stream DeployEvent);
}

service MirrorService {
  rpc Publish(stream MirrorFrame) returns (stream MirrorAck);
  rpc Subscribe(MirrorSubscribeRequest) returns (stream MirrorFrame);
  rpc ListSessions(MirrorListSessionsRequest) returns (MirrorListSessionsResponse);
  rpc GetSession(MirrorGetSessionRequest) returns (MirrorSession);
  rpc SetSessionMeta(MirrorSetSessionMetaRequest) returns (MirrorSession);
  rpc SetSessionStatus(MirrorSetSessionStatusRequest) returns (MirrorSession);
  rpc DeleteSession(MirrorDeleteSessionRequest) returns (MirrorDeleteSessionResponse);
  rpc Export(MirrorExportRequest) returns (stream MirrorExportChunk);
}

service VerifyService {
  rpc Verify(VerifyRequest) returns (stream VerifyEvent);
}

service AgentInfoService {
  rpc GetInfo(AgentInfoRequest) returns (AgentInfo);
}
